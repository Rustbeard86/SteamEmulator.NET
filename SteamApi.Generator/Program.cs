using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;
using SteamApi.Generator;

// Paths
var workspaceRoot = Path.GetFullPath(Path.Combine(AppContext.BaseDirectory, "../../../.."));
var jsonPath = Path.Combine(workspaceRoot, "steamworks_sdk_163", "sdk", "public", "steam", "steam_api.json");
var referenceDllPath = Path.Combine(workspaceRoot, "steamworks_sdk_163", "sdk", "redistributable_bin", "win64",
    "steam_api64.dll");
var outputDir = Path.Combine(workspaceRoot, "steam_api", "Generated");

// Debug: check keys
var jsonContent = File.ReadAllText(jsonPath);
using var doc = JsonDocument.Parse(jsonContent);
foreach (var prop in doc.RootElement.EnumerateObject()) Console.WriteLine($"JSON Root Key: {prop.Name}");

Console.WriteLine($"Loading JSON from {jsonPath}");

JsonSerializerOptions jsonSerializerOptions = new()
{
    PropertyNameCaseInsensitive = true,
    ReadCommentHandling = JsonCommentHandling.Skip
};

var api = JsonSerializer.Deserialize<SteamApiDefinition>(File.ReadAllText(jsonPath), jsonSerializerOptions) ??
          throw new InvalidOperationException("Failed to parse steam_api.json");

// Initialize TypeDB
TypeDb.Init(api);

Console.WriteLine($"Reading exports from {referenceDllPath}");
var exports = PeReader.GetExports(referenceDllPath);
Console.WriteLine($"Found {exports.Count} exports.");

Directory.CreateDirectory(outputDir);

// Generate ArchConfig
File.WriteAllText(Path.Combine(outputDir, "ArchConfig.cs"), Generator.GenerateArchConfig());

// Generate Interfaces & VTables
var interfaceSb = new StringBuilder();
var shimSb = new StringBuilder();
var logicSb = new StringBuilder();

interfaceSb.AppendLine("// <auto-generated/>");
interfaceSb.AppendLine("#nullable enable");
interfaceSb.AppendLine("using System;");
interfaceSb.AppendLine("using System.Runtime.InteropServices;");
interfaceSb.AppendLine("namespace SteamEmulator;");
interfaceSb.AppendLine();

shimSb.AppendLine("// <auto-generated/>");
shimSb.AppendLine("#nullable enable");
shimSb.AppendLine("using System;");
shimSb.AppendLine("using System.Runtime.InteropServices;");
shimSb.AppendLine("using System.Runtime.CompilerServices;");
shimSb.AppendLine("namespace SteamEmulator;");
shimSb.AppendLine();

logicSb.AppendLine("// <auto-generated/>");
logicSb.AppendLine("#nullable enable");
logicSb.AppendLine("using System;");
logicSb.AppendLine("namespace SteamEmulator;");
logicSb.AppendLine();

// Generate Interfaces
foreach (var iface in api.Interfaces)
{
    // Pre-pass: Resolve Logical Names
    Generator.ResolveLogicNames(iface);

    var vtableCode = Generator.GenerateVTable(iface);
    interfaceSb.AppendLine(vtableCode);

    var logicCode = Generator.GenerateLogicInterface(iface);
    logicSb.AppendLine(logicCode);

    var stubCode = Generator.GenerateLogicStub(iface);
    logicSb.AppendLine(stubCode);

    var shimCode = Generator.GenerateShim(iface);
    shimSb.AppendLine(shimCode);

    // We generate extensions for ALL interfaces to ensure full coverage
    // even if multiple versions exist.
}

File.WriteAllText(Path.Combine(outputDir, "SteamInterfaces.cs"), interfaceSb.ToString());
File.WriteAllText(Path.Combine(outputDir, "SteamShims.cs"), shimSb.ToString());
File.WriteAllText(Path.Combine(outputDir, "SteamLogic.cs"), logicSb.ToString());
File.WriteAllText(Path.Combine(outputDir, "SteamExtensions.cs"), Generator.GenerateAllExtensions(api.Interfaces));

// Generate Manager (SteamManager.g.cs)
var managerCode = Generator.GenerateManagerStubRegistration(api.Interfaces, api.Functions);
File.WriteAllText(Path.Combine(outputDir, "SteamManager.g.cs"), managerCode);

// Generate Global Accessors (SteamExports)
var (exportsCode, activeShims) = Generator.GenerateExports(api.Interfaces, exports, api.Functions);
File.WriteAllText(Path.Combine(outputDir, "SteamExports.g.cs"), exportsCode);

// Generate DEF file
var exportsBodySb = new StringBuilder();

// Track handled ordinals to export
foreach (var (name, ordinal) in activeShims.OrderBy(x => x.Ordinal))
    if (ordinal > 0)
        exportsBodySb.AppendLine($"    {name} @{ordinal}");
    else
        // Fallback for items without specific ordinal (shouldn't happen for DLL match parity)
        exportsBodySb.AppendLine($"    {name}");

var def64 = new StringBuilder();
def64.AppendLine("LIBRARY steam_api64");
def64.AppendLine("EXPORTS");
def64.Append(exportsBodySb);

var def32 = new StringBuilder();
def32.AppendLine("LIBRARY steam_api");
def32.AppendLine("EXPORTS");
def32.Append(exportsBodySb);

File.WriteAllText(Path.Combine(outputDir, "steam_api64.def"), def64.ToString());
File.WriteAllText(Path.Combine(outputDir, "steam_api.def"), def32.ToString());

Console.WriteLine("Done.");

namespace SteamApi.Generator
{
// ----------------------------------------------------------------------------
// Generator Logic
// ----------------------------------------------------------------------------

    public static class Generator
    {
        public static string GenerateArchConfig()
        {
            return """
                   // <auto-generated/>
                   #nullable enable
                   namespace SteamEmulator;

                   public static class ArchConfig
                   {
                   #if TARGET_64BIT
                       public const int PACK = 8;
                   #else
                       public const int PACK = 4;
                   #endif
                   }
                   """;
        }

        public static string GenerateVTable(InterfaceDef iface)
        {
            var sb = new StringBuilder();
            sb.AppendLine("[StructLayout(LayoutKind.Sequential, Pack = ArchConfig.PACK)]");
            sb.AppendLine($"public unsafe struct {iface.ClassName}VTable");
            sb.AppendLine("{");

            foreach (var method in iface.Methods) sb.AppendLine($"    public IntPtr {method.LogicName};");
            sb.AppendLine("}");
            return sb.ToString();
        }

        public static string GenerateLogicInterface(InterfaceDef iface)
        {
            var sb = new StringBuilder();
            var logicName = iface.ClassName + "Logic";

            sb.AppendLine($"public interface {logicName}");
            sb.AppendLine("{");
            foreach (var method in iface.Methods)
            {
                sb.Append($"    {TypeDb.MapType(method.ReturnType)} {method.LogicName}({Generics(method.Params)})");
                sb.AppendLine(";");
            }

            sb.AppendLine("}");
            return sb.ToString();

            static string Generics(List<ParamDef> parameters)
            {
                var parts = new List<string>();
                foreach (var p in parameters) parts.Add($"{TypeDb.MapType(p.ParamType)} {CleanParamName(p.ParamName)}");
                return string.Join(", ", parts);
            }
        }

        public static string GenerateLogicStub(InterfaceDef iface)
        {
            var sb = new StringBuilder();
            var interfaceName = iface.ClassName + "Logic";
            var stubName = iface.ClassName + "Stub";

            sb.AppendLine($"public class {stubName} : {interfaceName}");
            sb.AppendLine("{");

            // C# 14 'field' keyword usage demo
            sb.AppendLine("    public object? UserContext { get => field; set => field = value; }");
            sb.AppendLine();

            foreach (var method in iface.Methods)
            {
                sb.Append(
                    $"    public {TypeDb.MapType(method.ReturnType)} {method.LogicName}({Generics(method.Params)})");
                sb.AppendLine();
                sb.AppendLine("    {");
                sb.AppendLine(
                    $"        throw new NotImplementedException(\"{method.LogicName} not implemented in stub\");");
                sb.AppendLine("    }");
            }

            sb.AppendLine("}");
            return sb.ToString();

            static string Generics(List<ParamDef> parameters)
            {
                var parts = new List<string>();
                foreach (var p in parameters) parts.Add($"{TypeDb.MapType(p.ParamType)} {CleanParamName(p.ParamName)}");
                return string.Join(", ", parts);
            }
        }

        public static string GenerateShim(InterfaceDef iface)
        {
            var sb = new StringBuilder();
            var logicInterface = iface.ClassName + "Logic";

            sb.AppendLine($"public unsafe class {iface.ClassName}Shim");
            sb.AppendLine("{");
            sb.AppendLine($"    public static {iface.ClassName}VTable VTable;");
            sb.AppendLine("    public static IntPtr VTablePtr;");

            sb.AppendLine();
            sb.AppendLine($"    static {iface.ClassName}Shim()");
            sb.AppendLine("    {");
            sb.AppendLine("        VTablePtr = (IntPtr)Unsafe.AsPointer(ref VTable);");
            // Initialize VTable pointers
            foreach (var method in iface.Methods)
            {
                var stubName = $"{iface.ClassName}_{method.LogicName}";
                sb.AppendLine(
                    $"        VTable.{method.LogicName} = (IntPtr)(delegate* unmanaged[Cdecl]<{GetSigTypes(method, true)}>)&{stubName};");
            }

            sb.AppendLine("    }");

            // Factory Method
            sb.AppendLine();
            sb.AppendLine($"    public static IntPtr Create({logicInterface} logic)");
            sb.AppendLine("    {");
            sb.AppendLine("        var handle = GCHandle.Alloc(logic);");
            sb.AppendLine("        var ptr = Marshal.AllocHGlobal(IntPtr.Size * 2);");
            sb.AppendLine("        *(IntPtr*)ptr = VTablePtr;");
            sb.AppendLine("        *(IntPtr*)((byte*)ptr + IntPtr.Size) = GCHandle.ToIntPtr(handle);");
            sb.AppendLine("        // Track for cleanup");
            sb.AppendLine("        SteamExports.RegisterShim(ptr, Dispose);");
            sb.AppendLine("        return ptr;");
            sb.AppendLine("    }");

            // Dispose Method
            sb.AppendLine();
            sb.AppendLine("    public static void Dispose(IntPtr pThis)");
            sb.AppendLine("    {");
            sb.AppendLine("        if (pThis == IntPtr.Zero) return;");
            sb.AppendLine("        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);");
            sb.AppendLine("        if (handlePtr != IntPtr.Zero)");
            sb.AppendLine("        {");
            sb.AppendLine("             var handle = GCHandle.FromIntPtr(handlePtr);");
            sb.AppendLine("             if (handle.IsAllocated) handle.Free();");
            sb.AppendLine("        }");
            sb.AppendLine("        Marshal.FreeHGlobal(pThis);");
            sb.AppendLine("    }");

            foreach (var method in iface.Methods)
            {
                var stubName = $"{iface.ClassName}_{method.LogicName}";
                sb.AppendLine();
                sb.AppendLine("    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]");
                sb.Append($"    public static {TypeDb.MapType(method.ReturnType)} {stubName}(IntPtr pThis");

                foreach (var p in method.Params)
                    sb.Append($", {TypeDb.MapType(p.ParamType)} {CleanParamName(p.ParamName)}");
                sb.AppendLine(")");
                sb.AppendLine("    {");
                sb.AppendLine("        var __thisPtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);");
                sb.AppendLine("        var __thisHandle = GCHandle.FromIntPtr(__thisPtr);");
                sb.AppendLine($"        var __logic = ({logicInterface})__thisHandle.Target!;");

                if (method.ReturnType != "void")
                    sb.Append($"        return __logic.{method.LogicName}(");
                else
                    sb.Append($"        __logic.{method.LogicName}(");

                for (var i = 0; i < method.Params.Count; i++)
                {
                    sb.Append($"{CleanParamName(method.Params[i].ParamName)}");
                    if (i < method.Params.Count - 1) sb.Append(", ");
                }

                sb.AppendLine(");");
                sb.AppendLine("    }");
            }

            sb.AppendLine("}");
            return sb.ToString();
        }

        public static (string Code, List<(string Name, int Ordinal)> ActiveShims) GenerateExports(
            List<InterfaceDef> interfaces, List<ExportInfo> exports, List<FunctionDef> functions)
        {
            var sb = new StringBuilder();
            var activeShims = new List<(string, int)>();
            var usedExportNames = new HashSet<string>();
            var cacheFields = new List<string>();

            // Map Interface Name (e.g. SteamUser) to Entry Point (e.g. SteamUser_Entry)
            var interfaceToEntryMap = new Dictionary<string, string>();
            foreach (var iface in interfaces)
            {
                // Heuristic: Accessor name logic from previous step
                var accessorName =
                    iface.Accessors.FirstOrDefault()?.Name ?? iface.ClassName[1..]; // Remove 'I' -> SteamUser
                interfaceToEntryMap[iface.ClassName] = $"{accessorName}_Entry";
                // Also map clean name "SteamUser" -> "SteamUser_Entry"
                interfaceToEntryMap[accessorName] = $"{accessorName}_Entry";
            }

            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine("#nullable enable");
            sb.AppendLine("using System;");
            sb.AppendLine("using System.Runtime.InteropServices;");
            sb.AppendLine("using System.Collections.Concurrent;");
            sb.AppendLine("using System.Collections.Generic;");
            sb.AppendLine("namespace SteamEmulator;");
            sb.AppendLine();
            sb.AppendLine("public static class SteamExports");
            sb.AppendLine("{");

            // Tracking logic for cleanup
            sb.AppendLine(
                "    private static readonly ConcurrentDictionary<IntPtr, Action<IntPtr>> _activeShims = new();");
            sb.AppendLine(
                "    public static void RegisterShim(IntPtr shim, Action<IntPtr> disposer) => _activeShims.TryAdd(shim, disposer);");
            sb.AppendLine();

            // 1. Flat API Exports (from Methods)
            foreach (var iface in interfaces)
            {
                var logicInterface = iface.ClassName + "Logic";

                foreach (var method in iface.Methods)
                {
                    var flatName = method.MethodNameFlat;
                    if (string.IsNullOrEmpty(flatName)) continue;

                    // Check if this flat name is in DLL exports
                    var ordinal = exports.FirstOrDefault(e => e.Name == flatName)?.Ordinal ?? -1;
                    if (ordinal == -1) continue; // Not exported in this DLL version

                    sb.AppendLine($"    [UnmanagedCallersOnly(EntryPoint = \"{flatName}\")]");
                    sb.Append($"    public static {TypeDb.MapType(method.ReturnType)} {flatName}(IntPtr pThis");
                    foreach (var p in method.Params)
                        sb.Append($", {TypeDb.MapType(p.ParamType)} {CleanParamName(p.ParamName)}");
                    sb.AppendLine(")");
                    sb.AppendLine("    {");
                    // Implementation: Resolve pThis to Logic and call
                    // Note: pThis here is the interface pointer (VTable pointer)
                    sb.AppendLine("        unsafe {");
                    sb.AppendLine("            var __thisPtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);");
                    sb.AppendLine("            var __thisHandle = GCHandle.FromIntPtr(__thisPtr);");
                    sb.AppendLine($"            var __logic = ({logicInterface})__thisHandle.Target!;");

                    if (method.ReturnType != "void")
                        sb.Append($"            return __logic.{method.LogicName}(");
                    else
                        sb.Append($"            __logic.{method.LogicName}(");

                    for (var i = 0; i < method.Params.Count; i++)
                    {
                        sb.Append($"{CleanParamName(method.Params[i].ParamName)}");
                        if (i < method.Params.Count - 1) sb.Append(", ");
                    }

                    sb.AppendLine(");");
                    sb.AppendLine("        }");
                    sb.AppendLine("    }");
                    sb.AppendLine();

                    activeShims.Add((flatName, ordinal));
                    usedExportNames.Add(flatName);
                }
            }

            // 2. Accessors (if they match exports)
            foreach (var iface in interfaces)
            foreach (var acc in iface.Accessors)
            {
                var exportName = acc.Name;
                if (usedExportNames.Contains(exportName)) continue;

                var ordinal = exports.FirstOrDefault(e => e.Name == exportName)?.Ordinal ?? -1;

                // Caching for accessors
                var cacheField = $"_cache_{exportName}";
                cacheFields.Add(cacheField);

                sb.AppendLine($"    private static IntPtr {cacheField};");

                sb.AppendLine($"    [UnmanagedCallersOnly(EntryPoint = \"{exportName}\")]");
                sb.AppendLine($"    public static IntPtr {exportName}_Entry()");
                sb.AppendLine("    {");
                sb.AppendLine($"        if ({cacheField} != IntPtr.Zero) return {cacheField};");
                sb.AppendLine(
                    $"        var logic = SteamEmulator.Manager.GetImplementation<{iface.ClassName}Logic>();");
                sb.AppendLine($"        {cacheField} = {iface.ClassName}Shim.Create(logic);");
                sb.AppendLine($"        return {cacheField};");
                sb.AppendLine("    }");
                sb.AppendLine();

                if (ordinal != -1)
                {
                    activeShims.Add((exportName, ordinal));
                    usedExportNames.Add(exportName);
                }
            }

            // 3. Global Functions (Core Lifecycle & Versioned Accessors)
            foreach (var func in functions)
            {
                var funcName = func.FunctionName;
                var entryPoint = !string.IsNullOrEmpty(func.FunctionNameFlat) ? func.FunctionNameFlat : funcName;

                if (usedExportNames.Contains(entryPoint)) continue;

                // Skip SteamInternal_CreateInterface here, we handle it specially later or if it appears in exports
                if (funcName == "SteamInternal_CreateInterface") continue;

                var ordinal = exports.FirstOrDefault(e => e.Name == entryPoint)?.Ordinal ?? -1;
                if (ordinal == -1) continue;

                sb.AppendLine($"    [UnmanagedCallersOnly(EntryPoint = \"{entryPoint}\")]");
                sb.Append($"    public static {TypeDb.MapType(func.ReturnType)} {funcName}(");

                var paramList = new List<string>();
                foreach (var p in func.Params)
                {
                    var pType = TypeDb.MapType(p.ParamType);
                    var pName = CleanParamName(p.ParamName);
                    sb.Append($"{pType} {pName}");
                    paramList.Add(pName);
                    if (p != func.Params.Last()) sb.Append(", ");
                }

                sb.AppendLine(")");
                sb.AppendLine("    {");

                // Logic Dispatch
                if (funcName.StartsWith("SteamAPI_ISteam") && funcName.Contains("_v"))
                {
                    // Versioned Accessor: SteamAPI_ISteamUser_v023
                    var parts = funcName.Split("_v");
                    if (parts.Length == 2)
                    {
                        var prefix = parts[0].Replace("SteamAPI_I", "");
                        if (interfaceToEntryMap.TryGetValue(prefix, out var entry))
                            sb.AppendLine($"        return {entry}();");
                        else
                            // Fallback
                            CallManager(func, paramList);
                    }
                    else
                    {
                        CallManager(func, paramList);
                    }
                }
                else if (funcName == "SteamAPI_Init")
                {
                    sb.AppendLine("        // Core Lifecycle");
                    sb.AppendLine($"        return SteamEmulator.Manager.{funcName}() ? (byte)1 : (byte)0;");
                }
                else
                {
                    // Core Lifecycle or unknown
                    CallManager(func, paramList);
                }

                sb.AppendLine("    }");
                sb.AppendLine();

                activeShims.Add((entryPoint, ordinal));
                usedExportNames.Add(entryPoint);

                void CallManager(FunctionDef f, List<string> pNames)
                {
                    sb.Append("        ");
                    if (f.ReturnType != "void") sb.Append("return ");
                    sb.Append($"SteamEmulator.Manager.{f.FunctionName}(");
                    sb.Append(string.Join(", ", pNames));
                    sb.AppendLine(");");
                }
            }

            // 3b. SteamInternal_CreateInterface (The Factory)
            // Check if exported
            var createOrdinal = exports.FirstOrDefault(e => e.Name == "SteamInternal_CreateInterface")?.Ordinal ?? -1;
            if (createOrdinal != -1 && !usedExportNames.Contains("SteamInternal_CreateInterface"))
            {
                sb.AppendLine("    [UnmanagedCallersOnly(EntryPoint = \"SteamInternal_CreateInterface\")]");
                sb.AppendLine("    public static IntPtr SteamInternal_CreateInterface(IntPtr pVersion)");
                sb.AppendLine("    {");
                sb.AppendLine("        var version = Marshal.PtrToStringAnsi(pVersion);");
                sb.AppendLine("        if (version == null) return IntPtr.Zero;");
                sb.AppendLine("        return SteamEmulator.Manager.CreateInterface(version);");
                sb.AppendLine("    }");
                sb.AppendLine();

                activeShims.Add(("SteamInternal_CreateInterface", createOrdinal));
                usedExportNames.Add("SteamInternal_CreateInterface");
            }

            // 3c. g_pSteamClientGameServer (Data Export)
            var gpOrdinal = exports.FirstOrDefault(e => e.Name == "g_pSteamClientGameServer")?.Ordinal ?? -1;
            if (gpOrdinal != -1 && !usedExportNames.Contains("g_pSteamClientGameServer"))
            {
                sb.AppendLine("    [UnmanagedCallersOnly(EntryPoint = \"g_pSteamClientGameServer\")]");
                sb.AppendLine("    public static IntPtr g_pSteamClientGameServer()");
                sb.AppendLine("    {");
                sb.AppendLine("        return SteamEmulator.Manager.GetGameServerGlobal();");
                sb.AppendLine("    }");
                sb.AppendLine();
                activeShims.Add(("g_pSteamClientGameServer", gpOrdinal));
                usedExportNames.Add("g_pSteamClientGameServer");
            }

            // 4. Automatic Stub Generation for missing exports
            sb.AppendLine("    // Generic Stubs for missing exports");
            foreach (var export in exports)
            {
                if (usedExportNames.Contains(export.Name)) continue;

                sb.AppendLine($"    [UnmanagedCallersOnly(EntryPoint = \"{export.Name}\")]");
                sb.AppendLine($"    public static IntPtr Stub_{export.Name}()");
                sb.AppendLine("    {");
                sb.AppendLine($"        // Stub for {export.Name} @{export.Ordinal}");
                sb.AppendLine("        return IntPtr.Zero;");
                sb.AppendLine("    }");
                sb.AppendLine();

                activeShims.Add((export.Name, export.Ordinal));
                usedExportNames.Add(export.Name);
            }

            // 5. SteamEmulator_Shutdown (Moved to end to clear caches)
            // Ordinal = MaxOrdinal + 1
            var shutdownOrdinal = exports.Count > 0 ? exports.Max(e => e.Ordinal) + 1 : 1;

            sb.AppendLine("    [UnmanagedCallersOnly(EntryPoint = \"SteamEmulator_Shutdown\")]");
            sb.AppendLine("    public static void SteamEmulator_Shutdown()");
            sb.AppendLine("    {");
            sb.AppendLine("        foreach (var kvp in _activeShims)");
            sb.AppendLine("        {");
            sb.AppendLine("             // kvp.Key is ptr, kvp.Value is Dispose action");
            sb.AppendLine("             kvp.Value(kvp.Key);");
            sb.AppendLine("        }");
            sb.AppendLine("        _activeShims.Clear();");

            // Clear cache fields
            foreach (var field in cacheFields) sb.AppendLine($"        {field} = IntPtr.Zero;");

            sb.AppendLine("    }");
            sb.AppendLine();

            activeShims.Add(("SteamEmulator_Shutdown", shutdownOrdinal));

            sb.AppendLine("}");

            return (sb.ToString(), activeShims);
        }

        public static string GenerateAllExtensions(List<InterfaceDef> interfaces)
        {
            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine("#nullable enable");
            sb.AppendLine("using System;");
            sb.AppendLine("using System.Runtime.InteropServices;");
            sb.AppendLine("using System.Runtime.CompilerServices;");
            sb.AppendLine("namespace SteamEmulator;");
            sb.AppendLine();

            foreach (var iface in interfaces)
            {
                sb.AppendLine($"public static unsafe class {iface.ClassName}Extensions");
                sb.AppendLine("{");
                sb.Append(GenerateExtensions(iface));
                sb.AppendLine("}");
                sb.AppendLine();
            }

            return sb.ToString();
        }

        public static string GenerateManagerStubRegistration(List<InterfaceDef> interfaces, List<FunctionDef> functions)
        {
            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine("#nullable enable");
            sb.AppendLine("using System;");
            sb.AppendLine("namespace SteamEmulator;");
            sb.AppendLine();
            sb.AppendLine("public static partial class Manager");
            sb.AppendLine("{");
            sb.AppendLine("    static partial void RegisterGeneratedStubs()");
            sb.AppendLine("    {");

            foreach (var iface in interfaces)
            {
                var logic = iface.ClassName + "Logic";
                var stub = iface.ClassName + "Stub";
                sb.AppendLine($"        Register<{logic}>(new {stub}());");
            }

            sb.AppendLine("    }");

            // Generate CreateInterface Switch
            // Map Interface Name (e.g. SteamUser) to Entry Point (e.g. SteamUser_Entry)
            var interfaceToEntryMap = new Dictionary<string, string>();
            foreach (var iface in interfaces)
            {
                // Heuristic matches GenerateExports logic
                var accessorName = iface.Accessors.FirstOrDefault()?.Name ?? iface.ClassName[1..];
                interfaceToEntryMap[iface.ClassName] = $"{accessorName}_Entry";
                interfaceToEntryMap[accessorName] = $"{accessorName}_Entry";
            }

            sb.AppendLine();
            sb.AppendLine("    public static IntPtr CreateInterface(string version)");
            sb.AppendLine("    {");
            sb.AppendLine("        return version switch");
            sb.AppendLine("        {");

            foreach (var func in functions)
            {
                var name = func.FunctionName;
                if (name.StartsWith("SteamAPI_ISteam") && name.Contains("_v"))
                {
                    // Pattern: SteamAPI_ISteamUser_v023 -> SteamUser023
                    var parts = name.Split("_v");
                    if (parts.Length == 2)
                    {
                        var prefix = parts[0].Replace("SteamAPI_I", "");
                        var ver = parts[1];
                        var key = prefix + ver;

                        if (interfaceToEntryMap.TryGetValue(prefix, out var entry))
                            sb.AppendLine($"            \"{key}\" => SteamExports.{entry}(),");
                    }
                }
            }

            sb.AppendLine("            _ => IntPtr.Zero");
            sb.AppendLine("        };");
            sb.AppendLine("    }");

            sb.AppendLine("}");
            return sb.ToString();
        }

        public static string GenerateExtensions(InterfaceDef iface)
        {
            var sb = new StringBuilder();
            var index = 0;
            foreach (var method in iface.Methods)
            {
                sb.Append(
                    $"    public static {TypeDb.MapType(method.ReturnType)} {method.LogicName}(this IntPtr pThis");
                foreach (var p in method.Params)
                    sb.Append($", {TypeDb.MapType(p.ParamType)} {CleanParamName(p.ParamName)}");
                sb.AppendLine(")");
                sb.AppendLine("    {");
                sb.AppendLine("        var vtable = *(IntPtr*)(void*)pThis;");
                sb.AppendLine($"        var methodPtr = *(IntPtr*)((byte*)vtable + {index} * IntPtr.Size);");
                sb.AppendLine(
                    $"        var func = (delegate* unmanaged[Cdecl]<{GetSigTypes(method, true)}>)methodPtr;");

                sb.Append(method.ReturnType == "void" ? "        func(pThis" : "        return func(pThis");

                foreach (var p in method.Params) sb.Append($", {CleanParamName(p.ParamName)}");
                sb.AppendLine(");");
                sb.AppendLine("    }");
                index++;
            }

            return sb.ToString();
        }

        public static void ResolveLogicNames(InterfaceDef iface)
        {
            var buckets = iface.Methods.GroupBy(m => m.MethodName).ToList();

            foreach (var group in buckets)
                if (group.Count() == 1)
                {
                    group.First().LogicName = group.Key;
                }
                else
                {
                    // Duplicates found.
                    // Strategy: Use suffix from Flat Name if available.
                    // If Flat Names are identical (unlikely) or missing, use index.
                    var index = 1;
                    foreach (var method in group)
                    {
                        var baseName = group.Key;
                        var suffix = "";

                        if (!string.IsNullOrEmpty(method.MethodNameFlat))
                        {
                            // E.g. SteamAPI_ISteamUserStats_GetStatInt32
                            // We look for baseName ("GetStat") in flat name logic.
                            // Sometimes casing differs? "GetStat" vs "GetStatInt32"
                            // Try to find the methodName in the flat name.
                            var idx = method.MethodNameFlat.LastIndexOf(baseName,
                                StringComparison.InvariantCultureIgnoreCase);
                            if (idx >= 0)
                            {
                                var rawSuffix = method.MethodNameFlat[(idx + baseName.Length)..];
                                // rawSuffix might be "Int32"
                                if (!string.IsNullOrEmpty(rawSuffix)) suffix = "_" + rawSuffix;
                            }
                        }

                        if (string.IsNullOrEmpty(suffix))
                        {
                            // Fallback to index if no suffix derived (or if suffix collision? unlikely)
                            if (index > 1) suffix = $"_{index}";
                            index++;
                        }

                        method.LogicName = baseName + suffix;
                    }
                }
        }

        private static string GetSigTypes(MethodDef method, bool includeRet)
        {
            var sb = new StringBuilder();
            sb.Append("IntPtr"); // pThis
            foreach (var p in method.Params) sb.Append($", {TypeDb.MapType(p.ParamType)}");
            if (includeRet) sb.Append($", {TypeDb.MapType(method.ReturnType)}");
            return sb.ToString();
        }

        private static string CleanParamName(string name)
        {
            if (name == "params") return "@params";
            if (name == "string") return "@string";
            if (name == "class") return "@class";
            if (name == "ptr") return "@ptr";
            if (name == "event") return "@event";
            return name;
        }
    }

// ----------------------------------------------------------------------------
// Type Database
// ----------------------------------------------------------------------------

    public static class TypeDb
    {
        private static readonly HashSet<string> Structs = [];
        private static readonly Dictionary<string, string> Typedefs = [];
        private static readonly Dictionary<string, string> Enums = [];

        public static void Init(SteamApiDefinition api)
        {
            foreach (var s in api.Structs)
                Structs.Add(s.StructName);

            foreach (var t in api.Typedefs)
                Typedefs[t.Typedef] = t.Type;

            foreach (var e in api.Enums)
                Enums[e.EnumName] = "int"; // Most enums are int
        }

        public static string MapType(string type)
        {
            // 1. Clean type (strip const, handle refs)
            type = type.Replace("const ", "").Trim();

            if (type.EndsWith('&')) return "IntPtr";

            // 2. Handle immediate pointers (*)
            if (type.EndsWith('*') || type.Contains("**")) return "IntPtr";

            // 2b. Basic conversions
            if (type == "int" || type == "signed int" || type == "int32") return "int";
            if (type == "unsigned int" || type == "uint" || type == "uint32") return "uint";
            if (type == "long long" || type == "int64") return "long";
            if (type == "unsigned long long" || type == "uint64") return "ulong";
            if (type == "bool") return "byte";
            if (type == "void") return "void";
            if (type == "float" || type == "float32") return "float";
            if (type == "double" || type == "float64") return "double";
            if (type == "char") return "byte";

            // 3. Resolve Typedef chains using the _typedefs dictionary
            var depth = 0;
            var resolved = type;
            while (Typedefs.TryGetValue(resolved, out var nextType))
            {
                if (depth++ > 10) break; // Depth limit

                nextType = nextType.Replace("const ", "").Trim();

                // 4. Map fixed-size arrays in typedefs to IntPtr
                if (nextType.Contains('[') && nextType.Contains(']')) return "IntPtr";

                // Checks for pointers in typedef
                if (nextType.EndsWith('*') || nextType.Contains("**") || nextType.Contains("(*")) return "IntPtr";

                resolved = nextType;
            }

            if (resolved != type)
            {
                var mapping = MapType(resolved);
                if (mapping != "int") return mapping;
            }

            // 5. Apply Steam-specific primitive mappings (ulong, uint, byte)
            if (type == "SteamAPICall_t") return "ulong";
            if (type == "CSteamID") return "ulong";
            if (type == "CGameID") return "ulong";
            if (type == "AppId_t") return "uint";

            if (Structs.Contains(type)) return "IntPtr";
            if (Enums.ContainsKey(type)) return "int";

            // Handles
            if (type.StartsWith('H') && type.Length > 1 && char.IsUpper(type[1])) return "uint";
            if (type.StartsWith('E') && type.Length > 1 && char.IsUpper(type[1])) return "int";

            // 6. Fallback to int for Enums or unknown types
            return "int";
        }
    }

// ----------------------------------------------------------------------------
// JSON Models
// ----------------------------------------------------------------------------

    public class SteamApiDefinition
    {
        public List<InterfaceDef> Interfaces { get; set; } = [];
        public List<FunctionDef> Functions { get; set; } = [];
        public List<StructDef> Structs { get; set; } = [];
        public List<TypedefDef> Typedefs { get; set; } = [];
        public List<EnumDef> Enums { get; set; } = [];
    }

    public class InterfaceDef
    {
        [JsonPropertyName("classname")] public string ClassName { get; set; } = "";

        public List<MethodDef> Methods { get; set; } = [];
        public List<AccessorDef> Accessors { get; set; } = [];
    }

    public class MethodDef
    {
        [JsonPropertyName("methodname")] public string MethodName { get; set; } = "";

        [JsonPropertyName("methodname_flat")] public string MethodNameFlat { get; set; } = "";

        [JsonPropertyName("returntype")] public string ReturnType { get; set; } = "";

        public List<ParamDef> Params { get; set; } = [];

        // Transient - not in JSON
        public string LogicName { get; set; } = "";
    }

    public class ParamDef
    {
        [JsonPropertyName("paramname")] public string ParamName { get; set; } = "";

        [JsonPropertyName("paramtype")] public string ParamType { get; set; } = "";
    }

    public class AccessorDef
    {
        [JsonPropertyName("name")] public string Name { get; set; } = "";
    }

    public class StructDef
    {
        [JsonPropertyName("struct")] public string StructName { get; set; } = "";
    }

    public class TypedefDef
    {
        [JsonPropertyName("typedef")] public string Typedef { get; set; } = "";

        [JsonPropertyName("type")] public string Type { get; set; } = "";
    }

    public class EnumDef
    {
        [JsonPropertyName("enumname")] public string EnumName { get; set; } = "";
    }

    public class FunctionDef
    {
        [JsonPropertyName("functionname")] public string FunctionName { get; set; } = "";

        [JsonPropertyName("functionname_flat")]
        public string FunctionNameFlat { get; set; } = "";

        [JsonPropertyName("returntype")] public string ReturnType { get; set; } = "";
        [JsonPropertyName("params")] public List<ParamDef> Params { get; set; } = [];
    }

// ----------------------------------------------------------------------------
// PE Export Reader (Preserved)
// ----------------------------------------------------------------------------

    public class ExportInfo
    {
        public string Name { get; set; } = "";
        public int Ordinal { get; set; }
    }

    public static class PeReader
    {
        public static List<ExportInfo> GetExports(string path)
        {
            var exports = new List<ExportInfo>();
            using var fs = File.OpenRead(path);
            using var reader = new BinaryReader(fs);

            fs.Seek(0x3C, SeekOrigin.Begin);
            var eLfanew = reader.ReadInt32();

            fs.Seek(eLfanew, SeekOrigin.Begin);
            _ = reader.ReadUInt32(); // signature
            _ = reader.ReadUInt16(); // machine
            var numberOfSections = reader.ReadUInt16();
            fs.Seek(12, SeekOrigin.Current);
            var sizeOfOptionalHeader = reader.ReadUInt16();
            fs.Seek(2, SeekOrigin.Current);

            var magic = reader.ReadUInt16();

            var numRvaOffset = magic == 0x20B ? 108 : 92;
            fs.Seek(eLfanew + 4 + 20 + numRvaOffset, SeekOrigin.Begin);
            var numberOfRvaAndSizes = reader.ReadUInt32();

            if (numberOfRvaAndSizes == 0) return exports;

            var exportRva = reader.ReadUInt32();
            _ = reader.ReadUInt32(); // exportSize

            if (exportRva == 0) return exports;

            long sectionsStart = eLfanew + 4 + 20 + sizeOfOptionalHeader;
            var exportFileOffset = RvaToFileOffset(exportRva, sectionsStart, numberOfSections, reader);

            if (exportFileOffset == 0) return exports;

            fs.Seek(exportFileOffset, SeekOrigin.Begin);
            _ = reader.ReadUInt32(); // characteristics
            _ = reader.ReadUInt32(); // timeDateStamp
            _ = reader.ReadUInt16(); // majorVersion
            _ = reader.ReadUInt16(); // minorVersion
            _ = reader.ReadUInt32(); // nameRva
            var ordinalBase = reader.ReadUInt32();
            _ = reader.ReadUInt32(); // numberOfFunctions
            var numberOfNames = reader.ReadUInt32();
            _ = reader.ReadUInt32(); // addressOfFunctionsRva
            var addressOfNamesRva = reader.ReadUInt32();
            var addressOfNameOrdinalsRva = reader.ReadUInt32();

            var namesStart = RvaToFileOffset(addressOfNamesRva, sectionsStart, numberOfSections, reader);
            var ordinalsStart = RvaToFileOffset(addressOfNameOrdinalsRva, sectionsStart, numberOfSections, reader);

            for (var i = 0; i < numberOfNames; i++)
            {
                fs.Seek(namesStart + i * 4, SeekOrigin.Begin);
                var namePtrRva = reader.ReadUInt32();

                fs.Seek(ordinalsStart + i * 2, SeekOrigin.Begin);
                var ordinalIndex = reader.ReadUInt16();

                var nameOffset = RvaToFileOffset(namePtrRva, sectionsStart, numberOfSections, reader);

                fs.Seek(nameOffset, SeekOrigin.Begin);
                var name = ReadNullTerminatedString(reader);

                exports.Add(new ExportInfo { Name = name, Ordinal = (int)(ordinalBase + ordinalIndex) });
            }

            return exports;
        }

        private static long RvaToFileOffset(uint rva, long sectionsStart, int numberOfSections, BinaryReader reader)
        {
            for (var i = 0; i < numberOfSections; i++)
            {
                reader.BaseStream.Seek(sectionsStart + i * 40, SeekOrigin.Begin);
                _ = reader.ReadBytes(8); // nameChars
                var virtualSize = reader.ReadUInt32();
                var virtualAddress = reader.ReadUInt32();
                var sizeOfRawData = reader.ReadUInt32();
                var pointerToRawData = reader.ReadUInt32();

                if (rva >= virtualAddress && rva < virtualAddress + Math.Max(virtualSize, sizeOfRawData))
                    if (rva < virtualAddress + sizeOfRawData)
                        return pointerToRawData + (rva - virtualAddress);
            }

            return 0;
        }

        private static string ReadNullTerminatedString(BinaryReader reader)
        {
            var bytes = new List<byte>();
            while (true)
            {
                var b = reader.ReadByte();
                if (b == 0) break;
                bytes.Add(b);
            }

            return Encoding.ASCII.GetString([.. bytes]);
        }
    }
}