using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;

// Paths
var workspaceRoot = Path.GetFullPath(Path.Combine(AppContext.BaseDirectory, "../../../.."));
var jsonPath = Path.Combine(workspaceRoot, "steamworks_sdk_163", "sdk", "public", "steam", "steam_api.json");
var referenceDllPath = Path.Combine(workspaceRoot, "steamworks_sdk_163", "sdk", "redistributable_bin", "win64",
    "steam_api64.dll");
var outputDir = Path.Combine(workspaceRoot, "steam_api", "Generated");


// Debug: check keys
var jsonContent = File.ReadAllText(jsonPath);
using var doc = JsonDocument.Parse(jsonContent);
foreach (var prop in doc.RootElement.EnumerateObject()) Console.WriteLine($"JSON Root Key: {prop.Name}");

Console.WriteLine($"Loading JSON from {jsonPath}");

JsonSerializerOptions options = new()
{
    PropertyNameCaseInsensitive = true,
    ReadCommentHandling = JsonCommentHandling.Skip
};

var api = JsonSerializer.Deserialize<SteamApiDefinition>(File.ReadAllText(jsonPath), options) ??
          throw new InvalidOperationException("Failed to parse steam_api.json");

// Initialize TypeDB
TypeDb.Init(api);

Console.WriteLine($"Reading exports from {referenceDllPath}");
var exports = PeReader.GetExports(referenceDllPath);
Console.WriteLine($"Found {exports.Count} exports.");

// Debug: write exports to file
// File.WriteAllLines("found_exports.txt", exports.Select(e => $"{e.Name} @{e.Ordinal}"));

Directory.CreateDirectory(outputDir);

// Generate ArchConfig
File.WriteAllText(Path.Combine(outputDir, "ArchConfig.cs"), Generator.GenerateArchConfig());

// Generate Interfaces & VTables
var interfaceSb = new StringBuilder();
var shimSb = new StringBuilder();
var logicSb = new StringBuilder();

interfaceSb.AppendLine("// <auto-generated/>");
interfaceSb.AppendLine("using System;");
interfaceSb.AppendLine("using System.Runtime.InteropServices;");
interfaceSb.AppendLine("namespace SteamEmulator;");
interfaceSb.AppendLine();

shimSb.AppendLine("// <auto-generated/>");
shimSb.AppendLine("using System;");
shimSb.AppendLine("using System.Runtime.InteropServices;");
shimSb.AppendLine("using System.Runtime.CompilerServices;");
shimSb.AppendLine("namespace SteamEmulator;");
shimSb.AppendLine();

logicSb.AppendLine("// <auto-generated/>");
logicSb.AppendLine("using System;");
logicSb.AppendLine("namespace SteamEmulator;");
logicSb.AppendLine();

// Generate Interfaces
foreach (var iface in api.Interfaces)
{
    // Pre-pass: Resolve Logical Names
    Generator.ResolveLogicNames(iface);

    var vtableCode = Generator.GenerateVTable(iface);
    interfaceSb.AppendLine(vtableCode);

    var logicCode = Generator.GenerateLogicInterface(iface);
    logicSb.AppendLine(logicCode);

    var shimCode = Generator.GenerateShim(iface);
    shimSb.AppendLine(shimCode);

    // We generate extensions for ALL interfaces to ensure full coverage
    // even if multiple versions exist.
}

File.WriteAllText(Path.Combine(outputDir, "SteamInterfaces.cs"), interfaceSb.ToString());
File.WriteAllText(Path.Combine(outputDir, "SteamShims.cs"), shimSb.ToString());
File.WriteAllText(Path.Combine(outputDir, "SteamLogic.cs"), logicSb.ToString());
File.WriteAllText(Path.Combine(outputDir, "SteamExtensions.cs"), Generator.GenerateAllExtensions(api.Interfaces));

// Generate Global Accessors (SteamExports)
var (exportsCode, activeShims) = Generator.GenerateExports(api.Interfaces, exports);
File.WriteAllText(Path.Combine(outputDir, "SteamExports.g.cs"), exportsCode);

// Generate DEF file
var defSb = new StringBuilder();
defSb.AppendLine("LIBRARY steam_api64");
defSb.AppendLine("EXPORTS");

// Track handled ordinals to avoid duplicates or conflicts
var handledOrdinals = new HashSet<int>();

foreach (var shimExport in activeShims)
    // shimExport is (Name, Ordinal)
    if (shimExport.Ordinal > 0)
    {
        defSb.AppendLine($"    {shimExport.Name} @{shimExport.Ordinal}");
        handledOrdinals.Add(shimExport.Ordinal);
    }

// If we didn't find an ordinal, we can't put it in def with specific ordinal.
// But we should warn.
// Add remaining exports from DLL that we might have missed or are internal
foreach (var export in exports.OrderBy(e => e.Ordinal))
    if (!handledOrdinals.Contains(export.Ordinal))
    {
        // Check if we have an entry point that matches this name?
        // If not, we just pass it through or comment it out?
        // The requirement is specific: "Linker Parity".
        // If we don't implement it, we can't really export it from our DLL unless we have a dummy.
        // For now, let's only export what we have implementations for, 
        // OR export dummies for everything else to match the surface area exactly?
        // "Produce the C# shims and Linker Definition files required for a drop-in replacement"
        // Drop-in replacement implies matching exports.
        // But if we don't have code, it will fail at runtime link (or build time if NativeAOT complains).
        // NativeAOT only exports what has [UnmanagedCallersOnly].
        // Therefore, we can ONLY put in .def what we have in C#.
        // The generator step 1 generates accessors.
        // Shutdown logic is manually added.
        // Let's assume the user logic handles the rest or we skip them.
        // However, "SteamEmulator_Shutdown" needs to be added.
    }

// Add SteamEmulator_Shutdown if present in exports? No, it's our custom export.
// But wait, "Step 2: Integration: Add a SteamEmulator_Shutdown() global export".
// Is this export supposed to remain in the DLL for the EMULATOR management, not necessarily part of Steam API?
// Yes.
defSb.AppendLine("    SteamEmulator_Shutdown");

File.WriteAllText(Path.Combine(outputDir, "steam_api64.def"), defSb.ToString());

Console.WriteLine("Done.");

// ----------------------------------------------------------------------------
// Generator Logic
// ----------------------------------------------------------------------------

public static class Generator
{
    public static string GenerateArchConfig()
    {
        return """
               namespace SteamEmulator;

               public static class ArchConfig
               {
               #if TARGET_64BIT
                   public const int PACK = 8;
               #else
                   public const int PACK = 4;
               #endif
               }
               """;
    }

    public static string GenerateVTable(InterfaceDef iface)
    {
        var sb = new StringBuilder();
        sb.AppendLine("[StructLayout(LayoutKind.Sequential, Pack = ArchConfig.PACK)]");
        sb.AppendLine($"public unsafe struct {iface.ClassName}VTable");
        sb.AppendLine("{");

        foreach (var method in iface.Methods) sb.AppendLine($"    public IntPtr {method.LogicName};");
        sb.AppendLine("}");
        return sb.ToString();
    }

    public static string GenerateLogicInterface(InterfaceDef iface)
    {
        var sb = new StringBuilder();
        var logicName = iface.ClassName + "Logic";

        sb.AppendLine($"public interface {logicName}");
        sb.AppendLine("{");
        foreach (var method in iface.Methods)
        {
            sb.Append($"    {TypeDb.MapType(method.ReturnType)} {method.LogicName}({Generics(method.Params)})");
            sb.AppendLine(";");
        }

        sb.AppendLine("}");
        return sb.ToString();

        string Generics(List<ParamDef> parameters)
        {
            var parts = new List<string>();
            foreach (var p in parameters) parts.Add($"{TypeDb.MapType(p.ParamType)} {CleanParamName(p.ParamName)}");
            return string.Join(", ", parts);
        }
    }

    public static string GenerateShim(InterfaceDef iface)
    {
        var sb = new StringBuilder();
        var shimClassName = iface.ClassName + "Shim";
        var logicInterface = iface.ClassName + "Logic";

        sb.AppendLine($"public unsafe class {shimClassName}");
        sb.AppendLine("{");
        sb.AppendLine($"    public static {iface.ClassName}VTable VTable;");
        sb.AppendLine("    public static IntPtr VTablePtr;");

        sb.AppendLine();
        sb.AppendLine($"    static {shimClassName}()");
        sb.AppendLine("    {");
        sb.AppendLine("        VTablePtr = (IntPtr)Unsafe.AsPointer(ref VTable);");
        // Initialize VTable pointers
        foreach (var method in iface.Methods)
        {
            var stubName = $"{iface.ClassName}_{method.LogicName}";
            sb.AppendLine(
                $"        VTable.{method.LogicName} = (IntPtr)(delegate* unmanaged[Cdecl]<{GetSigTypes(method, true)}>)&{stubName};");
        }

        sb.AppendLine("    }");

        // Factory Method
        sb.AppendLine();
        sb.AppendLine($"    public static IntPtr Create({logicInterface} logic)");
        sb.AppendLine("    {");
        sb.AppendLine("        var handle = GCHandle.Alloc(logic);");
        sb.AppendLine("        var ptr = Marshal.AllocHGlobal(IntPtr.Size * 2);");
        sb.AppendLine("        *(IntPtr*)ptr = VTablePtr;");
        sb.AppendLine("        *(IntPtr*)((byte*)ptr + IntPtr.Size) = GCHandle.ToIntPtr(handle);");
        sb.AppendLine("        // Track for cleanup");
        sb.AppendLine("        SteamExports.RegisterShim(ptr);");
        sb.AppendLine("        return ptr;");
        sb.AppendLine("    }");

        // Dispose Method
        sb.AppendLine();
        sb.AppendLine("    public static void Dispose(IntPtr pThis)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (pThis == IntPtr.Zero) return;");
        sb.AppendLine("        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);");
        sb.AppendLine("        if (handlePtr != IntPtr.Zero)");
        sb.AppendLine("        {");
        sb.AppendLine("             var handle = GCHandle.FromIntPtr(handlePtr);");
        sb.AppendLine("             if (handle.IsAllocated) handle.Free();");
        sb.AppendLine("        }");
        sb.AppendLine("        Marshal.FreeHGlobal(pThis);");
        sb.AppendLine("    }");

        foreach (var method in iface.Methods)
        {
            var stubName = $"{iface.ClassName}_{method.LogicName}";
            sb.AppendLine();
            sb.AppendLine("    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]");
            sb.Append($"    public static {TypeDb.MapType(method.ReturnType)} {stubName}(IntPtr pThis");

            foreach (var p in method.Params)
                sb.Append($", {TypeDb.MapType(p.ParamType)} {CleanParamName(p.ParamName)}");
            sb.AppendLine(")");
            sb.AppendLine("    {");
            sb.AppendLine("        var __thisPtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);");
            sb.AppendLine("        var __thisHandle = GCHandle.FromIntPtr(__thisPtr);");
            sb.AppendLine($"        var __logic = ({logicInterface})__thisHandle.Target!;");

            if (method.ReturnType != "void")
                sb.Append($"        return __logic.{method.LogicName}(");
            else
                sb.Append($"        __logic.{method.LogicName}(");

            for (var i = 0; i < method.Params.Count; i++)
            {
                sb.Append($"{CleanParamName(method.Params[i].ParamName)}");
                if (i < method.Params.Count - 1) sb.Append(", ");
            }

            sb.AppendLine(");");
            sb.AppendLine("    }");
        }

        sb.AppendLine("}");
        return sb.ToString();
    }

    public static (string Code, List<(string Name, int Ordinal)> ActiveShims) GenerateExports(
        List<InterfaceDef> interfaces, List<ExportInfo> exports)
    {
        var sb = new StringBuilder();
        var activeShims = new List<(string, int)>();
        var usedExportNames = new HashSet<string>();

        // Console.WriteLine($"Generating exports for {interfaces.Count} interfaces...");

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Runtime.InteropServices;");
        sb.AppendLine("using System.Collections.Concurrent;");
        sb.AppendLine("namespace SteamEmulator;");
        sb.AppendLine();
        sb.AppendLine("public static class SteamExports");
        sb.AppendLine("{");

        // Tracking logic for cleanup
        sb.AppendLine("    private static readonly ConcurrentBag<IntPtr> _activeShims = new();");
        sb.AppendLine("    public static void RegisterShim(IntPtr shim) => _activeShims.Add(shim);");
        sb.AppendLine();
        sb.AppendLine("    [UnmanagedCallersOnly(EntryPoint = \"SteamEmulator_Shutdown\")]");
        sb.AppendLine("    public static void SteamEmulator_Shutdown()");
        sb.AppendLine("    {");
        sb.AppendLine("        foreach (var shim in _activeShims)");
        sb.AppendLine("        {");
        sb.AppendLine("             if (shim == IntPtr.Zero) continue;");
        sb.AppendLine("             unsafe {");
        sb.AppendLine("                 var handlePtr = *(IntPtr*)((byte*)shim + IntPtr.Size);");
        sb.AppendLine("                 if (handlePtr != IntPtr.Zero) {");
        sb.AppendLine("                     var handle = GCHandle.FromIntPtr(handlePtr);");
        sb.AppendLine("                     if (handle.IsAllocated) handle.Free();");
        sb.AppendLine("                 }");
        sb.AppendLine("                 Marshal.FreeHGlobal(shim);");
        sb.AppendLine("             }");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine();

        // 1. Flat API Exports (from Methods)
        foreach (var iface in interfaces)
        {
            var shimClassName = iface.ClassName + "Shim";
            var logicInterface = iface.ClassName + "Logic";

            foreach (var method in iface.Methods)
            {
                var flatName = method.MethodNameFlat;
                if (string.IsNullOrEmpty(flatName)) continue;

                // Check if this flat name is in DLL exports
                var ordinal = exports.FirstOrDefault(e => e.Name == flatName)?.Ordinal ?? -1;
                if (ordinal == -1) continue; // Not exported in this DLL version

                sb.AppendLine($"    [UnmanagedCallersOnly(EntryPoint = \"{flatName}\")]");
                sb.Append($"    public static {TypeDb.MapType(method.ReturnType)} {flatName}(IntPtr pThis");
                foreach (var p in method.Params)
                    sb.Append($", {TypeDb.MapType(p.ParamType)} {CleanParamName(p.ParamName)}");
                sb.AppendLine(")");
                sb.AppendLine("    {");
                // Implementation: Resolve pThis to Logic and call
                // Note: pThis here is the interface pointer (VTable pointer)
                sb.AppendLine("        unsafe {");
                sb.AppendLine("            var __thisPtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);");
                sb.AppendLine("            var __thisHandle = GCHandle.FromIntPtr(__thisPtr);");
                sb.AppendLine($"            var __logic = ({logicInterface})__thisHandle.Target!;");

                if (method.ReturnType != "void")
                    sb.Append($"            return __logic.{method.LogicName}(");
                else
                    sb.Append($"            __logic.{method.LogicName}(");

                for (var i = 0; i < method.Params.Count; i++)
                {
                    sb.Append($"{CleanParamName(method.Params[i].ParamName)}");
                    if (i < method.Params.Count - 1) sb.Append(", ");
                }

                sb.AppendLine(");");
                sb.AppendLine("        }");
                sb.AppendLine("    }");
                sb.AppendLine();

                activeShims.Add((flatName, ordinal));
                usedExportNames.Add(flatName);
            }
        }

        // 2. Accessors (if they match exports)
        foreach (var iface in interfaces)
        {
            if (iface.Accessors == null) continue;
            foreach (var acc in iface.Accessors)
            {
                var exportName = acc.Name;
                if (usedExportNames.Contains(exportName)) continue;

                var ordinal = exports.FirstOrDefault(e => e.Name == exportName)?.Ordinal ?? -1;

                // Console.WriteLine($"Processing accessor {exportName} for {iface.ClassName}. Ordinal found: {ordinal}");

                sb.AppendLine($"    [UnmanagedCallersOnly(EntryPoint = \"{exportName}\")]");
                sb.AppendLine($"    public static IntPtr {exportName}_Entry()");
                sb.AppendLine("    {");
                sb.AppendLine($"        // Accessor for {iface.ClassName}");
                sb.AppendLine("        // Requires global context resolution.");
                sb.AppendLine("        return IntPtr.Zero; // TODO: Connect to Global Context");
                sb.AppendLine("    }");
                sb.AppendLine();

                if (ordinal != -1)
                {
                    activeShims.Add((exportName, ordinal));
                    usedExportNames.Add(exportName);
                }
            }
        }

        sb.AppendLine("}");

        return (sb.ToString(), activeShims);
    }

    public static string GenerateAllExtensions(List<InterfaceDef> interfaces)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Runtime.InteropServices;");
        sb.AppendLine("using System.Runtime.CompilerServices;");
        sb.AppendLine("namespace SteamEmulator;");
        sb.AppendLine();

        foreach (var iface in interfaces)
        {
            sb.AppendLine($"public static unsafe class {iface.ClassName}Extensions");
            sb.AppendLine("{");
            sb.Append(GenerateExtensions(iface));
            sb.AppendLine("}");
            sb.AppendLine();
        }

        return sb.ToString();
    }

    public static string GenerateExtensions(InterfaceDef iface)
    {
        var sb = new StringBuilder();
        var index = 0;
        foreach (var method in iface.Methods)
        {
            sb.Append($"    public static {TypeDb.MapType(method.ReturnType)} {method.LogicName}(this IntPtr pThis");
            foreach (var p in method.Params)
                sb.Append($", {TypeDb.MapType(p.ParamType)} {CleanParamName(p.ParamName)}");
            sb.AppendLine(")");
            sb.AppendLine("    {");
            sb.AppendLine("        var vtable = *(IntPtr*)(void*)pThis;");
            sb.AppendLine($"        var methodPtr = *(IntPtr*)((byte*)vtable + {index} * IntPtr.Size);");
            sb.AppendLine($"        var func = (delegate* unmanaged[Cdecl]<{GetSigTypes(method, true)}>)methodPtr;");

            if (method.ReturnType == "void")
                sb.Append("        func(pThis");
            else
                sb.Append("        return func(pThis");

            foreach (var p in method.Params) sb.Append($", {CleanParamName(p.ParamName)}");
            sb.AppendLine(");");
            sb.AppendLine("    }");
            index++;
        }

        return sb.ToString();
    }

    public static void ResolveLogicNames(InterfaceDef iface)
    {
        var buckets = iface.Methods.GroupBy(m => m.MethodName).ToList();

        foreach (var group in buckets)
            if (group.Count() == 1)
            {
                group.First().LogicName = group.Key;
            }
            else
            {
                // Duplicates found.
                // Strategy: Use suffix from Flat Name if available.
                // If Flat Names are identical (unlikely) or missing, use index.
                var index = 1;
                foreach (var method in group)
                {
                    var baseName = group.Key;
                    var suffix = "";

                    if (!string.IsNullOrEmpty(method.MethodNameFlat))
                    {
                        // E.g. SteamAPI_ISteamUserStats_GetStatInt32
                        // We look for baseName ("GetStat") in flat name logic.
                        // Sometimes casing differs? "GetStat" vs "GetStatInt32"
                        // Try to find the methodName in the flat name.
                        var idx = method.MethodNameFlat.LastIndexOf(baseName,
                            StringComparison.InvariantCultureIgnoreCase);
                        if (idx >= 0)
                        {
                            var rawSuffix = method.MethodNameFlat.Substring(idx + baseName.Length);
                            // rawSuffix might be "Int32"
                            if (!string.IsNullOrEmpty(rawSuffix)) suffix = "_" + rawSuffix;
                        }
                    }

                    if (string.IsNullOrEmpty(suffix))
                    {
                        // Fallback to index if no suffix derived (or if suffix collision? unlikely)
                        if (index > 1) suffix = $"_{index}";
                        index++;
                    }

                    method.LogicName = baseName + suffix;
                }
            }
    }

    private static string GetSigTypes(MethodDef method, bool includeRet)
    {
        var sb = new StringBuilder();
        sb.Append("IntPtr"); // pThis
        foreach (var p in method.Params) sb.Append($", {TypeDb.MapType(p.ParamType)}");
        if (includeRet) sb.Append($", {TypeDb.MapType(method.ReturnType)}");
        return sb.ToString();
    }

    private static string CleanParamName(string name)
    {
        if (name == "params") return "@params";
        if (name == "string") return "@string";
        if (name == "class") return "@class";
        if (name == "ptr") return "@ptr";
        if (name == "event") return "@event";
        return name;
    }
}

// ----------------------------------------------------------------------------
// Type Database
// ----------------------------------------------------------------------------

public static class TypeDb
{
    private static readonly HashSet<string> _structs = [];
    private static readonly Dictionary<string, string> _typedefs = [];
    private static readonly Dictionary<string, string> _enums = [];

    public static void Init(SteamApiDefinition api)
    {
        foreach (var s in api.Structs)
            _structs.Add(s.StructName);

        foreach (var t in api.Typedefs)
            _typedefs[t.Typedef] = t.Type;

        foreach (var e in api.Enums)
            _enums[e.EnumName] = "int"; // Most enums are int
    }

    public static string MapType(string type)
    {
        type = type.Replace("const ", "").Trim();
        type = type.Replace(" &", "").Trim(); // Handle refs as pointers or values? C++ refs are pointers usually in ABI

        // 1. Basic conversions
        if (type.EndsWith('*')) return "IntPtr";
        if (type == "int") return "int";
        if (type == "unsigned int") return "uint";
        if (type == "long long") return "long";
        if (type == "unsigned long long") return "ulong";
        if (type == "bool") return "byte"; // Requirement
        if (type == "void") return "void";
        if (type == "float") return "float";
        if (type == "double") return "double";

        // 2. Resolve Typedefs
        // Loop to resolve chain typedefs (e.g. typedef A B; typedef B C;)
        // Limit depth to avoid infinite loops
        var depth = 0;
        var resolved = type;
        while (_typedefs.TryGetValue(resolved, out var nextType) && depth++ < 10)
        {
            resolved = nextType;
            // If resolved type is a fixed array e.g. "char [1024]", Map that
            if (resolved.Contains('[')) return "IntPtr";
            if (resolved.EndsWith('*')) return "IntPtr";
        }

        // Check if resolved is basic type 
        if (resolved != type)
        {
            var mapping = MapType(resolved);
            if (mapping != "int") return mapping; // If it resolved to something specific
        }

        // 3. Known API Types
        if (type == "SteamAPICall_t") return "ulong";
        if (type == "CSteamID") return "ulong";
        if (type == "CGameID") return "ulong";
        if (type == "AppId_t") return "uint";

        // 4. Structs & Enums
        // If it's in structs list, and passed by value?
        // JSON defines structs.
        // If we see "SomeStruct", and it is not a pointer (handled above), it is passed by value.
        // NativeAOT supports structs if defined. But we are defining them as Integers/IntPtrs mostly for Shims?
        // Wait, "Ensure SteamNetworkingMessage_t * is mapped to IntPtr". We did that via *.
        // "Ensure types like SteamNetworkingErrMsg (which is a fixed-size char [1024]) are handled as IntPtr".
        // Typedef checking handles that.

        if (_enums.ContainsKey(type)) return "int";

        // Handles
        if (type.StartsWith('H')) return "uint"; // HSomething usually uint handle
        if (type.StartsWith('E')) return "int"; // Eunm usually int

        // Default
        return "int";
    }
}

// ----------------------------------------------------------------------------
// JSON Models
// ----------------------------------------------------------------------------

public class SteamApiDefinition
{
    public List<InterfaceDef> Interfaces { get; set; } = [];
    public List<StructDef> Structs { get; set; } = [];
    public List<TypedefDef> Typedefs { get; set; } = [];
    public List<EnumDef> Enums { get; set; } = [];
}

public class InterfaceDef
{
    [JsonPropertyName("classname")] public string ClassName { get; set; } = "";

    public List<MethodDef> Methods { get; set; } = [];
    public List<AccessorDef> Accessors { get; set; } = [];
}

public class MethodDef
{
    [JsonPropertyName("methodname")] public string MethodName { get; set; } = "";

    [JsonPropertyName("methodname_flat")] public string MethodNameFlat { get; set; } = "";

    [JsonPropertyName("returntype")] public string ReturnType { get; set; } = "";

    public List<ParamDef> Params { get; set; } = new();

    // Transient - not in JSON
    public string LogicName { get; set; } = "";
}

public class ParamDef
{
    [JsonPropertyName("paramname")] public string ParamName { get; set; } = "";

    [JsonPropertyName("paramtype")] public string ParamType { get; set; } = "";
}

public class AccessorDef
{
    [JsonPropertyName("kind")] public string Kind { get; set; } = "";

    [JsonPropertyName("name")] public string Name { get; set; } = "";
}

public class StructDef
{
    [JsonPropertyName("struct")] public string StructName { get; set; } = "";
}

public class TypedefDef
{
    [JsonPropertyName("typedef")] public string Typedef { get; set; } = "";

    [JsonPropertyName("type")] public string Type { get; set; } = "";
}

public class EnumDef
{
    [JsonPropertyName("enumname")] public string EnumName { get; set; } = "";
}

// ----------------------------------------------------------------------------
// PE Export Reader (Preserved)
// ----------------------------------------------------------------------------

public class ExportInfo
{
    public string Name { get; set; } = "";
    public int Ordinal { get; set; }
}

public static class PeReader
{
    public static List<ExportInfo> GetExports(string path)
    {
        var exports = new List<ExportInfo>();
        using var fs = File.OpenRead(path);
        using var reader = new BinaryReader(fs);

        fs.Seek(0x3C, SeekOrigin.Begin);
        var e_lfanew = reader.ReadInt32();

        fs.Seek(e_lfanew, SeekOrigin.Begin);
        var signature = reader.ReadUInt32();
        var machine = reader.ReadUInt16();
        var numberOfSections = reader.ReadUInt16();
        fs.Seek(12, SeekOrigin.Current);
        var sizeOfOptionalHeader = reader.ReadUInt16();
        fs.Seek(2, SeekOrigin.Current);

        var magic = reader.ReadUInt16();

        var numRvaOffset = magic == 0x20B ? 108 : 92;
        fs.Seek(e_lfanew + 4 + 20 + numRvaOffset, SeekOrigin.Begin);
        var numberOfRvaAndSizes = reader.ReadUInt32();

        if (numberOfRvaAndSizes == 0) return exports;

        var exportRva = reader.ReadUInt32();
        var exportSize = reader.ReadUInt32();

        if (exportRva == 0) return exports;

        long sectionsStart = e_lfanew + 4 + 20 + sizeOfOptionalHeader;
        var exportFileOffset = RvaToFileOffset(exportRva, sectionsStart, numberOfSections, reader);

        if (exportFileOffset == 0) return exports;

        fs.Seek(exportFileOffset, SeekOrigin.Begin);
        var characteristics = reader.ReadUInt32();
        var timeDateStamp = reader.ReadUInt32();
        var majorVersion = reader.ReadUInt16();
        var minorVersion = reader.ReadUInt16();
        var nameRva = reader.ReadUInt32();
        var ordinalBase = reader.ReadUInt32();
        var numberOfFunctions = reader.ReadUInt32();
        var numberOfNames = reader.ReadUInt32();
        var addressOfFunctionsRva = reader.ReadUInt32();
        var addressOfNamesRva = reader.ReadUInt32();
        var addressOfNameOrdinalsRva = reader.ReadUInt32();

        var namesStart = RvaToFileOffset(addressOfNamesRva, sectionsStart, numberOfSections, reader);
        var ordinalsStart = RvaToFileOffset(addressOfNameOrdinalsRva, sectionsStart, numberOfSections, reader);

        for (var i = 0; i < numberOfNames; i++)
        {
            fs.Seek(namesStart + i * 4, SeekOrigin.Begin);
            var namePtrRva = reader.ReadUInt32();

            fs.Seek(ordinalsStart + i * 2, SeekOrigin.Begin);
            var ordinalIndex = reader.ReadUInt16();

            var nameOffset = RvaToFileOffset(namePtrRva, sectionsStart, numberOfSections, reader);

            fs.Seek(nameOffset, SeekOrigin.Begin);
            var name = ReadNullTerminatedString(reader);

            exports.Add(new ExportInfo { Name = name, Ordinal = (int)(ordinalBase + ordinalIndex) });
        }

        return exports;
    }

    private static long RvaToFileOffset(uint rva, long sectionsStart, int numberOfSections, BinaryReader reader)
    {
        for (var i = 0; i < numberOfSections; i++)
        {
            reader.BaseStream.Seek(sectionsStart + i * 40, SeekOrigin.Begin);
            var nameChars = reader.ReadBytes(8);
            var virtualSize = reader.ReadUInt32();
            var virtualAddress = reader.ReadUInt32();
            var sizeOfRawData = reader.ReadUInt32();
            var pointerToRawData = reader.ReadUInt32();

            if (rva >= virtualAddress && rva < virtualAddress + Math.Max(virtualSize, sizeOfRawData))
                if (rva < virtualAddress + sizeOfRawData)
                    return pointerToRawData + (rva - virtualAddress);
        }

        return 0;
    }

    private static string ReadNullTerminatedString(BinaryReader reader)
    {
        var bytes = new List<byte>();
        while (true)
        {
            var b = reader.ReadByte();
            if (b == 0) break;
            bytes.Add(b);
        }

        return Encoding.ASCII.GetString([.. bytes]);
    }
}