using System.Runtime.InteropServices;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Text;

// Paths
var workspaceRoot = Path.GetFullPath(Path.Combine(AppContext.BaseDirectory, "../../../.."));
var jsonPath = Path.Combine(workspaceRoot, "steamworks_sdk_163", "sdk", "public", "steam", "steam_api.json");
var referenceDllPath = Path.Combine(workspaceRoot, "steamworks_sdk_163", "sdk", "redistributable_bin", "win64", "steam_api64.dll");
var outputDir = Path.Combine(workspaceRoot, "steam_api", "Generated");

Console.WriteLine($"Loading JSON from {jsonPath}");
var api = JsonSerializer.Deserialize<SteamApiDefinition>(File.ReadAllText(jsonPath), new JsonSerializerOptions
{
    PropertyNameCaseInsensitive = true,
    ReadCommentHandling = JsonCommentHandling.Skip
}) ?? throw new InvalidOperationException("Failed to parse steam_api.json");

Console.WriteLine($"Reading exports from {referenceDllPath}");
var exports = PeReader.GetExports(referenceDllPath);
Console.WriteLine($"Found {exports.Count} exports.");

Directory.CreateDirectory(outputDir);

// Generate ArchConfig
File.WriteAllText(Path.Combine(outputDir, "ArchConfig.cs"), Generator.GenerateArchConfig());

// Generate Interfaces & VTables
var interfaceSb = new StringBuilder();
var shimSb = new StringBuilder();
var logicSb = new StringBuilder();

interfaceSb.AppendLine("// <auto-generated/>");
interfaceSb.AppendLine("using System.Runtime.InteropServices;");
interfaceSb.AppendLine("namespace SteamEmulator;");
interfaceSb.AppendLine();

shimSb.AppendLine("// <auto-generated/>");
shimSb.AppendLine("using System.Runtime.InteropServices;");
shimSb.AppendLine("using System.Runtime.CompilerServices;");
shimSb.AppendLine("namespace SteamEmulator;");
shimSb.AppendLine();

logicSb.AppendLine("// <auto-generated/>");
logicSb.AppendLine("using System;");
logicSb.AppendLine("namespace SteamEmulator;");
logicSb.AppendLine();

// Generate Interfaces
foreach (var iface in api.Interfaces)
{
    var vtableCode = Generator.GenerateVTable(iface);
    interfaceSb.AppendLine(vtableCode);

    var logicCode = Generator.GenerateLogicInterface(iface);
    logicSb.AppendLine(logicCode);

    var shimCode = Generator.GenerateShim(iface);
    shimSb.AppendLine(shimCode);

    var extCode = Generator.GenerateExtensions(iface);
    // interfaceSb.AppendLine(extCode); // Put extensions in Interface file or separate?
}

File.WriteAllText(Path.Combine(outputDir, "SteamInterfaces.cs"), interfaceSb.ToString());
File.WriteAllText(Path.Combine(outputDir, "SteamShims.cs"), shimSb.ToString());
File.WriteAllText(Path.Combine(outputDir, "SteamLogic.cs"), logicSb.ToString());
File.WriteAllText(Path.Combine(outputDir, "SteamExtensions.cs"), Generator.GenerateAllExtensions(api.Interfaces));

// Generate DEF file
var defSb = new StringBuilder();
defSb.AppendLine("LIBRARY steam_api64");
defSb.AppendLine("EXPORTS");

foreach (var export in exports.OrderBy(e => e.Ordinal))
{
    // The user wants to map exports.
    // Shim functions will be named e.g. "SteamUser_Shim" in C#, but we export them as "SteamUser" in .def
    // Actually NativeAOT allows [UnmanagedCallersOnly(EntryPoint="...")]
    // But generating a .def file gives precise control over ordinals.
    
    // We need to map the export name to our implementation.
    // For global accessors like "SteamUser", we will likely implement them as static methods in a specific class.
    // For now, I will assume a class 'SteamExports' contains these methods.
    
    // However, the task says: "Create a robust Codegen tool... The .def file generator mapping functions to ordinals starting at @1."
    
    // If we have a Shim method for "SteamUser", let's say "Interop.SteamUser", we map it here.
    // If the export is not found in our generated code, we might output a comment or placeholder.
    // But since we are generating shims for INTERFACES, we also need to handle Global Accessors.
    
    // The global accessors are NOT in the 'interfaces' list usually.
    // They are just flat exports.
    // We will assume that for every interface access (e.g. SteamUser), there exists a static method we implement manually or generate.
    
    // The JSON does not list global flat exports explicitly in 'interfaces'.
    // It DOES list 'accessors' in Typedefs? No.
    
    // But we can guess: ISteamUser -> SteamUser()
    
    defSb.AppendLine($"    {export.Name} @{export.Ordinal}");
}

File.WriteAllText(Path.Combine(outputDir, "steam_api64.def"), defSb.ToString());

Console.WriteLine("Done.");

// ----------------------------------------------------------------------------
// Generator Logic
// ----------------------------------------------------------------------------

public static class Generator
{
    public static string GenerateArchConfig()
    {
        return """
        namespace SteamEmulator;
        
        public static class ArchConfig
        {
        #if TARGET_64BIT
            public const int PACK = 8;
        #else
            public const int PACK = 4;
        #endif
        }
        """;
    }

    public static string GenerateVTable(InterfaceDef iface)
    {
        var sb = new StringBuilder();
        sb.AppendLine($"[StructLayout(LayoutKind.Sequential, Pack = ArchConfig.PACK)]");
        sb.AppendLine($"public unsafe struct {iface.ClassName}VTable");
        sb.AppendLine("{");
        
        foreach (var method in iface.Methods)
        {
            // Function pointer field
            // No, user said: "Generate a struct of IntPtr fields"
            sb.AppendLine($"    public IntPtr {method.MethodName};");
        }
        sb.AppendLine("}");
        return sb.ToString();
    }

    public static string GenerateLogicInterface(InterfaceDef iface)
    {
        var sb = new StringBuilder();
        var logicName = iface.ClassName.StartsWith("I") ? iface.ClassName.Insert(1, "Logic_") : iface.ClassName + "_Logic"; // e.g. ILogic_SteamUser? OR ISteamUserLogic
        // "I...Logic interfaces" -> ISteamUserLogic
        logicName = iface.ClassName + "Logic";

        sb.AppendLine($"public interface {logicName}");
        sb.AppendLine("{");
        foreach (var method in iface.Methods)
        {
            sb.Append($"    {MapType(method.ReturnType)} {method.MethodName}(");
            for (int i = 0; i < method.Params.Count; i++)
            {
                var p = method.Params[i];
                sb.Append($"{MapType(p.ParamType)} {CleanParamName(p.ParamName)}");
                if (i < method.Params.Count - 1) sb.Append(", ");
            }
            sb.AppendLine(");");
        }
        sb.AppendLine("}");
        return sb.ToString();
    }

    public static string GenerateShim(InterfaceDef iface)
    {
        var sb = new StringBuilder();
        var shimClassName = iface.ClassName + "Shim";
        var logicInterface = iface.ClassName + "Logic";

        sb.AppendLine($"public unsafe class {shimClassName}");
        sb.AppendLine("{");
        sb.AppendLine($"    public static {iface.ClassName}VTable VTable;");
        sb.AppendLine($"    public static IntPtr VTablePtr;");
        
        sb.AppendLine();
        sb.AppendLine($"    static {shimClassName}()");
        sb.AppendLine("    {");
        sb.AppendLine($"        VTablePtr = (IntPtr)Unsafe.AsPointer(ref VTable);");
        // Initialize VTable pointers
        foreach (var method in iface.Methods)
        {
            var stubName = $"{iface.ClassName}_{method.MethodName}";
            sb.AppendLine($"        VTable.{method.MethodName} = (IntPtr)(delegate* unmanaged[Cdecl]<{GetSigTypes(method, true)}>)&{stubName};");
        }
        sb.AppendLine("    }");
        
        // Factory Method
        sb.AppendLine();
        sb.AppendLine($"    public static IntPtr Create({logicInterface} logic)");
        sb.AppendLine("    {");
        sb.AppendLine("        var handle = GCHandle.Alloc(logic);");
        sb.AppendLine("        var ptr = Marshal.AllocHGlobal(IntPtr.Size * 2);");
        sb.AppendLine("        *(IntPtr*)ptr = VTablePtr;");
        sb.AppendLine("        *(IntPtr*)((byte*)ptr + IntPtr.Size) = GCHandle.ToIntPtr(handle);");
        sb.AppendLine("        return ptr;");
        sb.AppendLine("    }");

        foreach (var method in iface.Methods)
        {
            var stubName = $"{iface.ClassName}_{method.MethodName}";
            sb.AppendLine();
            sb.AppendLine($"    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]");
            sb.Append($"    public static {MapType(method.ReturnType)} {stubName}(IntPtr pThis");
            
            foreach (var p in method.Params)
            {
                sb.Append($", {MapType(p.ParamType)} {CleanParamName(p.ParamName)}");
            }
            sb.AppendLine(")");
            sb.AppendLine("    {");
            sb.AppendLine("        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);");
            sb.AppendLine("        var handle = GCHandle.FromIntPtr(handlePtr);");
            sb.AppendLine($"        var logic = ({logicInterface})handle.Target!;");
            sb.Append($"        return logic.{method.MethodName}(");
            for (int i = 0; i < method.Params.Count; i++)
            {
                sb.Append($"{CleanParamName(method.Params[i].ParamName)}");
                if (i < method.Params.Count - 1) sb.Append(", ");
            }
            sb.AppendLine(");");
            sb.AppendLine("    }");
        }

        sb.AppendLine("}");
        return sb.ToString();
    }
    
    public static string GenerateAllExtensions(List<InterfaceDef> interfaces)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Runtime.InteropServices;");
        sb.AppendLine("using System.Runtime.CompilerServices;");
        sb.AppendLine("namespace SteamEmulator;");
        sb.AppendLine();
        sb.AppendLine("public static unsafe class SteamExtensions");
        sb.AppendLine("{");
        foreach(var iface in interfaces)
        {
             sb.AppendLine(GenerateExtensions(iface));
        }
        sb.AppendLine("}");
        return sb.ToString();
    }

    public static string GenerateExtensions(InterfaceDef iface)
    {
        var sb = new StringBuilder();
        // Index tracking
        int index = 0;
        foreach (var method in iface.Methods)
        {
            sb.Append($"    public static {MapType(method.ReturnType)} {method.MethodName}(this IntPtr pThis");
            foreach (var p in method.Params)
            {
                sb.Append($", {MapType(p.ParamType)} {CleanParamName(p.ParamName)}");
            }
            sb.AppendLine(")");
            sb.AppendLine("    {");
            sb.AppendLine("        var vtable = *(IntPtr*)pThis;");
            sb.AppendLine($"        var func = *(delegate* unmanaged[Cdecl]<{GetSigTypes(method, true)}>)((byte*)vtable + {index} * IntPtr.Size);");
            sb.Append("        return func(pThis");
             foreach (var p in method.Params)
            {
                sb.Append($", {CleanParamName(p.ParamName)}");
            }
            sb.AppendLine(");");
            sb.AppendLine("    }");
            index++;
        }
        return sb.ToString();
    }

    static string GetSigTypes(MethodDef method, bool includeRet)
    {
        // First arg is IntPtr pThis
        var sb = new StringBuilder();
        sb.Append("IntPtr"); // pThis
        foreach (var p in method.Params)
        {
            sb.Append($", {MapType(p.ParamType)}");
        }
        if (includeRet)
        {
            sb.Append($", {MapType(method.ReturnType)}");
        }
        else
        {
             // For function pointers in C# 9+, return type is last generic arg
        }
        return sb.ToString();
    }

    public static string MapType(string type)
    {
        type = type.Replace("const ", "").Trim();
        if (type.EndsWith("*")) return "IntPtr";
        if (type == "const char *") return "IntPtr";
        if (type == "char *") return "IntPtr";
        if (type == "SteamAPICall_t") return "ulong";
        if (type == "CSteamID") return "ulong"; // Simplified
        if (type == "CGameID") return "ulong";
        if (type == "uint64") return "ulong";
        if (type == "int32") return "int";
        if (type == "uint32") return "uint";
        if (type == "int64") return "long";
        if (type == "bool") return "byte"; // per requirements
        if (type == "void") return "void";
        
        // Default to int/uint if unknown enum or simple type, or IntPtr if handle
        if (type.StartsWith("H")) return "uint"; // Handles are usually ints or uints
        if (type.StartsWith("E")) return "int"; // Enums
        
        return "int"; // Check fallback
    }
    
    static string CleanParamName(string name)
    {
        if (name == "params") return "@params";
        if (name == "string") return "@string";
        if (name == "class") return "@class";
        return name;
    }
}

// ----------------------------------------------------------------------------
// JSON Models
// ----------------------------------------------------------------------------

public class SteamApiDefinition
{
    public List<InterfaceDef> Interfaces { get; set; } = new();
}

public class InterfaceDef
{
    [JsonPropertyName("classname")]
    public string ClassName { get; set; } = "";
    public List<MethodDef> Methods { get; set; } = new();
}

public class MethodDef
{
    [JsonPropertyName("methodname")]
    public string MethodName { get; set; } = "";
    [JsonPropertyName("returntype")]
    public string ReturnType { get; set; } = "";
    public List<ParamDef> Params { get; set; } = new();
}

public class ParamDef
{
    [JsonPropertyName("paramname")]
    public string ParamName { get; set; } = "";
    [JsonPropertyName("paramtype")]
    public string ParamType { get; set; } = "";
}

public class ExportInfo
{
    public string Name { get; set; } = "";
    public int Ordinal { get; set; }
}

// ----------------------------------------------------------------------------
// PE Export Reader
// ----------------------------------------------------------------------------

public static class PeReader
{
    public static List<ExportInfo> GetExports(string path)
    {
        var exports = new List<ExportInfo>();
        using var fs = File.OpenRead(path);
        using var reader = new BinaryReader(fs);

        // DOS Header
        fs.Seek(0x3C, SeekOrigin.Begin);
        var e_lfanew = reader.ReadInt32();

        // PE Header
        fs.Seek(e_lfanew, SeekOrigin.Begin);
        var signature = reader.ReadUInt32(); // PE\0\0
        var machine = reader.ReadUInt16();
        var numberOfSections = reader.ReadUInt16();
        fs.Seek(12, SeekOrigin.Current); // Skip to OptionalHeader size
        var sizeOfOptionalHeader = reader.ReadUInt16();
        fs.Seek(2, SeekOrigin.Current); // Characteristics

        Console.WriteLine($"PE Header: Machine={machine:X}, Sections={numberOfSections}, OptHdrSize={sizeOfOptionalHeader:X}");

        // Optional Header
        var magic = reader.ReadUInt16(); // 0x10B (32bit) or 0x20B (64bit)
        
        // Correct offsets:
        // PE32+ (64-bit): NumberOfRvaAndSizes at 108, DataDirectory at 112
        // PE32 (32-bit): NumberOfRvaAndSizes at 92, DataDirectory at 96
        int numRvaOffset = (magic == 0x20B) ? 108 : 92;
        fs.Seek(e_lfanew + 4 + 20 + numRvaOffset, SeekOrigin.Begin); 
        var numberOfRvaAndSizes = reader.ReadUInt32();

        if (numberOfRvaAndSizes == 0) return exports;

        // Data Directories start right after
        var exportRva = reader.ReadUInt32();
        var exportSize = reader.ReadUInt32();

        Console.WriteLine($"Export Directory: RVA={exportRva:X}, Size={exportSize:X}");

        if (exportRva == 0) return exports;

        // Map RVA to File Offset
        // Read Sections
        long sectionsStart = e_lfanew + 4 + 20 + sizeOfOptionalHeader;
        long exportFileOffset = RvaToFileOffset(exportRva, sectionsStart, numberOfSections, reader);
        
        Console.WriteLine($"Export File Offset: {exportFileOffset:X}");

        if (exportFileOffset == 0) return exports;

        // Read Export Directory Table
        fs.Seek(exportFileOffset, SeekOrigin.Begin);
        var characteristics = reader.ReadUInt32();
        var timeDateStamp = reader.ReadUInt32();
        var majorVersion = reader.ReadUInt16();
        var minorVersion = reader.ReadUInt16();
        var nameRva = reader.ReadUInt32();
        var ordinalBase = reader.ReadUInt32();
        var numberOfFunctions = reader.ReadUInt32();
        var numberOfNames = reader.ReadUInt32();
        var addressOfFunctionsRva = reader.ReadUInt32();
        var addressOfNamesRva = reader.ReadUInt32();
        var addressOfNameOrdinalsRva = reader.ReadUInt32();

        Console.WriteLine($"Exports: Names={numberOfNames}, Funcs={numberOfFunctions}, Base={ordinalBase}");
        Console.WriteLine($"NamesRVA={addressOfNamesRva:X}, OrdsRVA={addressOfNameOrdinalsRva:X}");

        var namesStart = RvaToFileOffset(addressOfNamesRva, sectionsStart, numberOfSections, reader);
        var ordinalsStart = RvaToFileOffset(addressOfNameOrdinalsRva, sectionsStart, numberOfSections, reader);

        for (int i = 0; i < numberOfNames; i++)
        {
            fs.Seek(namesStart + i * 4, SeekOrigin.Begin);
            var namePtrRva = reader.ReadUInt32();
            
            fs.Seek(ordinalsStart + i * 2, SeekOrigin.Begin);
            var ordinalIndex = reader.ReadUInt16();

            var nameOffset = RvaToFileOffset(namePtrRva, sectionsStart, numberOfSections, reader);
            
            fs.Seek(nameOffset, SeekOrigin.Begin);
            var name = ReadNullTerminatedString(reader);

            exports.Add(new ExportInfo { Name = name, Ordinal = (int)(ordinalBase + ordinalIndex) });
        }

        return exports;
    }

    static long RvaToFileOffset(uint rva, long sectionsStart, int numberOfSections, BinaryReader reader)
    {
        for (int i = 0; i < numberOfSections; i++)
        {
            reader.BaseStream.Seek(sectionsStart + i * 40, SeekOrigin.Begin);
            var nameChars = reader.ReadBytes(8);
            var name = Encoding.UTF8.GetString(nameChars).TrimEnd('\0'); // Debug use
            var virtualSize = reader.ReadUInt32();
            var virtualAddress = reader.ReadUInt32();
            var sizeOfRawData = reader.ReadUInt32();
            var pointerToRawData = reader.ReadUInt32();

            // Console.WriteLine($"Section {name}: VA={virtualAddress:X}, VSize={virtualSize:X}, RawPtr={pointerToRawData:X}, RawSize={sizeOfRawData:X}");

            if (rva >= virtualAddress && rva < virtualAddress + Math.Max(virtualSize, sizeOfRawData))
            {
                 if (rva < virtualAddress + sizeOfRawData)
                 {
                     return pointerToRawData + (rva - virtualAddress);
                 }
            }
        }
        return 0;
    }

    static string ReadNullTerminatedString(BinaryReader reader)
    {
        var bytes = new List<byte>();
        while (true)
        {
            var b = reader.ReadByte();
            if (b == 0) break;
            bytes.Add(b);
        }
        return Encoding.ASCII.GetString(bytes.ToArray());
    }
}
