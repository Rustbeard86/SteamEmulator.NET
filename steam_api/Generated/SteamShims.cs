// <auto-generated/>
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;
namespace SteamEmulator;

public unsafe class ISteamClientShim
{
    public static ISteamClientVTable VTable;
    public static IntPtr VTablePtr;

    static ISteamClientShim()
    {
        VTablePtr = (IntPtr)Unsafe.AsPointer(ref VTable);
        VTable.CreateSteamPipe = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint>)&ISteamClient_CreateSteamPipe;
        VTable.BReleaseSteamPipe = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, byte>)&ISteamClient_BReleaseSteamPipe;
        VTable.ConnectToGlobalUser = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, uint>)&ISteamClient_ConnectToGlobalUser;
        VTable.CreateLocalUser = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, int, uint>)&ISteamClient_CreateLocalUser;
        VTable.ReleaseUser = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, uint, void>)&ISteamClient_ReleaseUser;
        VTable.GetISteamUser = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, uint, IntPtr, IntPtr>)&ISteamClient_GetISteamUser;
        VTable.GetISteamGameServer = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, uint, IntPtr, IntPtr>)&ISteamClient_GetISteamGameServer;
        VTable.SetLocalIPBinding = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, void>)&ISteamClient_SetLocalIPBinding;
        VTable.GetISteamFriends = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, uint, IntPtr, IntPtr>)&ISteamClient_GetISteamFriends;
        VTable.GetISteamUtils = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, IntPtr, IntPtr>)&ISteamClient_GetISteamUtils;
        VTable.GetISteamMatchmaking = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, uint, IntPtr, IntPtr>)&ISteamClient_GetISteamMatchmaking;
        VTable.GetISteamMatchmakingServers = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, uint, IntPtr, IntPtr>)&ISteamClient_GetISteamMatchmakingServers;
        VTable.GetISteamGenericInterface = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, uint, IntPtr, IntPtr>)&ISteamClient_GetISteamGenericInterface;
        VTable.GetISteamUserStats = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, uint, IntPtr, IntPtr>)&ISteamClient_GetISteamUserStats;
        VTable.GetISteamGameServerStats = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, uint, IntPtr, IntPtr>)&ISteamClient_GetISteamGameServerStats;
        VTable.GetISteamApps = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, uint, IntPtr, IntPtr>)&ISteamClient_GetISteamApps;
        VTable.GetISteamNetworking = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, uint, IntPtr, IntPtr>)&ISteamClient_GetISteamNetworking;
        VTable.GetISteamRemoteStorage = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, uint, IntPtr, IntPtr>)&ISteamClient_GetISteamRemoteStorage;
        VTable.GetISteamScreenshots = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, uint, IntPtr, IntPtr>)&ISteamClient_GetISteamScreenshots;
        VTable.GetIPCCallCount = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint>)&ISteamClient_GetIPCCallCount;
        VTable.SetWarningMessageHook = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, void>)&ISteamClient_SetWarningMessageHook;
        VTable.BShutdownIfAllPipesClosed = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, byte>)&ISteamClient_BShutdownIfAllPipesClosed;
        VTable.GetISteamHTTP = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, uint, IntPtr, IntPtr>)&ISteamClient_GetISteamHTTP;
        VTable.GetISteamController = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, uint, IntPtr, IntPtr>)&ISteamClient_GetISteamController;
        VTable.GetISteamUGC = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, uint, IntPtr, IntPtr>)&ISteamClient_GetISteamUGC;
        VTable.GetISteamMusic = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, uint, IntPtr, IntPtr>)&ISteamClient_GetISteamMusic;
        VTable.GetISteamHTMLSurface = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, uint, IntPtr, IntPtr>)&ISteamClient_GetISteamHTMLSurface;
        VTable.GetISteamInventory = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, uint, IntPtr, IntPtr>)&ISteamClient_GetISteamInventory;
        VTable.GetISteamVideo = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, uint, IntPtr, IntPtr>)&ISteamClient_GetISteamVideo;
        VTable.GetISteamParentalSettings = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, uint, IntPtr, IntPtr>)&ISteamClient_GetISteamParentalSettings;
        VTable.GetISteamInput = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, uint, IntPtr, IntPtr>)&ISteamClient_GetISteamInput;
        VTable.GetISteamParties = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, uint, IntPtr, IntPtr>)&ISteamClient_GetISteamParties;
        VTable.GetISteamRemotePlay = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, uint, IntPtr, IntPtr>)&ISteamClient_GetISteamRemotePlay;
    }

    public static IntPtr Create(ISteamClientLogic logic)
    {
        var handle = GCHandle.Alloc(logic);
        var ptr = Marshal.AllocHGlobal(IntPtr.Size * 2);
        *(IntPtr*)ptr = VTablePtr;
        *(IntPtr*)((byte*)ptr + IntPtr.Size) = GCHandle.ToIntPtr(handle);
        return ptr;
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static uint ISteamClient_CreateSteamPipe(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamClientLogic)handle.Target!;
        return logic.CreateSteamPipe();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamClient_BReleaseSteamPipe(IntPtr pThis, uint hSteamPipe)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamClientLogic)handle.Target!;
        return logic.BReleaseSteamPipe(hSteamPipe);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static uint ISteamClient_ConnectToGlobalUser(IntPtr pThis, uint hSteamPipe)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamClientLogic)handle.Target!;
        return logic.ConnectToGlobalUser(hSteamPipe);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static uint ISteamClient_CreateLocalUser(IntPtr pThis, IntPtr phSteamPipe, int eAccountType)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamClientLogic)handle.Target!;
        return logic.CreateLocalUser(phSteamPipe, eAccountType);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamClient_ReleaseUser(IntPtr pThis, uint hSteamPipe, uint hUser)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamClientLogic)handle.Target!;
        return logic.ReleaseUser(hSteamPipe, hUser);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static IntPtr ISteamClient_GetISteamUser(IntPtr pThis, uint hSteamUser, uint hSteamPipe, IntPtr pchVersion)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamClientLogic)handle.Target!;
        return logic.GetISteamUser(hSteamUser, hSteamPipe, pchVersion);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static IntPtr ISteamClient_GetISteamGameServer(IntPtr pThis, uint hSteamUser, uint hSteamPipe, IntPtr pchVersion)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamClientLogic)handle.Target!;
        return logic.GetISteamGameServer(hSteamUser, hSteamPipe, pchVersion);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamClient_SetLocalIPBinding(IntPtr pThis, int unIP, int usPort)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamClientLogic)handle.Target!;
        return logic.SetLocalIPBinding(unIP, usPort);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static IntPtr ISteamClient_GetISteamFriends(IntPtr pThis, uint hSteamUser, uint hSteamPipe, IntPtr pchVersion)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamClientLogic)handle.Target!;
        return logic.GetISteamFriends(hSteamUser, hSteamPipe, pchVersion);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static IntPtr ISteamClient_GetISteamUtils(IntPtr pThis, uint hSteamPipe, IntPtr pchVersion)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamClientLogic)handle.Target!;
        return logic.GetISteamUtils(hSteamPipe, pchVersion);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static IntPtr ISteamClient_GetISteamMatchmaking(IntPtr pThis, uint hSteamUser, uint hSteamPipe, IntPtr pchVersion)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamClientLogic)handle.Target!;
        return logic.GetISteamMatchmaking(hSteamUser, hSteamPipe, pchVersion);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static IntPtr ISteamClient_GetISteamMatchmakingServers(IntPtr pThis, uint hSteamUser, uint hSteamPipe, IntPtr pchVersion)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamClientLogic)handle.Target!;
        return logic.GetISteamMatchmakingServers(hSteamUser, hSteamPipe, pchVersion);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static IntPtr ISteamClient_GetISteamGenericInterface(IntPtr pThis, uint hSteamUser, uint hSteamPipe, IntPtr pchVersion)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamClientLogic)handle.Target!;
        return logic.GetISteamGenericInterface(hSteamUser, hSteamPipe, pchVersion);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static IntPtr ISteamClient_GetISteamUserStats(IntPtr pThis, uint hSteamUser, uint hSteamPipe, IntPtr pchVersion)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamClientLogic)handle.Target!;
        return logic.GetISteamUserStats(hSteamUser, hSteamPipe, pchVersion);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static IntPtr ISteamClient_GetISteamGameServerStats(IntPtr pThis, uint hSteamuser, uint hSteamPipe, IntPtr pchVersion)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamClientLogic)handle.Target!;
        return logic.GetISteamGameServerStats(hSteamuser, hSteamPipe, pchVersion);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static IntPtr ISteamClient_GetISteamApps(IntPtr pThis, uint hSteamUser, uint hSteamPipe, IntPtr pchVersion)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamClientLogic)handle.Target!;
        return logic.GetISteamApps(hSteamUser, hSteamPipe, pchVersion);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static IntPtr ISteamClient_GetISteamNetworking(IntPtr pThis, uint hSteamUser, uint hSteamPipe, IntPtr pchVersion)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamClientLogic)handle.Target!;
        return logic.GetISteamNetworking(hSteamUser, hSteamPipe, pchVersion);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static IntPtr ISteamClient_GetISteamRemoteStorage(IntPtr pThis, uint hSteamuser, uint hSteamPipe, IntPtr pchVersion)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamClientLogic)handle.Target!;
        return logic.GetISteamRemoteStorage(hSteamuser, hSteamPipe, pchVersion);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static IntPtr ISteamClient_GetISteamScreenshots(IntPtr pThis, uint hSteamuser, uint hSteamPipe, IntPtr pchVersion)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamClientLogic)handle.Target!;
        return logic.GetISteamScreenshots(hSteamuser, hSteamPipe, pchVersion);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static uint ISteamClient_GetIPCCallCount(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamClientLogic)handle.Target!;
        return logic.GetIPCCallCount();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamClient_SetWarningMessageHook(IntPtr pThis, int pFunction)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamClientLogic)handle.Target!;
        return logic.SetWarningMessageHook(pFunction);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamClient_BShutdownIfAllPipesClosed(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamClientLogic)handle.Target!;
        return logic.BShutdownIfAllPipesClosed();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static IntPtr ISteamClient_GetISteamHTTP(IntPtr pThis, uint hSteamuser, uint hSteamPipe, IntPtr pchVersion)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamClientLogic)handle.Target!;
        return logic.GetISteamHTTP(hSteamuser, hSteamPipe, pchVersion);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static IntPtr ISteamClient_GetISteamController(IntPtr pThis, uint hSteamUser, uint hSteamPipe, IntPtr pchVersion)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamClientLogic)handle.Target!;
        return logic.GetISteamController(hSteamUser, hSteamPipe, pchVersion);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static IntPtr ISteamClient_GetISteamUGC(IntPtr pThis, uint hSteamUser, uint hSteamPipe, IntPtr pchVersion)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamClientLogic)handle.Target!;
        return logic.GetISteamUGC(hSteamUser, hSteamPipe, pchVersion);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static IntPtr ISteamClient_GetISteamMusic(IntPtr pThis, uint hSteamuser, uint hSteamPipe, IntPtr pchVersion)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamClientLogic)handle.Target!;
        return logic.GetISteamMusic(hSteamuser, hSteamPipe, pchVersion);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static IntPtr ISteamClient_GetISteamHTMLSurface(IntPtr pThis, uint hSteamuser, uint hSteamPipe, IntPtr pchVersion)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamClientLogic)handle.Target!;
        return logic.GetISteamHTMLSurface(hSteamuser, hSteamPipe, pchVersion);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static IntPtr ISteamClient_GetISteamInventory(IntPtr pThis, uint hSteamuser, uint hSteamPipe, IntPtr pchVersion)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamClientLogic)handle.Target!;
        return logic.GetISteamInventory(hSteamuser, hSteamPipe, pchVersion);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static IntPtr ISteamClient_GetISteamVideo(IntPtr pThis, uint hSteamuser, uint hSteamPipe, IntPtr pchVersion)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamClientLogic)handle.Target!;
        return logic.GetISteamVideo(hSteamuser, hSteamPipe, pchVersion);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static IntPtr ISteamClient_GetISteamParentalSettings(IntPtr pThis, uint hSteamuser, uint hSteamPipe, IntPtr pchVersion)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamClientLogic)handle.Target!;
        return logic.GetISteamParentalSettings(hSteamuser, hSteamPipe, pchVersion);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static IntPtr ISteamClient_GetISteamInput(IntPtr pThis, uint hSteamUser, uint hSteamPipe, IntPtr pchVersion)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamClientLogic)handle.Target!;
        return logic.GetISteamInput(hSteamUser, hSteamPipe, pchVersion);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static IntPtr ISteamClient_GetISteamParties(IntPtr pThis, uint hSteamUser, uint hSteamPipe, IntPtr pchVersion)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamClientLogic)handle.Target!;
        return logic.GetISteamParties(hSteamUser, hSteamPipe, pchVersion);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static IntPtr ISteamClient_GetISteamRemotePlay(IntPtr pThis, uint hSteamUser, uint hSteamPipe, IntPtr pchVersion)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamClientLogic)handle.Target!;
        return logic.GetISteamRemotePlay(hSteamUser, hSteamPipe, pchVersion);
    }
}

public unsafe class ISteamUserShim
{
    public static ISteamUserVTable VTable;
    public static IntPtr VTablePtr;

    static ISteamUserShim()
    {
        VTablePtr = (IntPtr)Unsafe.AsPointer(ref VTable);
        VTable.GetHSteamUser = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint>)&ISteamUser_GetHSteamUser;
        VTable.BLoggedOn = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, byte>)&ISteamUser_BLoggedOn;
        VTable.GetSteamID = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong>)&ISteamUser_GetSteamID;
        VTable.InitiateGameConnection_DEPRECATED = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, int, ulong, uint, int, byte, int>)&ISteamUser_InitiateGameConnection_DEPRECATED;
        VTable.TerminateGameConnection_DEPRECATED = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, int, void>)&ISteamUser_TerminateGameConnection_DEPRECATED;
        VTable.TrackAppUsageEvent = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, int, IntPtr, void>)&ISteamUser_TrackAppUsageEvent;
        VTable.GetUserDataFolder = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, int, byte>)&ISteamUser_GetUserDataFolder;
        VTable.StartVoiceRecording = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, void>)&ISteamUser_StartVoiceRecording;
        VTable.StopVoiceRecording = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, void>)&ISteamUser_StopVoiceRecording;
        VTable.GetAvailableVoice = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, IntPtr, uint, int>)&ISteamUser_GetAvailableVoice;
        VTable.GetVoice = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, byte, IntPtr, uint, IntPtr, byte, IntPtr, uint, IntPtr, uint, int>)&ISteamUser_GetVoice;
        VTable.DecompressVoice = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, uint, IntPtr, uint, IntPtr, uint, int>)&ISteamUser_DecompressVoice;
        VTable.GetVoiceOptimalSampleRate = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint>)&ISteamUser_GetVoiceOptimalSampleRate;
        VTable.GetAuthSessionTicket = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, int, IntPtr, IntPtr, uint>)&ISteamUser_GetAuthSessionTicket;
        VTable.GetAuthTicketForWebApi = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, uint>)&ISteamUser_GetAuthTicketForWebApi;
        VTable.BeginAuthSession = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, int, ulong, int>)&ISteamUser_BeginAuthSession;
        VTable.EndAuthSession = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, void>)&ISteamUser_EndAuthSession;
        VTable.CancelAuthTicket = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, void>)&ISteamUser_CancelAuthTicket;
        VTable.UserHasLicenseForApp = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, int, int>)&ISteamUser_UserHasLicenseForApp;
        VTable.BIsBehindNAT = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, byte>)&ISteamUser_BIsBehindNAT;
        VTable.AdvertiseGame = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, uint, int, void>)&ISteamUser_AdvertiseGame;
        VTable.RequestEncryptedAppTicket = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, int, ulong>)&ISteamUser_RequestEncryptedAppTicket;
        VTable.GetEncryptedAppTicket = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, int, IntPtr, byte>)&ISteamUser_GetEncryptedAppTicket;
        VTable.GetGameBadgeLevel = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, byte, int>)&ISteamUser_GetGameBadgeLevel;
        VTable.GetPlayerSteamLevel = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int>)&ISteamUser_GetPlayerSteamLevel;
        VTable.RequestStoreAuthURL = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, ulong>)&ISteamUser_RequestStoreAuthURL;
        VTable.BIsPhoneVerified = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, byte>)&ISteamUser_BIsPhoneVerified;
        VTable.BIsTwoFactorEnabled = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, byte>)&ISteamUser_BIsTwoFactorEnabled;
        VTable.BIsPhoneIdentifying = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, byte>)&ISteamUser_BIsPhoneIdentifying;
        VTable.BIsPhoneRequiringVerification = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, byte>)&ISteamUser_BIsPhoneRequiringVerification;
        VTable.GetMarketEligibility = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong>)&ISteamUser_GetMarketEligibility;
        VTable.GetDurationControl = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong>)&ISteamUser_GetDurationControl;
        VTable.BSetDurationControlOnlineState = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, byte>)&ISteamUser_BSetDurationControlOnlineState;
    }

    public static IntPtr Create(ISteamUserLogic logic)
    {
        var handle = GCHandle.Alloc(logic);
        var ptr = Marshal.AllocHGlobal(IntPtr.Size * 2);
        *(IntPtr*)ptr = VTablePtr;
        *(IntPtr*)((byte*)ptr + IntPtr.Size) = GCHandle.ToIntPtr(handle);
        return ptr;
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static uint ISteamUser_GetHSteamUser(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUserLogic)handle.Target!;
        return logic.GetHSteamUser();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUser_BLoggedOn(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUserLogic)handle.Target!;
        return logic.BLoggedOn();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamUser_GetSteamID(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUserLogic)handle.Target!;
        return logic.GetSteamID();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamUser_InitiateGameConnection_DEPRECATED(IntPtr pThis, IntPtr pAuthBlob, int cbMaxAuthBlob, ulong steamIDGameServer, uint unIPServer, int usPortServer, byte bSecure)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUserLogic)handle.Target!;
        return logic.InitiateGameConnection_DEPRECATED(pAuthBlob, cbMaxAuthBlob, steamIDGameServer, unIPServer, usPortServer, bSecure);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamUser_TerminateGameConnection_DEPRECATED(IntPtr pThis, uint unIPServer, int usPortServer)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUserLogic)handle.Target!;
        return logic.TerminateGameConnection_DEPRECATED(unIPServer, usPortServer);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamUser_TrackAppUsageEvent(IntPtr pThis, ulong gameID, int eAppUsageEvent, IntPtr pchExtraInfo)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUserLogic)handle.Target!;
        return logic.TrackAppUsageEvent(gameID, eAppUsageEvent, pchExtraInfo);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUser_GetUserDataFolder(IntPtr pThis, IntPtr pchBuffer, int cubBuffer)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUserLogic)handle.Target!;
        return logic.GetUserDataFolder(pchBuffer, cubBuffer);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamUser_StartVoiceRecording(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUserLogic)handle.Target!;
        return logic.StartVoiceRecording();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamUser_StopVoiceRecording(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUserLogic)handle.Target!;
        return logic.StopVoiceRecording();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamUser_GetAvailableVoice(IntPtr pThis, IntPtr pcbCompressed, IntPtr pcbUncompressed_Deprecated, uint nUncompressedVoiceDesiredSampleRate_Deprecated)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUserLogic)handle.Target!;
        return logic.GetAvailableVoice(pcbCompressed, pcbUncompressed_Deprecated, nUncompressedVoiceDesiredSampleRate_Deprecated);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamUser_GetVoice(IntPtr pThis, byte bWantCompressed, IntPtr pDestBuffer, uint cbDestBufferSize, IntPtr nBytesWritten, byte bWantUncompressed_Deprecated, IntPtr pUncompressedDestBuffer_Deprecated, uint cbUncompressedDestBufferSize_Deprecated, IntPtr nUncompressBytesWritten_Deprecated, uint nUncompressedVoiceDesiredSampleRate_Deprecated)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUserLogic)handle.Target!;
        return logic.GetVoice(bWantCompressed, pDestBuffer, cbDestBufferSize, nBytesWritten, bWantUncompressed_Deprecated, pUncompressedDestBuffer_Deprecated, cbUncompressedDestBufferSize_Deprecated, nUncompressBytesWritten_Deprecated, nUncompressedVoiceDesiredSampleRate_Deprecated);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamUser_DecompressVoice(IntPtr pThis, IntPtr pCompressed, uint cbCompressed, IntPtr pDestBuffer, uint cbDestBufferSize, IntPtr nBytesWritten, uint nDesiredSampleRate)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUserLogic)handle.Target!;
        return logic.DecompressVoice(pCompressed, cbCompressed, pDestBuffer, cbDestBufferSize, nBytesWritten, nDesiredSampleRate);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static uint ISteamUser_GetVoiceOptimalSampleRate(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUserLogic)handle.Target!;
        return logic.GetVoiceOptimalSampleRate();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static uint ISteamUser_GetAuthSessionTicket(IntPtr pThis, IntPtr pTicket, int cbMaxTicket, IntPtr pcbTicket, IntPtr pSteamNetworkingIdentity)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUserLogic)handle.Target!;
        return logic.GetAuthSessionTicket(pTicket, cbMaxTicket, pcbTicket, pSteamNetworkingIdentity);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static uint ISteamUser_GetAuthTicketForWebApi(IntPtr pThis, IntPtr pchIdentity)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUserLogic)handle.Target!;
        return logic.GetAuthTicketForWebApi(pchIdentity);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamUser_BeginAuthSession(IntPtr pThis, IntPtr pAuthTicket, int cbAuthTicket, ulong steamID)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUserLogic)handle.Target!;
        return logic.BeginAuthSession(pAuthTicket, cbAuthTicket, steamID);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamUser_EndAuthSession(IntPtr pThis, ulong steamID)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUserLogic)handle.Target!;
        return logic.EndAuthSession(steamID);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamUser_CancelAuthTicket(IntPtr pThis, uint hAuthTicket)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUserLogic)handle.Target!;
        return logic.CancelAuthTicket(hAuthTicket);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamUser_UserHasLicenseForApp(IntPtr pThis, ulong steamID, int appID)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUserLogic)handle.Target!;
        return logic.UserHasLicenseForApp(steamID, appID);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUser_BIsBehindNAT(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUserLogic)handle.Target!;
        return logic.BIsBehindNAT();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamUser_AdvertiseGame(IntPtr pThis, ulong steamIDGameServer, uint unIPServer, int usPortServer)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUserLogic)handle.Target!;
        return logic.AdvertiseGame(steamIDGameServer, unIPServer, usPortServer);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamUser_RequestEncryptedAppTicket(IntPtr pThis, IntPtr pDataToInclude, int cbDataToInclude)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUserLogic)handle.Target!;
        return logic.RequestEncryptedAppTicket(pDataToInclude, cbDataToInclude);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUser_GetEncryptedAppTicket(IntPtr pThis, IntPtr pTicket, int cbMaxTicket, IntPtr pcbTicket)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUserLogic)handle.Target!;
        return logic.GetEncryptedAppTicket(pTicket, cbMaxTicket, pcbTicket);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamUser_GetGameBadgeLevel(IntPtr pThis, int nSeries, byte bFoil)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUserLogic)handle.Target!;
        return logic.GetGameBadgeLevel(nSeries, bFoil);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamUser_GetPlayerSteamLevel(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUserLogic)handle.Target!;
        return logic.GetPlayerSteamLevel();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamUser_RequestStoreAuthURL(IntPtr pThis, IntPtr pchRedirectURL)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUserLogic)handle.Target!;
        return logic.RequestStoreAuthURL(pchRedirectURL);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUser_BIsPhoneVerified(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUserLogic)handle.Target!;
        return logic.BIsPhoneVerified();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUser_BIsTwoFactorEnabled(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUserLogic)handle.Target!;
        return logic.BIsTwoFactorEnabled();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUser_BIsPhoneIdentifying(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUserLogic)handle.Target!;
        return logic.BIsPhoneIdentifying();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUser_BIsPhoneRequiringVerification(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUserLogic)handle.Target!;
        return logic.BIsPhoneRequiringVerification();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamUser_GetMarketEligibility(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUserLogic)handle.Target!;
        return logic.GetMarketEligibility();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamUser_GetDurationControl(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUserLogic)handle.Target!;
        return logic.GetDurationControl();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUser_BSetDurationControlOnlineState(IntPtr pThis, int eNewState)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUserLogic)handle.Target!;
        return logic.BSetDurationControlOnlineState(eNewState);
    }
}

public unsafe class ISteamFriendsShim
{
    public static ISteamFriendsVTable VTable;
    public static IntPtr VTablePtr;

    static ISteamFriendsShim()
    {
        VTablePtr = (IntPtr)Unsafe.AsPointer(ref VTable);
        VTable.GetPersonaName = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr>)&ISteamFriends_GetPersonaName;
        VTable.GetPersonaState = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int>)&ISteamFriends_GetPersonaState;
        VTable.GetFriendCount = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int>)&ISteamFriends_GetFriendCount;
        VTable.GetFriendByIndex = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, ulong>)&ISteamFriends_GetFriendByIndex;
        VTable.GetFriendRelationship = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, int>)&ISteamFriends_GetFriendRelationship;
        VTable.GetFriendPersonaState = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, int>)&ISteamFriends_GetFriendPersonaState;
        VTable.GetFriendPersonaName = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, IntPtr>)&ISteamFriends_GetFriendPersonaName;
        VTable.GetFriendGamePlayed = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, IntPtr, byte>)&ISteamFriends_GetFriendGamePlayed;
        VTable.GetFriendPersonaNameHistory = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, int, IntPtr>)&ISteamFriends_GetFriendPersonaNameHistory;
        VTable.GetFriendSteamLevel = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, int>)&ISteamFriends_GetFriendSteamLevel;
        VTable.GetPlayerNickname = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, IntPtr>)&ISteamFriends_GetPlayerNickname;
        VTable.GetFriendsGroupCount = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int>)&ISteamFriends_GetFriendsGroupCount;
        VTable.GetFriendsGroupIDByIndex = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int>)&ISteamFriends_GetFriendsGroupIDByIndex;
        VTable.GetFriendsGroupName = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr>)&ISteamFriends_GetFriendsGroupName;
        VTable.GetFriendsGroupMembersCount = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int>)&ISteamFriends_GetFriendsGroupMembersCount;
        VTable.GetFriendsGroupMembersList = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, int, void>)&ISteamFriends_GetFriendsGroupMembersList;
        VTable.HasFriend = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, int, byte>)&ISteamFriends_HasFriend;
        VTable.GetClanCount = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int>)&ISteamFriends_GetClanCount;
        VTable.GetClanByIndex = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, ulong>)&ISteamFriends_GetClanByIndex;
        VTable.GetClanName = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, IntPtr>)&ISteamFriends_GetClanName;
        VTable.GetClanTag = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, IntPtr>)&ISteamFriends_GetClanTag;
        VTable.GetClanActivityCounts = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, IntPtr, IntPtr, IntPtr, byte>)&ISteamFriends_GetClanActivityCounts;
        VTable.DownloadClanActivityCounts = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, int, ulong>)&ISteamFriends_DownloadClanActivityCounts;
        VTable.GetFriendCountFromSource = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, int>)&ISteamFriends_GetFriendCountFromSource;
        VTable.GetFriendFromSourceByIndex = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, int, ulong>)&ISteamFriends_GetFriendFromSourceByIndex;
        VTable.IsUserInSource = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, ulong, byte>)&ISteamFriends_IsUserInSource;
        VTable.SetInGameVoiceSpeaking = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, byte, void>)&ISteamFriends_SetInGameVoiceSpeaking;
        VTable.ActivateGameOverlay = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, void>)&ISteamFriends_ActivateGameOverlay;
        VTable.ActivateGameOverlayToUser = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, ulong, void>)&ISteamFriends_ActivateGameOverlayToUser;
        VTable.ActivateGameOverlayToWebPage = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, int, void>)&ISteamFriends_ActivateGameOverlayToWebPage;
        VTable.ActivateGameOverlayToStore = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, void>)&ISteamFriends_ActivateGameOverlayToStore;
        VTable.SetPlayedWith = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, void>)&ISteamFriends_SetPlayedWith;
        VTable.ActivateGameOverlayInviteDialog = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, void>)&ISteamFriends_ActivateGameOverlayInviteDialog;
        VTable.GetSmallFriendAvatar = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, int>)&ISteamFriends_GetSmallFriendAvatar;
        VTable.GetMediumFriendAvatar = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, int>)&ISteamFriends_GetMediumFriendAvatar;
        VTable.GetLargeFriendAvatar = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, int>)&ISteamFriends_GetLargeFriendAvatar;
        VTable.RequestUserInformation = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, byte, byte>)&ISteamFriends_RequestUserInformation;
        VTable.RequestClanOfficerList = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, ulong>)&ISteamFriends_RequestClanOfficerList;
        VTable.GetClanOwner = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, ulong>)&ISteamFriends_GetClanOwner;
        VTable.GetClanOfficerCount = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, int>)&ISteamFriends_GetClanOfficerCount;
        VTable.GetClanOfficerByIndex = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, int, ulong>)&ISteamFriends_GetClanOfficerByIndex;
        VTable.SetRichPresence = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, IntPtr, byte>)&ISteamFriends_SetRichPresence;
        VTable.ClearRichPresence = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, void>)&ISteamFriends_ClearRichPresence;
        VTable.GetFriendRichPresence = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, IntPtr, IntPtr>)&ISteamFriends_GetFriendRichPresence;
        VTable.GetFriendRichPresenceKeyCount = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, int>)&ISteamFriends_GetFriendRichPresenceKeyCount;
        VTable.GetFriendRichPresenceKeyByIndex = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, int, IntPtr>)&ISteamFriends_GetFriendRichPresenceKeyByIndex;
        VTable.RequestFriendRichPresence = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, void>)&ISteamFriends_RequestFriendRichPresence;
        VTable.InviteUserToGame = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, IntPtr, byte>)&ISteamFriends_InviteUserToGame;
        VTable.GetCoplayFriendCount = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int>)&ISteamFriends_GetCoplayFriendCount;
        VTable.GetCoplayFriend = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, ulong>)&ISteamFriends_GetCoplayFriend;
        VTable.GetFriendCoplayTime = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, int>)&ISteamFriends_GetFriendCoplayTime;
        VTable.GetFriendCoplayGame = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, int>)&ISteamFriends_GetFriendCoplayGame;
        VTable.JoinClanChatRoom = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, ulong>)&ISteamFriends_JoinClanChatRoom;
        VTable.LeaveClanChatRoom = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, byte>)&ISteamFriends_LeaveClanChatRoom;
        VTable.GetClanChatMemberCount = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, int>)&ISteamFriends_GetClanChatMemberCount;
        VTable.GetChatMemberByIndex = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, int, ulong>)&ISteamFriends_GetChatMemberByIndex;
        VTable.SendClanChatMessage = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, IntPtr, byte>)&ISteamFriends_SendClanChatMessage;
        VTable.GetClanChatMessage = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, int, IntPtr, int, IntPtr, IntPtr, int>)&ISteamFriends_GetClanChatMessage;
        VTable.IsClanChatAdmin = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, ulong, byte>)&ISteamFriends_IsClanChatAdmin;
        VTable.IsClanChatWindowOpenInSteam = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, byte>)&ISteamFriends_IsClanChatWindowOpenInSteam;
        VTable.OpenClanChatWindowInSteam = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, byte>)&ISteamFriends_OpenClanChatWindowInSteam;
        VTable.CloseClanChatWindowInSteam = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, byte>)&ISteamFriends_CloseClanChatWindowInSteam;
        VTable.SetListenForFriendsMessages = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, byte, byte>)&ISteamFriends_SetListenForFriendsMessages;
        VTable.ReplyToFriendMessage = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, IntPtr, byte>)&ISteamFriends_ReplyToFriendMessage;
        VTable.GetFriendMessage = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, int, IntPtr, int, IntPtr, int>)&ISteamFriends_GetFriendMessage;
        VTable.GetFollowerCount = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, ulong>)&ISteamFriends_GetFollowerCount;
        VTable.IsFollowing = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, ulong>)&ISteamFriends_IsFollowing;
        VTable.EnumerateFollowingList = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, ulong>)&ISteamFriends_EnumerateFollowingList;
        VTable.IsClanPublic = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, byte>)&ISteamFriends_IsClanPublic;
        VTable.IsClanOfficialGameGroup = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, byte>)&ISteamFriends_IsClanOfficialGameGroup;
        VTable.GetNumChatsWithUnreadPriorityMessages = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int>)&ISteamFriends_GetNumChatsWithUnreadPriorityMessages;
        VTable.ActivateGameOverlayRemotePlayTogetherInviteDialog = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, void>)&ISteamFriends_ActivateGameOverlayRemotePlayTogetherInviteDialog;
        VTable.RegisterProtocolInOverlayBrowser = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, byte>)&ISteamFriends_RegisterProtocolInOverlayBrowser;
        VTable.ActivateGameOverlayInviteDialogConnectString = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, void>)&ISteamFriends_ActivateGameOverlayInviteDialogConnectString;
        VTable.RequestEquippedProfileItems = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, ulong>)&ISteamFriends_RequestEquippedProfileItems;
        VTable.BHasEquippedProfileItem = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, int, byte>)&ISteamFriends_BHasEquippedProfileItem;
        VTable.GetProfileItemPropertyString = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, int, int, IntPtr>)&ISteamFriends_GetProfileItemPropertyString;
        VTable.GetProfileItemPropertyUint = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, int, int, uint>)&ISteamFriends_GetProfileItemPropertyUint;
    }

    public static IntPtr Create(ISteamFriendsLogic logic)
    {
        var handle = GCHandle.Alloc(logic);
        var ptr = Marshal.AllocHGlobal(IntPtr.Size * 2);
        *(IntPtr*)ptr = VTablePtr;
        *(IntPtr*)((byte*)ptr + IntPtr.Size) = GCHandle.ToIntPtr(handle);
        return ptr;
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static IntPtr ISteamFriends_GetPersonaName(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.GetPersonaName();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamFriends_GetPersonaState(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.GetPersonaState();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamFriends_GetFriendCount(IntPtr pThis, int iFriendFlags)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.GetFriendCount(iFriendFlags);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamFriends_GetFriendByIndex(IntPtr pThis, int iFriend, int iFriendFlags)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.GetFriendByIndex(iFriend, iFriendFlags);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamFriends_GetFriendRelationship(IntPtr pThis, ulong steamIDFriend)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.GetFriendRelationship(steamIDFriend);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamFriends_GetFriendPersonaState(IntPtr pThis, ulong steamIDFriend)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.GetFriendPersonaState(steamIDFriend);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static IntPtr ISteamFriends_GetFriendPersonaName(IntPtr pThis, ulong steamIDFriend)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.GetFriendPersonaName(steamIDFriend);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamFriends_GetFriendGamePlayed(IntPtr pThis, ulong steamIDFriend, IntPtr pFriendGameInfo)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.GetFriendGamePlayed(steamIDFriend, pFriendGameInfo);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static IntPtr ISteamFriends_GetFriendPersonaNameHistory(IntPtr pThis, ulong steamIDFriend, int iPersonaName)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.GetFriendPersonaNameHistory(steamIDFriend, iPersonaName);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamFriends_GetFriendSteamLevel(IntPtr pThis, ulong steamIDFriend)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.GetFriendSteamLevel(steamIDFriend);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static IntPtr ISteamFriends_GetPlayerNickname(IntPtr pThis, ulong steamIDPlayer)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.GetPlayerNickname(steamIDPlayer);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamFriends_GetFriendsGroupCount(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.GetFriendsGroupCount();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamFriends_GetFriendsGroupIDByIndex(IntPtr pThis, int iFG)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.GetFriendsGroupIDByIndex(iFG);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static IntPtr ISteamFriends_GetFriendsGroupName(IntPtr pThis, int friendsGroupID)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.GetFriendsGroupName(friendsGroupID);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamFriends_GetFriendsGroupMembersCount(IntPtr pThis, int friendsGroupID)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.GetFriendsGroupMembersCount(friendsGroupID);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamFriends_GetFriendsGroupMembersList(IntPtr pThis, int friendsGroupID, IntPtr pOutSteamIDMembers, int nMembersCount)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.GetFriendsGroupMembersList(friendsGroupID, pOutSteamIDMembers, nMembersCount);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamFriends_HasFriend(IntPtr pThis, ulong steamIDFriend, int iFriendFlags)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.HasFriend(steamIDFriend, iFriendFlags);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamFriends_GetClanCount(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.GetClanCount();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamFriends_GetClanByIndex(IntPtr pThis, int iClan)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.GetClanByIndex(iClan);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static IntPtr ISteamFriends_GetClanName(IntPtr pThis, ulong steamIDClan)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.GetClanName(steamIDClan);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static IntPtr ISteamFriends_GetClanTag(IntPtr pThis, ulong steamIDClan)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.GetClanTag(steamIDClan);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamFriends_GetClanActivityCounts(IntPtr pThis, ulong steamIDClan, IntPtr pnOnline, IntPtr pnInGame, IntPtr pnChatting)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.GetClanActivityCounts(steamIDClan, pnOnline, pnInGame, pnChatting);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamFriends_DownloadClanActivityCounts(IntPtr pThis, IntPtr psteamIDClans, int cClansToRequest)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.DownloadClanActivityCounts(psteamIDClans, cClansToRequest);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamFriends_GetFriendCountFromSource(IntPtr pThis, ulong steamIDSource)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.GetFriendCountFromSource(steamIDSource);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamFriends_GetFriendFromSourceByIndex(IntPtr pThis, ulong steamIDSource, int iFriend)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.GetFriendFromSourceByIndex(steamIDSource, iFriend);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamFriends_IsUserInSource(IntPtr pThis, ulong steamIDUser, ulong steamIDSource)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.IsUserInSource(steamIDUser, steamIDSource);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamFriends_SetInGameVoiceSpeaking(IntPtr pThis, ulong steamIDUser, byte bSpeaking)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.SetInGameVoiceSpeaking(steamIDUser, bSpeaking);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamFriends_ActivateGameOverlay(IntPtr pThis, IntPtr pchDialog)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.ActivateGameOverlay(pchDialog);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamFriends_ActivateGameOverlayToUser(IntPtr pThis, IntPtr pchDialog, ulong steamID)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.ActivateGameOverlayToUser(pchDialog, steamID);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamFriends_ActivateGameOverlayToWebPage(IntPtr pThis, IntPtr pchURL, int eMode)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.ActivateGameOverlayToWebPage(pchURL, eMode);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamFriends_ActivateGameOverlayToStore(IntPtr pThis, int nAppID, int eFlag)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.ActivateGameOverlayToStore(nAppID, eFlag);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamFriends_SetPlayedWith(IntPtr pThis, ulong steamIDUserPlayedWith)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.SetPlayedWith(steamIDUserPlayedWith);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamFriends_ActivateGameOverlayInviteDialog(IntPtr pThis, ulong steamIDLobby)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.ActivateGameOverlayInviteDialog(steamIDLobby);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamFriends_GetSmallFriendAvatar(IntPtr pThis, ulong steamIDFriend)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.GetSmallFriendAvatar(steamIDFriend);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamFriends_GetMediumFriendAvatar(IntPtr pThis, ulong steamIDFriend)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.GetMediumFriendAvatar(steamIDFriend);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamFriends_GetLargeFriendAvatar(IntPtr pThis, ulong steamIDFriend)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.GetLargeFriendAvatar(steamIDFriend);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamFriends_RequestUserInformation(IntPtr pThis, ulong steamIDUser, byte bRequireNameOnly)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.RequestUserInformation(steamIDUser, bRequireNameOnly);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamFriends_RequestClanOfficerList(IntPtr pThis, ulong steamIDClan)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.RequestClanOfficerList(steamIDClan);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamFriends_GetClanOwner(IntPtr pThis, ulong steamIDClan)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.GetClanOwner(steamIDClan);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamFriends_GetClanOfficerCount(IntPtr pThis, ulong steamIDClan)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.GetClanOfficerCount(steamIDClan);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamFriends_GetClanOfficerByIndex(IntPtr pThis, ulong steamIDClan, int iOfficer)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.GetClanOfficerByIndex(steamIDClan, iOfficer);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamFriends_SetRichPresence(IntPtr pThis, IntPtr pchKey, IntPtr pchValue)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.SetRichPresence(pchKey, pchValue);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamFriends_ClearRichPresence(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.ClearRichPresence();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static IntPtr ISteamFriends_GetFriendRichPresence(IntPtr pThis, ulong steamIDFriend, IntPtr pchKey)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.GetFriendRichPresence(steamIDFriend, pchKey);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamFriends_GetFriendRichPresenceKeyCount(IntPtr pThis, ulong steamIDFriend)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.GetFriendRichPresenceKeyCount(steamIDFriend);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static IntPtr ISteamFriends_GetFriendRichPresenceKeyByIndex(IntPtr pThis, ulong steamIDFriend, int iKey)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.GetFriendRichPresenceKeyByIndex(steamIDFriend, iKey);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamFriends_RequestFriendRichPresence(IntPtr pThis, ulong steamIDFriend)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.RequestFriendRichPresence(steamIDFriend);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamFriends_InviteUserToGame(IntPtr pThis, ulong steamIDFriend, IntPtr pchConnectString)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.InviteUserToGame(steamIDFriend, pchConnectString);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamFriends_GetCoplayFriendCount(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.GetCoplayFriendCount();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamFriends_GetCoplayFriend(IntPtr pThis, int iCoplayFriend)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.GetCoplayFriend(iCoplayFriend);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamFriends_GetFriendCoplayTime(IntPtr pThis, ulong steamIDFriend)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.GetFriendCoplayTime(steamIDFriend);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamFriends_GetFriendCoplayGame(IntPtr pThis, ulong steamIDFriend)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.GetFriendCoplayGame(steamIDFriend);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamFriends_JoinClanChatRoom(IntPtr pThis, ulong steamIDClan)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.JoinClanChatRoom(steamIDClan);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamFriends_LeaveClanChatRoom(IntPtr pThis, ulong steamIDClan)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.LeaveClanChatRoom(steamIDClan);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamFriends_GetClanChatMemberCount(IntPtr pThis, ulong steamIDClan)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.GetClanChatMemberCount(steamIDClan);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamFriends_GetChatMemberByIndex(IntPtr pThis, ulong steamIDClan, int iUser)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.GetChatMemberByIndex(steamIDClan, iUser);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamFriends_SendClanChatMessage(IntPtr pThis, ulong steamIDClanChat, IntPtr pchText)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.SendClanChatMessage(steamIDClanChat, pchText);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamFriends_GetClanChatMessage(IntPtr pThis, ulong steamIDClanChat, int iMessage, IntPtr prgchText, int cchTextMax, IntPtr peChatEntryType, IntPtr psteamidChatter)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.GetClanChatMessage(steamIDClanChat, iMessage, prgchText, cchTextMax, peChatEntryType, psteamidChatter);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamFriends_IsClanChatAdmin(IntPtr pThis, ulong steamIDClanChat, ulong steamIDUser)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.IsClanChatAdmin(steamIDClanChat, steamIDUser);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamFriends_IsClanChatWindowOpenInSteam(IntPtr pThis, ulong steamIDClanChat)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.IsClanChatWindowOpenInSteam(steamIDClanChat);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamFriends_OpenClanChatWindowInSteam(IntPtr pThis, ulong steamIDClanChat)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.OpenClanChatWindowInSteam(steamIDClanChat);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamFriends_CloseClanChatWindowInSteam(IntPtr pThis, ulong steamIDClanChat)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.CloseClanChatWindowInSteam(steamIDClanChat);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamFriends_SetListenForFriendsMessages(IntPtr pThis, byte bInterceptEnabled)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.SetListenForFriendsMessages(bInterceptEnabled);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamFriends_ReplyToFriendMessage(IntPtr pThis, ulong steamIDFriend, IntPtr pchMsgToSend)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.ReplyToFriendMessage(steamIDFriend, pchMsgToSend);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamFriends_GetFriendMessage(IntPtr pThis, ulong steamIDFriend, int iMessageID, IntPtr pvData, int cubData, IntPtr peChatEntryType)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.GetFriendMessage(steamIDFriend, iMessageID, pvData, cubData, peChatEntryType);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamFriends_GetFollowerCount(IntPtr pThis, ulong steamID)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.GetFollowerCount(steamID);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamFriends_IsFollowing(IntPtr pThis, ulong steamID)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.IsFollowing(steamID);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamFriends_EnumerateFollowingList(IntPtr pThis, uint unStartIndex)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.EnumerateFollowingList(unStartIndex);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamFriends_IsClanPublic(IntPtr pThis, ulong steamIDClan)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.IsClanPublic(steamIDClan);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamFriends_IsClanOfficialGameGroup(IntPtr pThis, ulong steamIDClan)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.IsClanOfficialGameGroup(steamIDClan);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamFriends_GetNumChatsWithUnreadPriorityMessages(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.GetNumChatsWithUnreadPriorityMessages();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamFriends_ActivateGameOverlayRemotePlayTogetherInviteDialog(IntPtr pThis, ulong steamIDLobby)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.ActivateGameOverlayRemotePlayTogetherInviteDialog(steamIDLobby);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamFriends_RegisterProtocolInOverlayBrowser(IntPtr pThis, IntPtr pchProtocol)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.RegisterProtocolInOverlayBrowser(pchProtocol);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamFriends_ActivateGameOverlayInviteDialogConnectString(IntPtr pThis, IntPtr pchConnectString)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.ActivateGameOverlayInviteDialogConnectString(pchConnectString);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamFriends_RequestEquippedProfileItems(IntPtr pThis, ulong steamID)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.RequestEquippedProfileItems(steamID);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamFriends_BHasEquippedProfileItem(IntPtr pThis, ulong steamID, int itemType)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.BHasEquippedProfileItem(steamID, itemType);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static IntPtr ISteamFriends_GetProfileItemPropertyString(IntPtr pThis, ulong steamID, int itemType, int prop)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.GetProfileItemPropertyString(steamID, itemType, prop);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static uint ISteamFriends_GetProfileItemPropertyUint(IntPtr pThis, ulong steamID, int itemType, int prop)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamFriendsLogic)handle.Target!;
        return logic.GetProfileItemPropertyUint(steamID, itemType, prop);
    }
}

public unsafe class ISteamUtilsShim
{
    public static ISteamUtilsVTable VTable;
    public static IntPtr VTablePtr;

    static ISteamUtilsShim()
    {
        VTablePtr = (IntPtr)Unsafe.AsPointer(ref VTable);
        VTable.GetSecondsSinceAppActive = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint>)&ISteamUtils_GetSecondsSinceAppActive;
        VTable.GetSecondsSinceComputerActive = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint>)&ISteamUtils_GetSecondsSinceComputerActive;
        VTable.GetConnectedUniverse = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int>)&ISteamUtils_GetConnectedUniverse;
        VTable.GetServerRealTime = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint>)&ISteamUtils_GetServerRealTime;
        VTable.GetIPCountry = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr>)&ISteamUtils_GetIPCountry;
        VTable.GetImageSize = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, IntPtr, byte>)&ISteamUtils_GetImageSize;
        VTable.GetImageRGBA = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, int, byte>)&ISteamUtils_GetImageRGBA;
        VTable.GetCurrentBatteryPower = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int>)&ISteamUtils_GetCurrentBatteryPower;
        VTable.GetAppID = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint>)&ISteamUtils_GetAppID;
        VTable.SetOverlayNotificationPosition = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, void>)&ISteamUtils_SetOverlayNotificationPosition;
        VTable.IsAPICallCompleted = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, IntPtr, byte>)&ISteamUtils_IsAPICallCompleted;
        VTable.GetAPICallFailureReason = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, int>)&ISteamUtils_GetAPICallFailureReason;
        VTable.GetAPICallResult = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, IntPtr, int, int, IntPtr, byte>)&ISteamUtils_GetAPICallResult;
        VTable.GetIPCCallCount = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint>)&ISteamUtils_GetIPCCallCount;
        VTable.SetWarningMessageHook = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, void>)&ISteamUtils_SetWarningMessageHook;
        VTable.IsOverlayEnabled = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, byte>)&ISteamUtils_IsOverlayEnabled;
        VTable.BOverlayNeedsPresent = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, byte>)&ISteamUtils_BOverlayNeedsPresent;
        VTable.CheckFileSignature = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, ulong>)&ISteamUtils_CheckFileSignature;
        VTable.ShowGamepadTextInput = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, IntPtr, uint, IntPtr, byte>)&ISteamUtils_ShowGamepadTextInput;
        VTable.GetEnteredGamepadTextLength = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint>)&ISteamUtils_GetEnteredGamepadTextLength;
        VTable.GetEnteredGamepadTextInput = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, uint, byte>)&ISteamUtils_GetEnteredGamepadTextInput;
        VTable.GetSteamUILanguage = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr>)&ISteamUtils_GetSteamUILanguage;
        VTable.IsSteamRunningInVR = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, byte>)&ISteamUtils_IsSteamRunningInVR;
        VTable.SetOverlayNotificationInset = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, void>)&ISteamUtils_SetOverlayNotificationInset;
        VTable.IsSteamInBigPictureMode = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, byte>)&ISteamUtils_IsSteamInBigPictureMode;
        VTable.StartVRDashboard = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, void>)&ISteamUtils_StartVRDashboard;
        VTable.IsVRHeadsetStreamingEnabled = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, byte>)&ISteamUtils_IsVRHeadsetStreamingEnabled;
        VTable.SetVRHeadsetStreamingEnabled = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, byte, void>)&ISteamUtils_SetVRHeadsetStreamingEnabled;
        VTable.IsSteamChinaLauncher = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, byte>)&ISteamUtils_IsSteamChinaLauncher;
        VTable.InitFilterText = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, byte>)&ISteamUtils_InitFilterText;
        VTable.FilterText = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, ulong, IntPtr, IntPtr, uint, int>)&ISteamUtils_FilterText;
        VTable.GetIPv6ConnectivityState = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int>)&ISteamUtils_GetIPv6ConnectivityState;
        VTable.IsSteamRunningOnSteamDeck = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, byte>)&ISteamUtils_IsSteamRunningOnSteamDeck;
        VTable.ShowFloatingGamepadTextInput = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, int, int, int, byte>)&ISteamUtils_ShowFloatingGamepadTextInput;
        VTable.SetGameLauncherMode = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, byte, void>)&ISteamUtils_SetGameLauncherMode;
        VTable.DismissFloatingGamepadTextInput = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, byte>)&ISteamUtils_DismissFloatingGamepadTextInput;
        VTable.DismissGamepadTextInput = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, byte>)&ISteamUtils_DismissGamepadTextInput;
    }

    public static IntPtr Create(ISteamUtilsLogic logic)
    {
        var handle = GCHandle.Alloc(logic);
        var ptr = Marshal.AllocHGlobal(IntPtr.Size * 2);
        *(IntPtr*)ptr = VTablePtr;
        *(IntPtr*)((byte*)ptr + IntPtr.Size) = GCHandle.ToIntPtr(handle);
        return ptr;
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static uint ISteamUtils_GetSecondsSinceAppActive(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUtilsLogic)handle.Target!;
        return logic.GetSecondsSinceAppActive();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static uint ISteamUtils_GetSecondsSinceComputerActive(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUtilsLogic)handle.Target!;
        return logic.GetSecondsSinceComputerActive();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamUtils_GetConnectedUniverse(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUtilsLogic)handle.Target!;
        return logic.GetConnectedUniverse();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static uint ISteamUtils_GetServerRealTime(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUtilsLogic)handle.Target!;
        return logic.GetServerRealTime();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static IntPtr ISteamUtils_GetIPCountry(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUtilsLogic)handle.Target!;
        return logic.GetIPCountry();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUtils_GetImageSize(IntPtr pThis, int iImage, IntPtr pnWidth, IntPtr pnHeight)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUtilsLogic)handle.Target!;
        return logic.GetImageSize(iImage, pnWidth, pnHeight);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUtils_GetImageRGBA(IntPtr pThis, int iImage, IntPtr pubDest, int nDestBufferSize)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUtilsLogic)handle.Target!;
        return logic.GetImageRGBA(iImage, pubDest, nDestBufferSize);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamUtils_GetCurrentBatteryPower(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUtilsLogic)handle.Target!;
        return logic.GetCurrentBatteryPower();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static uint ISteamUtils_GetAppID(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUtilsLogic)handle.Target!;
        return logic.GetAppID();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamUtils_SetOverlayNotificationPosition(IntPtr pThis, int eNotificationPosition)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUtilsLogic)handle.Target!;
        return logic.SetOverlayNotificationPosition(eNotificationPosition);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUtils_IsAPICallCompleted(IntPtr pThis, ulong hSteamAPICall, IntPtr pbFailed)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUtilsLogic)handle.Target!;
        return logic.IsAPICallCompleted(hSteamAPICall, pbFailed);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamUtils_GetAPICallFailureReason(IntPtr pThis, ulong hSteamAPICall)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUtilsLogic)handle.Target!;
        return logic.GetAPICallFailureReason(hSteamAPICall);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUtils_GetAPICallResult(IntPtr pThis, ulong hSteamAPICall, IntPtr pCallback, int cubCallback, int iCallbackExpected, IntPtr pbFailed)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUtilsLogic)handle.Target!;
        return logic.GetAPICallResult(hSteamAPICall, pCallback, cubCallback, iCallbackExpected, pbFailed);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static uint ISteamUtils_GetIPCCallCount(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUtilsLogic)handle.Target!;
        return logic.GetIPCCallCount();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamUtils_SetWarningMessageHook(IntPtr pThis, int pFunction)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUtilsLogic)handle.Target!;
        return logic.SetWarningMessageHook(pFunction);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUtils_IsOverlayEnabled(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUtilsLogic)handle.Target!;
        return logic.IsOverlayEnabled();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUtils_BOverlayNeedsPresent(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUtilsLogic)handle.Target!;
        return logic.BOverlayNeedsPresent();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamUtils_CheckFileSignature(IntPtr pThis, IntPtr szFileName)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUtilsLogic)handle.Target!;
        return logic.CheckFileSignature(szFileName);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUtils_ShowGamepadTextInput(IntPtr pThis, int eInputMode, int eLineInputMode, IntPtr pchDescription, uint unCharMax, IntPtr pchExistingText)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUtilsLogic)handle.Target!;
        return logic.ShowGamepadTextInput(eInputMode, eLineInputMode, pchDescription, unCharMax, pchExistingText);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static uint ISteamUtils_GetEnteredGamepadTextLength(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUtilsLogic)handle.Target!;
        return logic.GetEnteredGamepadTextLength();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUtils_GetEnteredGamepadTextInput(IntPtr pThis, IntPtr pchText, uint cchText)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUtilsLogic)handle.Target!;
        return logic.GetEnteredGamepadTextInput(pchText, cchText);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static IntPtr ISteamUtils_GetSteamUILanguage(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUtilsLogic)handle.Target!;
        return logic.GetSteamUILanguage();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUtils_IsSteamRunningInVR(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUtilsLogic)handle.Target!;
        return logic.IsSteamRunningInVR();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamUtils_SetOverlayNotificationInset(IntPtr pThis, int nHorizontalInset, int nVerticalInset)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUtilsLogic)handle.Target!;
        return logic.SetOverlayNotificationInset(nHorizontalInset, nVerticalInset);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUtils_IsSteamInBigPictureMode(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUtilsLogic)handle.Target!;
        return logic.IsSteamInBigPictureMode();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamUtils_StartVRDashboard(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUtilsLogic)handle.Target!;
        return logic.StartVRDashboard();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUtils_IsVRHeadsetStreamingEnabled(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUtilsLogic)handle.Target!;
        return logic.IsVRHeadsetStreamingEnabled();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamUtils_SetVRHeadsetStreamingEnabled(IntPtr pThis, byte bEnabled)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUtilsLogic)handle.Target!;
        return logic.SetVRHeadsetStreamingEnabled(bEnabled);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUtils_IsSteamChinaLauncher(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUtilsLogic)handle.Target!;
        return logic.IsSteamChinaLauncher();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUtils_InitFilterText(IntPtr pThis, uint unFilterOptions)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUtilsLogic)handle.Target!;
        return logic.InitFilterText(unFilterOptions);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamUtils_FilterText(IntPtr pThis, int eContext, ulong sourceSteamID, IntPtr pchInputMessage, IntPtr pchOutFilteredText, uint nByteSizeOutFilteredText)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUtilsLogic)handle.Target!;
        return logic.FilterText(eContext, sourceSteamID, pchInputMessage, pchOutFilteredText, nByteSizeOutFilteredText);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamUtils_GetIPv6ConnectivityState(IntPtr pThis, int eProtocol)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUtilsLogic)handle.Target!;
        return logic.GetIPv6ConnectivityState(eProtocol);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUtils_IsSteamRunningOnSteamDeck(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUtilsLogic)handle.Target!;
        return logic.IsSteamRunningOnSteamDeck();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUtils_ShowFloatingGamepadTextInput(IntPtr pThis, int eKeyboardMode, int nTextFieldXPosition, int nTextFieldYPosition, int nTextFieldWidth, int nTextFieldHeight)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUtilsLogic)handle.Target!;
        return logic.ShowFloatingGamepadTextInput(eKeyboardMode, nTextFieldXPosition, nTextFieldYPosition, nTextFieldWidth, nTextFieldHeight);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamUtils_SetGameLauncherMode(IntPtr pThis, byte bLauncherMode)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUtilsLogic)handle.Target!;
        return logic.SetGameLauncherMode(bLauncherMode);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUtils_DismissFloatingGamepadTextInput(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUtilsLogic)handle.Target!;
        return logic.DismissFloatingGamepadTextInput();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUtils_DismissGamepadTextInput(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUtilsLogic)handle.Target!;
        return logic.DismissGamepadTextInput();
    }
}

public unsafe class ISteamMatchmakingShim
{
    public static ISteamMatchmakingVTable VTable;
    public static IntPtr VTablePtr;

    static ISteamMatchmakingShim()
    {
        VTablePtr = (IntPtr)Unsafe.AsPointer(ref VTable);
        VTable.GetFavoriteGameCount = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int>)&ISteamMatchmaking_GetFavoriteGameCount;
        VTable.GetFavoriteGame = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, IntPtr, IntPtr, IntPtr, IntPtr, IntPtr, byte>)&ISteamMatchmaking_GetFavoriteGame;
        VTable.AddFavoriteGame = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, uint, int, int, uint, uint, int>)&ISteamMatchmaking_AddFavoriteGame;
        VTable.RemoveFavoriteGame = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, uint, int, int, uint, byte>)&ISteamMatchmaking_RemoveFavoriteGame;
        VTable.RequestLobbyList = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong>)&ISteamMatchmaking_RequestLobbyList;
        VTable.AddRequestLobbyListStringFilter = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, IntPtr, int, void>)&ISteamMatchmaking_AddRequestLobbyListStringFilter;
        VTable.AddRequestLobbyListNumericalFilter = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, int, int, void>)&ISteamMatchmaking_AddRequestLobbyListNumericalFilter;
        VTable.AddRequestLobbyListNearValueFilter = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, int, void>)&ISteamMatchmaking_AddRequestLobbyListNearValueFilter;
        VTable.AddRequestLobbyListFilterSlotsAvailable = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, void>)&ISteamMatchmaking_AddRequestLobbyListFilterSlotsAvailable;
        VTable.AddRequestLobbyListDistanceFilter = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, void>)&ISteamMatchmaking_AddRequestLobbyListDistanceFilter;
        VTable.AddRequestLobbyListResultCountFilter = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, void>)&ISteamMatchmaking_AddRequestLobbyListResultCountFilter;
        VTable.AddRequestLobbyListCompatibleMembersFilter = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, void>)&ISteamMatchmaking_AddRequestLobbyListCompatibleMembersFilter;
        VTable.GetLobbyByIndex = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, ulong>)&ISteamMatchmaking_GetLobbyByIndex;
        VTable.CreateLobby = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, ulong>)&ISteamMatchmaking_CreateLobby;
        VTable.JoinLobby = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, ulong>)&ISteamMatchmaking_JoinLobby;
        VTable.LeaveLobby = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, void>)&ISteamMatchmaking_LeaveLobby;
        VTable.InviteUserToLobby = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, ulong, byte>)&ISteamMatchmaking_InviteUserToLobby;
        VTable.GetNumLobbyMembers = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, int>)&ISteamMatchmaking_GetNumLobbyMembers;
        VTable.GetLobbyMemberByIndex = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, int, ulong>)&ISteamMatchmaking_GetLobbyMemberByIndex;
        VTable.GetLobbyData = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, IntPtr, IntPtr>)&ISteamMatchmaking_GetLobbyData;
        VTable.SetLobbyData = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, IntPtr, IntPtr, byte>)&ISteamMatchmaking_SetLobbyData;
        VTable.GetLobbyDataCount = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, int>)&ISteamMatchmaking_GetLobbyDataCount;
        VTable.GetLobbyDataByIndex = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, int, IntPtr, int, IntPtr, int, byte>)&ISteamMatchmaking_GetLobbyDataByIndex;
        VTable.DeleteLobbyData = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, IntPtr, byte>)&ISteamMatchmaking_DeleteLobbyData;
        VTable.GetLobbyMemberData = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, ulong, IntPtr, IntPtr>)&ISteamMatchmaking_GetLobbyMemberData;
        VTable.SetLobbyMemberData = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, IntPtr, IntPtr, void>)&ISteamMatchmaking_SetLobbyMemberData;
        VTable.SendLobbyChatMsg = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, IntPtr, int, byte>)&ISteamMatchmaking_SendLobbyChatMsg;
        VTable.GetLobbyChatEntry = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, int, IntPtr, IntPtr, int, IntPtr, int>)&ISteamMatchmaking_GetLobbyChatEntry;
        VTable.RequestLobbyData = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, byte>)&ISteamMatchmaking_RequestLobbyData;
        VTable.SetLobbyGameServer = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, uint, int, ulong, void>)&ISteamMatchmaking_SetLobbyGameServer;
        VTable.GetLobbyGameServer = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, IntPtr, IntPtr, IntPtr, byte>)&ISteamMatchmaking_GetLobbyGameServer;
        VTable.SetLobbyMemberLimit = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, int, byte>)&ISteamMatchmaking_SetLobbyMemberLimit;
        VTable.GetLobbyMemberLimit = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, int>)&ISteamMatchmaking_GetLobbyMemberLimit;
        VTable.SetLobbyType = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, int, byte>)&ISteamMatchmaking_SetLobbyType;
        VTable.SetLobbyJoinable = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, byte, byte>)&ISteamMatchmaking_SetLobbyJoinable;
        VTable.GetLobbyOwner = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, ulong>)&ISteamMatchmaking_GetLobbyOwner;
        VTable.SetLobbyOwner = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, ulong, byte>)&ISteamMatchmaking_SetLobbyOwner;
        VTable.SetLinkedLobby = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, ulong, byte>)&ISteamMatchmaking_SetLinkedLobby;
    }

    public static IntPtr Create(ISteamMatchmakingLogic logic)
    {
        var handle = GCHandle.Alloc(logic);
        var ptr = Marshal.AllocHGlobal(IntPtr.Size * 2);
        *(IntPtr*)ptr = VTablePtr;
        *(IntPtr*)((byte*)ptr + IntPtr.Size) = GCHandle.ToIntPtr(handle);
        return ptr;
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamMatchmaking_GetFavoriteGameCount(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamMatchmakingLogic)handle.Target!;
        return logic.GetFavoriteGameCount();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamMatchmaking_GetFavoriteGame(IntPtr pThis, int iGame, IntPtr pnAppID, IntPtr pnIP, IntPtr pnConnPort, IntPtr pnQueryPort, IntPtr punFlags, IntPtr pRTime32LastPlayedOnServer)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamMatchmakingLogic)handle.Target!;
        return logic.GetFavoriteGame(iGame, pnAppID, pnIP, pnConnPort, pnQueryPort, punFlags, pRTime32LastPlayedOnServer);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamMatchmaking_AddFavoriteGame(IntPtr pThis, int nAppID, uint nIP, int nConnPort, int nQueryPort, uint unFlags, uint rTime32LastPlayedOnServer)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamMatchmakingLogic)handle.Target!;
        return logic.AddFavoriteGame(nAppID, nIP, nConnPort, nQueryPort, unFlags, rTime32LastPlayedOnServer);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamMatchmaking_RemoveFavoriteGame(IntPtr pThis, int nAppID, uint nIP, int nConnPort, int nQueryPort, uint unFlags)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamMatchmakingLogic)handle.Target!;
        return logic.RemoveFavoriteGame(nAppID, nIP, nConnPort, nQueryPort, unFlags);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamMatchmaking_RequestLobbyList(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamMatchmakingLogic)handle.Target!;
        return logic.RequestLobbyList();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamMatchmaking_AddRequestLobbyListStringFilter(IntPtr pThis, IntPtr pchKeyToMatch, IntPtr pchValueToMatch, int eComparisonType)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamMatchmakingLogic)handle.Target!;
        return logic.AddRequestLobbyListStringFilter(pchKeyToMatch, pchValueToMatch, eComparisonType);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamMatchmaking_AddRequestLobbyListNumericalFilter(IntPtr pThis, IntPtr pchKeyToMatch, int nValueToMatch, int eComparisonType)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamMatchmakingLogic)handle.Target!;
        return logic.AddRequestLobbyListNumericalFilter(pchKeyToMatch, nValueToMatch, eComparisonType);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamMatchmaking_AddRequestLobbyListNearValueFilter(IntPtr pThis, IntPtr pchKeyToMatch, int nValueToBeCloseTo)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamMatchmakingLogic)handle.Target!;
        return logic.AddRequestLobbyListNearValueFilter(pchKeyToMatch, nValueToBeCloseTo);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamMatchmaking_AddRequestLobbyListFilterSlotsAvailable(IntPtr pThis, int nSlotsAvailable)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamMatchmakingLogic)handle.Target!;
        return logic.AddRequestLobbyListFilterSlotsAvailable(nSlotsAvailable);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamMatchmaking_AddRequestLobbyListDistanceFilter(IntPtr pThis, int eLobbyDistanceFilter)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamMatchmakingLogic)handle.Target!;
        return logic.AddRequestLobbyListDistanceFilter(eLobbyDistanceFilter);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamMatchmaking_AddRequestLobbyListResultCountFilter(IntPtr pThis, int cMaxResults)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamMatchmakingLogic)handle.Target!;
        return logic.AddRequestLobbyListResultCountFilter(cMaxResults);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamMatchmaking_AddRequestLobbyListCompatibleMembersFilter(IntPtr pThis, ulong steamIDLobby)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamMatchmakingLogic)handle.Target!;
        return logic.AddRequestLobbyListCompatibleMembersFilter(steamIDLobby);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamMatchmaking_GetLobbyByIndex(IntPtr pThis, int iLobby)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamMatchmakingLogic)handle.Target!;
        return logic.GetLobbyByIndex(iLobby);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamMatchmaking_CreateLobby(IntPtr pThis, int eLobbyType, int cMaxMembers)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamMatchmakingLogic)handle.Target!;
        return logic.CreateLobby(eLobbyType, cMaxMembers);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamMatchmaking_JoinLobby(IntPtr pThis, ulong steamIDLobby)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamMatchmakingLogic)handle.Target!;
        return logic.JoinLobby(steamIDLobby);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamMatchmaking_LeaveLobby(IntPtr pThis, ulong steamIDLobby)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamMatchmakingLogic)handle.Target!;
        return logic.LeaveLobby(steamIDLobby);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamMatchmaking_InviteUserToLobby(IntPtr pThis, ulong steamIDLobby, ulong steamIDInvitee)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamMatchmakingLogic)handle.Target!;
        return logic.InviteUserToLobby(steamIDLobby, steamIDInvitee);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamMatchmaking_GetNumLobbyMembers(IntPtr pThis, ulong steamIDLobby)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamMatchmakingLogic)handle.Target!;
        return logic.GetNumLobbyMembers(steamIDLobby);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamMatchmaking_GetLobbyMemberByIndex(IntPtr pThis, ulong steamIDLobby, int iMember)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamMatchmakingLogic)handle.Target!;
        return logic.GetLobbyMemberByIndex(steamIDLobby, iMember);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static IntPtr ISteamMatchmaking_GetLobbyData(IntPtr pThis, ulong steamIDLobby, IntPtr pchKey)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamMatchmakingLogic)handle.Target!;
        return logic.GetLobbyData(steamIDLobby, pchKey);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamMatchmaking_SetLobbyData(IntPtr pThis, ulong steamIDLobby, IntPtr pchKey, IntPtr pchValue)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamMatchmakingLogic)handle.Target!;
        return logic.SetLobbyData(steamIDLobby, pchKey, pchValue);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamMatchmaking_GetLobbyDataCount(IntPtr pThis, ulong steamIDLobby)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamMatchmakingLogic)handle.Target!;
        return logic.GetLobbyDataCount(steamIDLobby);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamMatchmaking_GetLobbyDataByIndex(IntPtr pThis, ulong steamIDLobby, int iLobbyData, IntPtr pchKey, int cchKeyBufferSize, IntPtr pchValue, int cchValueBufferSize)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamMatchmakingLogic)handle.Target!;
        return logic.GetLobbyDataByIndex(steamIDLobby, iLobbyData, pchKey, cchKeyBufferSize, pchValue, cchValueBufferSize);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamMatchmaking_DeleteLobbyData(IntPtr pThis, ulong steamIDLobby, IntPtr pchKey)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamMatchmakingLogic)handle.Target!;
        return logic.DeleteLobbyData(steamIDLobby, pchKey);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static IntPtr ISteamMatchmaking_GetLobbyMemberData(IntPtr pThis, ulong steamIDLobby, ulong steamIDUser, IntPtr pchKey)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamMatchmakingLogic)handle.Target!;
        return logic.GetLobbyMemberData(steamIDLobby, steamIDUser, pchKey);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamMatchmaking_SetLobbyMemberData(IntPtr pThis, ulong steamIDLobby, IntPtr pchKey, IntPtr pchValue)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamMatchmakingLogic)handle.Target!;
        return logic.SetLobbyMemberData(steamIDLobby, pchKey, pchValue);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamMatchmaking_SendLobbyChatMsg(IntPtr pThis, ulong steamIDLobby, IntPtr pvMsgBody, int cubMsgBody)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamMatchmakingLogic)handle.Target!;
        return logic.SendLobbyChatMsg(steamIDLobby, pvMsgBody, cubMsgBody);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamMatchmaking_GetLobbyChatEntry(IntPtr pThis, ulong steamIDLobby, int iChatID, IntPtr pSteamIDUser, IntPtr pvData, int cubData, IntPtr peChatEntryType)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamMatchmakingLogic)handle.Target!;
        return logic.GetLobbyChatEntry(steamIDLobby, iChatID, pSteamIDUser, pvData, cubData, peChatEntryType);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamMatchmaking_RequestLobbyData(IntPtr pThis, ulong steamIDLobby)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamMatchmakingLogic)handle.Target!;
        return logic.RequestLobbyData(steamIDLobby);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamMatchmaking_SetLobbyGameServer(IntPtr pThis, ulong steamIDLobby, uint unGameServerIP, int unGameServerPort, ulong steamIDGameServer)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamMatchmakingLogic)handle.Target!;
        return logic.SetLobbyGameServer(steamIDLobby, unGameServerIP, unGameServerPort, steamIDGameServer);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamMatchmaking_GetLobbyGameServer(IntPtr pThis, ulong steamIDLobby, IntPtr punGameServerIP, IntPtr punGameServerPort, IntPtr psteamIDGameServer)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamMatchmakingLogic)handle.Target!;
        return logic.GetLobbyGameServer(steamIDLobby, punGameServerIP, punGameServerPort, psteamIDGameServer);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamMatchmaking_SetLobbyMemberLimit(IntPtr pThis, ulong steamIDLobby, int cMaxMembers)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamMatchmakingLogic)handle.Target!;
        return logic.SetLobbyMemberLimit(steamIDLobby, cMaxMembers);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamMatchmaking_GetLobbyMemberLimit(IntPtr pThis, ulong steamIDLobby)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamMatchmakingLogic)handle.Target!;
        return logic.GetLobbyMemberLimit(steamIDLobby);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamMatchmaking_SetLobbyType(IntPtr pThis, ulong steamIDLobby, int eLobbyType)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamMatchmakingLogic)handle.Target!;
        return logic.SetLobbyType(steamIDLobby, eLobbyType);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamMatchmaking_SetLobbyJoinable(IntPtr pThis, ulong steamIDLobby, byte bLobbyJoinable)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamMatchmakingLogic)handle.Target!;
        return logic.SetLobbyJoinable(steamIDLobby, bLobbyJoinable);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamMatchmaking_GetLobbyOwner(IntPtr pThis, ulong steamIDLobby)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamMatchmakingLogic)handle.Target!;
        return logic.GetLobbyOwner(steamIDLobby);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamMatchmaking_SetLobbyOwner(IntPtr pThis, ulong steamIDLobby, ulong steamIDNewOwner)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamMatchmakingLogic)handle.Target!;
        return logic.SetLobbyOwner(steamIDLobby, steamIDNewOwner);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamMatchmaking_SetLinkedLobby(IntPtr pThis, ulong steamIDLobby, ulong steamIDLobbyDependent)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamMatchmakingLogic)handle.Target!;
        return logic.SetLinkedLobby(steamIDLobby, steamIDLobbyDependent);
    }
}

public unsafe class ISteamMatchmakingServerListResponseShim
{
    public static ISteamMatchmakingServerListResponseVTable VTable;
    public static IntPtr VTablePtr;

    static ISteamMatchmakingServerListResponseShim()
    {
        VTablePtr = (IntPtr)Unsafe.AsPointer(ref VTable);
        VTable.ServerResponded = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, int, void>)&ISteamMatchmakingServerListResponse_ServerResponded;
        VTable.ServerFailedToRespond = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, int, void>)&ISteamMatchmakingServerListResponse_ServerFailedToRespond;
        VTable.RefreshComplete = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, int, void>)&ISteamMatchmakingServerListResponse_RefreshComplete;
    }

    public static IntPtr Create(ISteamMatchmakingServerListResponseLogic logic)
    {
        var handle = GCHandle.Alloc(logic);
        var ptr = Marshal.AllocHGlobal(IntPtr.Size * 2);
        *(IntPtr*)ptr = VTablePtr;
        *(IntPtr*)((byte*)ptr + IntPtr.Size) = GCHandle.ToIntPtr(handle);
        return ptr;
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamMatchmakingServerListResponse_ServerResponded(IntPtr pThis, uint hRequest, int iServer)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamMatchmakingServerListResponseLogic)handle.Target!;
        return logic.ServerResponded(hRequest, iServer);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamMatchmakingServerListResponse_ServerFailedToRespond(IntPtr pThis, uint hRequest, int iServer)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamMatchmakingServerListResponseLogic)handle.Target!;
        return logic.ServerFailedToRespond(hRequest, iServer);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamMatchmakingServerListResponse_RefreshComplete(IntPtr pThis, uint hRequest, int response)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamMatchmakingServerListResponseLogic)handle.Target!;
        return logic.RefreshComplete(hRequest, response);
    }
}

public unsafe class ISteamMatchmakingPingResponseShim
{
    public static ISteamMatchmakingPingResponseVTable VTable;
    public static IntPtr VTablePtr;

    static ISteamMatchmakingPingResponseShim()
    {
        VTablePtr = (IntPtr)Unsafe.AsPointer(ref VTable);
        VTable.ServerResponded = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, void>)&ISteamMatchmakingPingResponse_ServerResponded;
        VTable.ServerFailedToRespond = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, void>)&ISteamMatchmakingPingResponse_ServerFailedToRespond;
    }

    public static IntPtr Create(ISteamMatchmakingPingResponseLogic logic)
    {
        var handle = GCHandle.Alloc(logic);
        var ptr = Marshal.AllocHGlobal(IntPtr.Size * 2);
        *(IntPtr*)ptr = VTablePtr;
        *(IntPtr*)((byte*)ptr + IntPtr.Size) = GCHandle.ToIntPtr(handle);
        return ptr;
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamMatchmakingPingResponse_ServerResponded(IntPtr pThis, int server)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamMatchmakingPingResponseLogic)handle.Target!;
        return logic.ServerResponded(server);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamMatchmakingPingResponse_ServerFailedToRespond(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamMatchmakingPingResponseLogic)handle.Target!;
        return logic.ServerFailedToRespond();
    }
}

public unsafe class ISteamMatchmakingPlayersResponseShim
{
    public static ISteamMatchmakingPlayersResponseVTable VTable;
    public static IntPtr VTablePtr;

    static ISteamMatchmakingPlayersResponseShim()
    {
        VTablePtr = (IntPtr)Unsafe.AsPointer(ref VTable);
        VTable.AddPlayerToList = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, int, int, void>)&ISteamMatchmakingPlayersResponse_AddPlayerToList;
        VTable.PlayersFailedToRespond = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, void>)&ISteamMatchmakingPlayersResponse_PlayersFailedToRespond;
        VTable.PlayersRefreshComplete = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, void>)&ISteamMatchmakingPlayersResponse_PlayersRefreshComplete;
    }

    public static IntPtr Create(ISteamMatchmakingPlayersResponseLogic logic)
    {
        var handle = GCHandle.Alloc(logic);
        var ptr = Marshal.AllocHGlobal(IntPtr.Size * 2);
        *(IntPtr*)ptr = VTablePtr;
        *(IntPtr*)((byte*)ptr + IntPtr.Size) = GCHandle.ToIntPtr(handle);
        return ptr;
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamMatchmakingPlayersResponse_AddPlayerToList(IntPtr pThis, IntPtr pchName, int nScore, int flTimePlayed)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamMatchmakingPlayersResponseLogic)handle.Target!;
        return logic.AddPlayerToList(pchName, nScore, flTimePlayed);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamMatchmakingPlayersResponse_PlayersFailedToRespond(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamMatchmakingPlayersResponseLogic)handle.Target!;
        return logic.PlayersFailedToRespond();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamMatchmakingPlayersResponse_PlayersRefreshComplete(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamMatchmakingPlayersResponseLogic)handle.Target!;
        return logic.PlayersRefreshComplete();
    }
}

public unsafe class ISteamMatchmakingRulesResponseShim
{
    public static ISteamMatchmakingRulesResponseVTable VTable;
    public static IntPtr VTablePtr;

    static ISteamMatchmakingRulesResponseShim()
    {
        VTablePtr = (IntPtr)Unsafe.AsPointer(ref VTable);
        VTable.RulesResponded = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, IntPtr, void>)&ISteamMatchmakingRulesResponse_RulesResponded;
        VTable.RulesFailedToRespond = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, void>)&ISteamMatchmakingRulesResponse_RulesFailedToRespond;
        VTable.RulesRefreshComplete = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, void>)&ISteamMatchmakingRulesResponse_RulesRefreshComplete;
    }

    public static IntPtr Create(ISteamMatchmakingRulesResponseLogic logic)
    {
        var handle = GCHandle.Alloc(logic);
        var ptr = Marshal.AllocHGlobal(IntPtr.Size * 2);
        *(IntPtr*)ptr = VTablePtr;
        *(IntPtr*)((byte*)ptr + IntPtr.Size) = GCHandle.ToIntPtr(handle);
        return ptr;
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamMatchmakingRulesResponse_RulesResponded(IntPtr pThis, IntPtr pchRule, IntPtr pchValue)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamMatchmakingRulesResponseLogic)handle.Target!;
        return logic.RulesResponded(pchRule, pchValue);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamMatchmakingRulesResponse_RulesFailedToRespond(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamMatchmakingRulesResponseLogic)handle.Target!;
        return logic.RulesFailedToRespond();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamMatchmakingRulesResponse_RulesRefreshComplete(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamMatchmakingRulesResponseLogic)handle.Target!;
        return logic.RulesRefreshComplete();
    }
}

public unsafe class ISteamMatchmakingServersShim
{
    public static ISteamMatchmakingServersVTable VTable;
    public static IntPtr VTablePtr;

    static ISteamMatchmakingServersShim()
    {
        VTablePtr = (IntPtr)Unsafe.AsPointer(ref VTable);
        VTable.RequestInternetServerList = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, uint, IntPtr, uint>)&ISteamMatchmakingServers_RequestInternetServerList;
        VTable.RequestLANServerList = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, uint>)&ISteamMatchmakingServers_RequestLANServerList;
        VTable.RequestFriendsServerList = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, uint, IntPtr, uint>)&ISteamMatchmakingServers_RequestFriendsServerList;
        VTable.RequestFavoritesServerList = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, uint, IntPtr, uint>)&ISteamMatchmakingServers_RequestFavoritesServerList;
        VTable.RequestHistoryServerList = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, uint, IntPtr, uint>)&ISteamMatchmakingServers_RequestHistoryServerList;
        VTable.RequestSpectatorServerList = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, uint, IntPtr, uint>)&ISteamMatchmakingServers_RequestSpectatorServerList;
        VTable.ReleaseRequest = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, void>)&ISteamMatchmakingServers_ReleaseRequest;
        VTable.GetServerDetails = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, int, IntPtr>)&ISteamMatchmakingServers_GetServerDetails;
        VTable.CancelQuery = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, void>)&ISteamMatchmakingServers_CancelQuery;
        VTable.RefreshQuery = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, void>)&ISteamMatchmakingServers_RefreshQuery;
        VTable.IsRefreshing = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, byte>)&ISteamMatchmakingServers_IsRefreshing;
        VTable.GetServerCount = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, int>)&ISteamMatchmakingServers_GetServerCount;
        VTable.RefreshServer = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, int, void>)&ISteamMatchmakingServers_RefreshServer;
        VTable.PingServer = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, int, IntPtr, uint>)&ISteamMatchmakingServers_PingServer;
        VTable.PlayerDetails = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, int, IntPtr, uint>)&ISteamMatchmakingServers_PlayerDetails;
        VTable.ServerRules = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, int, IntPtr, uint>)&ISteamMatchmakingServers_ServerRules;
        VTable.CancelServerQuery = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, void>)&ISteamMatchmakingServers_CancelServerQuery;
    }

    public static IntPtr Create(ISteamMatchmakingServersLogic logic)
    {
        var handle = GCHandle.Alloc(logic);
        var ptr = Marshal.AllocHGlobal(IntPtr.Size * 2);
        *(IntPtr*)ptr = VTablePtr;
        *(IntPtr*)((byte*)ptr + IntPtr.Size) = GCHandle.ToIntPtr(handle);
        return ptr;
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static uint ISteamMatchmakingServers_RequestInternetServerList(IntPtr pThis, int iApp, IntPtr ppchFilters, uint nFilters, IntPtr pRequestServersResponse)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamMatchmakingServersLogic)handle.Target!;
        return logic.RequestInternetServerList(iApp, ppchFilters, nFilters, pRequestServersResponse);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static uint ISteamMatchmakingServers_RequestLANServerList(IntPtr pThis, int iApp, IntPtr pRequestServersResponse)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamMatchmakingServersLogic)handle.Target!;
        return logic.RequestLANServerList(iApp, pRequestServersResponse);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static uint ISteamMatchmakingServers_RequestFriendsServerList(IntPtr pThis, int iApp, IntPtr ppchFilters, uint nFilters, IntPtr pRequestServersResponse)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamMatchmakingServersLogic)handle.Target!;
        return logic.RequestFriendsServerList(iApp, ppchFilters, nFilters, pRequestServersResponse);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static uint ISteamMatchmakingServers_RequestFavoritesServerList(IntPtr pThis, int iApp, IntPtr ppchFilters, uint nFilters, IntPtr pRequestServersResponse)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamMatchmakingServersLogic)handle.Target!;
        return logic.RequestFavoritesServerList(iApp, ppchFilters, nFilters, pRequestServersResponse);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static uint ISteamMatchmakingServers_RequestHistoryServerList(IntPtr pThis, int iApp, IntPtr ppchFilters, uint nFilters, IntPtr pRequestServersResponse)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamMatchmakingServersLogic)handle.Target!;
        return logic.RequestHistoryServerList(iApp, ppchFilters, nFilters, pRequestServersResponse);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static uint ISteamMatchmakingServers_RequestSpectatorServerList(IntPtr pThis, int iApp, IntPtr ppchFilters, uint nFilters, IntPtr pRequestServersResponse)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamMatchmakingServersLogic)handle.Target!;
        return logic.RequestSpectatorServerList(iApp, ppchFilters, nFilters, pRequestServersResponse);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamMatchmakingServers_ReleaseRequest(IntPtr pThis, uint hServerListRequest)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamMatchmakingServersLogic)handle.Target!;
        return logic.ReleaseRequest(hServerListRequest);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static IntPtr ISteamMatchmakingServers_GetServerDetails(IntPtr pThis, uint hRequest, int iServer)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamMatchmakingServersLogic)handle.Target!;
        return logic.GetServerDetails(hRequest, iServer);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamMatchmakingServers_CancelQuery(IntPtr pThis, uint hRequest)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamMatchmakingServersLogic)handle.Target!;
        return logic.CancelQuery(hRequest);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamMatchmakingServers_RefreshQuery(IntPtr pThis, uint hRequest)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamMatchmakingServersLogic)handle.Target!;
        return logic.RefreshQuery(hRequest);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamMatchmakingServers_IsRefreshing(IntPtr pThis, uint hRequest)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamMatchmakingServersLogic)handle.Target!;
        return logic.IsRefreshing(hRequest);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamMatchmakingServers_GetServerCount(IntPtr pThis, uint hRequest)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamMatchmakingServersLogic)handle.Target!;
        return logic.GetServerCount(hRequest);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamMatchmakingServers_RefreshServer(IntPtr pThis, uint hRequest, int iServer)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamMatchmakingServersLogic)handle.Target!;
        return logic.RefreshServer(hRequest, iServer);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static uint ISteamMatchmakingServers_PingServer(IntPtr pThis, uint unIP, int usPort, IntPtr pRequestServersResponse)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamMatchmakingServersLogic)handle.Target!;
        return logic.PingServer(unIP, usPort, pRequestServersResponse);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static uint ISteamMatchmakingServers_PlayerDetails(IntPtr pThis, uint unIP, int usPort, IntPtr pRequestServersResponse)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamMatchmakingServersLogic)handle.Target!;
        return logic.PlayerDetails(unIP, usPort, pRequestServersResponse);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static uint ISteamMatchmakingServers_ServerRules(IntPtr pThis, uint unIP, int usPort, IntPtr pRequestServersResponse)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamMatchmakingServersLogic)handle.Target!;
        return logic.ServerRules(unIP, usPort, pRequestServersResponse);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamMatchmakingServers_CancelServerQuery(IntPtr pThis, uint hServerQuery)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamMatchmakingServersLogic)handle.Target!;
        return logic.CancelServerQuery(hServerQuery);
    }
}

public unsafe class ISteamPartiesShim
{
    public static ISteamPartiesVTable VTable;
    public static IntPtr VTablePtr;

    static ISteamPartiesShim()
    {
        VTablePtr = (IntPtr)Unsafe.AsPointer(ref VTable);
        VTable.GetNumActiveBeacons = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint>)&ISteamParties_GetNumActiveBeacons;
        VTable.GetBeaconByIndex = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, int>)&ISteamParties_GetBeaconByIndex;
        VTable.GetBeaconDetails = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, IntPtr, IntPtr, int, byte>)&ISteamParties_GetBeaconDetails;
        VTable.JoinParty = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, ulong>)&ISteamParties_JoinParty;
        VTable.GetNumAvailableBeaconLocations = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, byte>)&ISteamParties_GetNumAvailableBeaconLocations;
        VTable.GetAvailableBeaconLocations = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, uint, byte>)&ISteamParties_GetAvailableBeaconLocations;
        VTable.CreateBeacon = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, IntPtr, IntPtr, IntPtr, ulong>)&ISteamParties_CreateBeacon;
        VTable.OnReservationCompleted = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, ulong, void>)&ISteamParties_OnReservationCompleted;
        VTable.CancelReservation = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, ulong, void>)&ISteamParties_CancelReservation;
        VTable.ChangeNumOpenSlots = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, uint, ulong>)&ISteamParties_ChangeNumOpenSlots;
        VTable.DestroyBeacon = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, byte>)&ISteamParties_DestroyBeacon;
        VTable.GetBeaconLocationData = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, IntPtr, int, byte>)&ISteamParties_GetBeaconLocationData;
    }

    public static IntPtr Create(ISteamPartiesLogic logic)
    {
        var handle = GCHandle.Alloc(logic);
        var ptr = Marshal.AllocHGlobal(IntPtr.Size * 2);
        *(IntPtr*)ptr = VTablePtr;
        *(IntPtr*)((byte*)ptr + IntPtr.Size) = GCHandle.ToIntPtr(handle);
        return ptr;
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static uint ISteamParties_GetNumActiveBeacons(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamPartiesLogic)handle.Target!;
        return logic.GetNumActiveBeacons();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamParties_GetBeaconByIndex(IntPtr pThis, uint unIndex)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamPartiesLogic)handle.Target!;
        return logic.GetBeaconByIndex(unIndex);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamParties_GetBeaconDetails(IntPtr pThis, int ulBeaconID, IntPtr pSteamIDBeaconOwner, IntPtr pLocation, IntPtr pchMetadata, int cchMetadata)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamPartiesLogic)handle.Target!;
        return logic.GetBeaconDetails(ulBeaconID, pSteamIDBeaconOwner, pLocation, pchMetadata, cchMetadata);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamParties_JoinParty(IntPtr pThis, int ulBeaconID)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamPartiesLogic)handle.Target!;
        return logic.JoinParty(ulBeaconID);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamParties_GetNumAvailableBeaconLocations(IntPtr pThis, IntPtr puNumLocations)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamPartiesLogic)handle.Target!;
        return logic.GetNumAvailableBeaconLocations(puNumLocations);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamParties_GetAvailableBeaconLocations(IntPtr pThis, IntPtr pLocationList, uint uMaxNumLocations)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamPartiesLogic)handle.Target!;
        return logic.GetAvailableBeaconLocations(pLocationList, uMaxNumLocations);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamParties_CreateBeacon(IntPtr pThis, uint unOpenSlots, IntPtr pBeaconLocation, IntPtr pchConnectString, IntPtr pchMetadata)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamPartiesLogic)handle.Target!;
        return logic.CreateBeacon(unOpenSlots, pBeaconLocation, pchConnectString, pchMetadata);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamParties_OnReservationCompleted(IntPtr pThis, int ulBeacon, ulong steamIDUser)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamPartiesLogic)handle.Target!;
        return logic.OnReservationCompleted(ulBeacon, steamIDUser);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamParties_CancelReservation(IntPtr pThis, int ulBeacon, ulong steamIDUser)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamPartiesLogic)handle.Target!;
        return logic.CancelReservation(ulBeacon, steamIDUser);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamParties_ChangeNumOpenSlots(IntPtr pThis, int ulBeacon, uint unOpenSlots)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamPartiesLogic)handle.Target!;
        return logic.ChangeNumOpenSlots(ulBeacon, unOpenSlots);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamParties_DestroyBeacon(IntPtr pThis, int ulBeacon)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamPartiesLogic)handle.Target!;
        return logic.DestroyBeacon(ulBeacon);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamParties_GetBeaconLocationData(IntPtr pThis, int BeaconLocation, int eData, IntPtr pchDataStringOut, int cchDataStringOut)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamPartiesLogic)handle.Target!;
        return logic.GetBeaconLocationData(BeaconLocation, eData, pchDataStringOut, cchDataStringOut);
    }
}

public unsafe class ISteamRemoteStorageShim
{
    public static ISteamRemoteStorageVTable VTable;
    public static IntPtr VTablePtr;

    static ISteamRemoteStorageShim()
    {
        VTablePtr = (IntPtr)Unsafe.AsPointer(ref VTable);
        VTable.FileWrite = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, IntPtr, int, byte>)&ISteamRemoteStorage_FileWrite;
        VTable.FileRead = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, IntPtr, int, int>)&ISteamRemoteStorage_FileRead;
        VTable.FileWriteAsync = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, IntPtr, uint, ulong>)&ISteamRemoteStorage_FileWriteAsync;
        VTable.FileReadAsync = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, uint, uint, ulong>)&ISteamRemoteStorage_FileReadAsync;
        VTable.FileReadAsyncComplete = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, IntPtr, uint, byte>)&ISteamRemoteStorage_FileReadAsyncComplete;
        VTable.FileForget = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, byte>)&ISteamRemoteStorage_FileForget;
        VTable.FileDelete = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, byte>)&ISteamRemoteStorage_FileDelete;
        VTable.FileShare = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, ulong>)&ISteamRemoteStorage_FileShare;
        VTable.SetSyncPlatforms = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, int, byte>)&ISteamRemoteStorage_SetSyncPlatforms;
        VTable.FileWriteStreamOpen = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, int>)&ISteamRemoteStorage_FileWriteStreamOpen;
        VTable.FileWriteStreamWriteChunk = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, int, byte>)&ISteamRemoteStorage_FileWriteStreamWriteChunk;
        VTable.FileWriteStreamClose = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, byte>)&ISteamRemoteStorage_FileWriteStreamClose;
        VTable.FileWriteStreamCancel = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, byte>)&ISteamRemoteStorage_FileWriteStreamCancel;
        VTable.FileExists = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, byte>)&ISteamRemoteStorage_FileExists;
        VTable.FilePersisted = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, byte>)&ISteamRemoteStorage_FilePersisted;
        VTable.GetFileSize = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, int>)&ISteamRemoteStorage_GetFileSize;
        VTable.GetFileTimestamp = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, long>)&ISteamRemoteStorage_GetFileTimestamp;
        VTable.GetSyncPlatforms = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, int>)&ISteamRemoteStorage_GetSyncPlatforms;
        VTable.GetFileCount = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int>)&ISteamRemoteStorage_GetFileCount;
        VTable.GetFileNameAndSize = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, IntPtr>)&ISteamRemoteStorage_GetFileNameAndSize;
        VTable.GetQuota = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, IntPtr, byte>)&ISteamRemoteStorage_GetQuota;
        VTable.IsCloudEnabledForAccount = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, byte>)&ISteamRemoteStorage_IsCloudEnabledForAccount;
        VTable.IsCloudEnabledForApp = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, byte>)&ISteamRemoteStorage_IsCloudEnabledForApp;
        VTable.SetCloudEnabledForApp = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, byte, void>)&ISteamRemoteStorage_SetCloudEnabledForApp;
        VTable.UGCDownload = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, uint, ulong>)&ISteamRemoteStorage_UGCDownload;
        VTable.GetUGCDownloadProgress = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, IntPtr, byte>)&ISteamRemoteStorage_GetUGCDownloadProgress;
        VTable.GetUGCDetails = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, IntPtr, IntPtr, IntPtr, byte>)&ISteamRemoteStorage_GetUGCDetails;
        VTable.UGCRead = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, int, uint, int, int>)&ISteamRemoteStorage_UGCRead;
        VTable.GetCachedUGCCount = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int>)&ISteamRemoteStorage_GetCachedUGCCount;
        VTable.GetCachedUGCHandle = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int>)&ISteamRemoteStorage_GetCachedUGCHandle;
        VTable.PublishWorkshopFile = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, IntPtr, int, IntPtr, IntPtr, int, IntPtr, int, ulong>)&ISteamRemoteStorage_PublishWorkshopFile;
        VTable.CreatePublishedFileUpdateRequest = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int>)&ISteamRemoteStorage_CreatePublishedFileUpdateRequest;
        VTable.UpdatePublishedFileFile = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, byte>)&ISteamRemoteStorage_UpdatePublishedFileFile;
        VTable.UpdatePublishedFilePreviewFile = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, byte>)&ISteamRemoteStorage_UpdatePublishedFilePreviewFile;
        VTable.UpdatePublishedFileTitle = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, byte>)&ISteamRemoteStorage_UpdatePublishedFileTitle;
        VTable.UpdatePublishedFileDescription = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, byte>)&ISteamRemoteStorage_UpdatePublishedFileDescription;
        VTable.UpdatePublishedFileVisibility = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, byte>)&ISteamRemoteStorage_UpdatePublishedFileVisibility;
        VTable.UpdatePublishedFileTags = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, byte>)&ISteamRemoteStorage_UpdatePublishedFileTags;
        VTable.CommitPublishedFileUpdate = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, ulong>)&ISteamRemoteStorage_CommitPublishedFileUpdate;
        VTable.GetPublishedFileDetails = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, uint, ulong>)&ISteamRemoteStorage_GetPublishedFileDetails;
        VTable.DeletePublishedFile = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, ulong>)&ISteamRemoteStorage_DeletePublishedFile;
        VTable.EnumerateUserPublishedFiles = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, ulong>)&ISteamRemoteStorage_EnumerateUserPublishedFiles;
        VTable.SubscribePublishedFile = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, ulong>)&ISteamRemoteStorage_SubscribePublishedFile;
        VTable.EnumerateUserSubscribedFiles = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, ulong>)&ISteamRemoteStorage_EnumerateUserSubscribedFiles;
        VTable.UnsubscribePublishedFile = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, ulong>)&ISteamRemoteStorage_UnsubscribePublishedFile;
        VTable.UpdatePublishedFileSetChangeDescription = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, byte>)&ISteamRemoteStorage_UpdatePublishedFileSetChangeDescription;
        VTable.GetPublishedItemVoteDetails = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, ulong>)&ISteamRemoteStorage_GetPublishedItemVoteDetails;
        VTable.UpdateUserPublishedItemVote = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, byte, ulong>)&ISteamRemoteStorage_UpdateUserPublishedItemVote;
        VTable.GetUserPublishedItemVoteDetails = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, ulong>)&ISteamRemoteStorage_GetUserPublishedItemVoteDetails;
        VTable.EnumerateUserSharedWorkshopFiles = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, uint, IntPtr, IntPtr, ulong>)&ISteamRemoteStorage_EnumerateUserSharedWorkshopFiles;
        VTable.PublishVideo = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, IntPtr, IntPtr, int, IntPtr, IntPtr, int, IntPtr, ulong>)&ISteamRemoteStorage_PublishVideo;
        VTable.SetUserPublishedFileAction = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, ulong>)&ISteamRemoteStorage_SetUserPublishedFileAction;
        VTable.EnumeratePublishedFilesByUserAction = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, uint, ulong>)&ISteamRemoteStorage_EnumeratePublishedFilesByUserAction;
        VTable.EnumeratePublishedWorkshopFiles = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, uint, uint, uint, IntPtr, IntPtr, ulong>)&ISteamRemoteStorage_EnumeratePublishedWorkshopFiles;
        VTable.UGCDownloadToLocation = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, uint, ulong>)&ISteamRemoteStorage_UGCDownloadToLocation;
        VTable.GetLocalFileChangeCount = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int>)&ISteamRemoteStorage_GetLocalFileChangeCount;
        VTable.GetLocalFileChange = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, IntPtr, IntPtr>)&ISteamRemoteStorage_GetLocalFileChange;
        VTable.BeginFileWriteBatch = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, byte>)&ISteamRemoteStorage_BeginFileWriteBatch;
        VTable.EndFileWriteBatch = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, byte>)&ISteamRemoteStorage_EndFileWriteBatch;
    }

    public static IntPtr Create(ISteamRemoteStorageLogic logic)
    {
        var handle = GCHandle.Alloc(logic);
        var ptr = Marshal.AllocHGlobal(IntPtr.Size * 2);
        *(IntPtr*)ptr = VTablePtr;
        *(IntPtr*)((byte*)ptr + IntPtr.Size) = GCHandle.ToIntPtr(handle);
        return ptr;
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamRemoteStorage_FileWrite(IntPtr pThis, IntPtr pchFile, IntPtr pvData, int cubData)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamRemoteStorageLogic)handle.Target!;
        return logic.FileWrite(pchFile, pvData, cubData);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamRemoteStorage_FileRead(IntPtr pThis, IntPtr pchFile, IntPtr pvData, int cubDataToRead)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamRemoteStorageLogic)handle.Target!;
        return logic.FileRead(pchFile, pvData, cubDataToRead);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamRemoteStorage_FileWriteAsync(IntPtr pThis, IntPtr pchFile, IntPtr pvData, uint cubData)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamRemoteStorageLogic)handle.Target!;
        return logic.FileWriteAsync(pchFile, pvData, cubData);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamRemoteStorage_FileReadAsync(IntPtr pThis, IntPtr pchFile, uint nOffset, uint cubToRead)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamRemoteStorageLogic)handle.Target!;
        return logic.FileReadAsync(pchFile, nOffset, cubToRead);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamRemoteStorage_FileReadAsyncComplete(IntPtr pThis, ulong hReadCall, IntPtr pvBuffer, uint cubToRead)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamRemoteStorageLogic)handle.Target!;
        return logic.FileReadAsyncComplete(hReadCall, pvBuffer, cubToRead);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamRemoteStorage_FileForget(IntPtr pThis, IntPtr pchFile)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamRemoteStorageLogic)handle.Target!;
        return logic.FileForget(pchFile);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamRemoteStorage_FileDelete(IntPtr pThis, IntPtr pchFile)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamRemoteStorageLogic)handle.Target!;
        return logic.FileDelete(pchFile);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamRemoteStorage_FileShare(IntPtr pThis, IntPtr pchFile)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamRemoteStorageLogic)handle.Target!;
        return logic.FileShare(pchFile);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamRemoteStorage_SetSyncPlatforms(IntPtr pThis, IntPtr pchFile, int eRemoteStoragePlatform)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamRemoteStorageLogic)handle.Target!;
        return logic.SetSyncPlatforms(pchFile, eRemoteStoragePlatform);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamRemoteStorage_FileWriteStreamOpen(IntPtr pThis, IntPtr pchFile)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamRemoteStorageLogic)handle.Target!;
        return logic.FileWriteStreamOpen(pchFile);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamRemoteStorage_FileWriteStreamWriteChunk(IntPtr pThis, int writeHandle, IntPtr pvData, int cubData)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamRemoteStorageLogic)handle.Target!;
        return logic.FileWriteStreamWriteChunk(writeHandle, pvData, cubData);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamRemoteStorage_FileWriteStreamClose(IntPtr pThis, int writeHandle)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamRemoteStorageLogic)handle.Target!;
        return logic.FileWriteStreamClose(writeHandle);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamRemoteStorage_FileWriteStreamCancel(IntPtr pThis, int writeHandle)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamRemoteStorageLogic)handle.Target!;
        return logic.FileWriteStreamCancel(writeHandle);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamRemoteStorage_FileExists(IntPtr pThis, IntPtr pchFile)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamRemoteStorageLogic)handle.Target!;
        return logic.FileExists(pchFile);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamRemoteStorage_FilePersisted(IntPtr pThis, IntPtr pchFile)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamRemoteStorageLogic)handle.Target!;
        return logic.FilePersisted(pchFile);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamRemoteStorage_GetFileSize(IntPtr pThis, IntPtr pchFile)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamRemoteStorageLogic)handle.Target!;
        return logic.GetFileSize(pchFile);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static long ISteamRemoteStorage_GetFileTimestamp(IntPtr pThis, IntPtr pchFile)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamRemoteStorageLogic)handle.Target!;
        return logic.GetFileTimestamp(pchFile);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamRemoteStorage_GetSyncPlatforms(IntPtr pThis, IntPtr pchFile)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamRemoteStorageLogic)handle.Target!;
        return logic.GetSyncPlatforms(pchFile);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamRemoteStorage_GetFileCount(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamRemoteStorageLogic)handle.Target!;
        return logic.GetFileCount();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static IntPtr ISteamRemoteStorage_GetFileNameAndSize(IntPtr pThis, int iFile, IntPtr pnFileSizeInBytes)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamRemoteStorageLogic)handle.Target!;
        return logic.GetFileNameAndSize(iFile, pnFileSizeInBytes);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamRemoteStorage_GetQuota(IntPtr pThis, IntPtr pnTotalBytes, IntPtr puAvailableBytes)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamRemoteStorageLogic)handle.Target!;
        return logic.GetQuota(pnTotalBytes, puAvailableBytes);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamRemoteStorage_IsCloudEnabledForAccount(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamRemoteStorageLogic)handle.Target!;
        return logic.IsCloudEnabledForAccount();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamRemoteStorage_IsCloudEnabledForApp(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamRemoteStorageLogic)handle.Target!;
        return logic.IsCloudEnabledForApp();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamRemoteStorage_SetCloudEnabledForApp(IntPtr pThis, byte bEnabled)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamRemoteStorageLogic)handle.Target!;
        return logic.SetCloudEnabledForApp(bEnabled);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamRemoteStorage_UGCDownload(IntPtr pThis, int hContent, uint unPriority)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamRemoteStorageLogic)handle.Target!;
        return logic.UGCDownload(hContent, unPriority);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamRemoteStorage_GetUGCDownloadProgress(IntPtr pThis, int hContent, IntPtr pnBytesDownloaded, IntPtr pnBytesExpected)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamRemoteStorageLogic)handle.Target!;
        return logic.GetUGCDownloadProgress(hContent, pnBytesDownloaded, pnBytesExpected);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamRemoteStorage_GetUGCDetails(IntPtr pThis, int hContent, IntPtr pnAppID, IntPtr ppchName, IntPtr pnFileSizeInBytes, IntPtr pSteamIDOwner)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamRemoteStorageLogic)handle.Target!;
        return logic.GetUGCDetails(hContent, pnAppID, ppchName, pnFileSizeInBytes, pSteamIDOwner);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamRemoteStorage_UGCRead(IntPtr pThis, int hContent, IntPtr pvData, int cubDataToRead, uint cOffset, int eAction)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamRemoteStorageLogic)handle.Target!;
        return logic.UGCRead(hContent, pvData, cubDataToRead, cOffset, eAction);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamRemoteStorage_GetCachedUGCCount(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamRemoteStorageLogic)handle.Target!;
        return logic.GetCachedUGCCount();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamRemoteStorage_GetCachedUGCHandle(IntPtr pThis, int iCachedContent)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamRemoteStorageLogic)handle.Target!;
        return logic.GetCachedUGCHandle(iCachedContent);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamRemoteStorage_PublishWorkshopFile(IntPtr pThis, IntPtr pchFile, IntPtr pchPreviewFile, int nConsumerAppId, IntPtr pchTitle, IntPtr pchDescription, int eVisibility, IntPtr pTags, int eWorkshopFileType)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamRemoteStorageLogic)handle.Target!;
        return logic.PublishWorkshopFile(pchFile, pchPreviewFile, nConsumerAppId, pchTitle, pchDescription, eVisibility, pTags, eWorkshopFileType);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamRemoteStorage_CreatePublishedFileUpdateRequest(IntPtr pThis, int unPublishedFileId)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamRemoteStorageLogic)handle.Target!;
        return logic.CreatePublishedFileUpdateRequest(unPublishedFileId);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamRemoteStorage_UpdatePublishedFileFile(IntPtr pThis, int updateHandle, IntPtr pchFile)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamRemoteStorageLogic)handle.Target!;
        return logic.UpdatePublishedFileFile(updateHandle, pchFile);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamRemoteStorage_UpdatePublishedFilePreviewFile(IntPtr pThis, int updateHandle, IntPtr pchPreviewFile)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamRemoteStorageLogic)handle.Target!;
        return logic.UpdatePublishedFilePreviewFile(updateHandle, pchPreviewFile);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamRemoteStorage_UpdatePublishedFileTitle(IntPtr pThis, int updateHandle, IntPtr pchTitle)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamRemoteStorageLogic)handle.Target!;
        return logic.UpdatePublishedFileTitle(updateHandle, pchTitle);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamRemoteStorage_UpdatePublishedFileDescription(IntPtr pThis, int updateHandle, IntPtr pchDescription)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamRemoteStorageLogic)handle.Target!;
        return logic.UpdatePublishedFileDescription(updateHandle, pchDescription);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamRemoteStorage_UpdatePublishedFileVisibility(IntPtr pThis, int updateHandle, int eVisibility)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamRemoteStorageLogic)handle.Target!;
        return logic.UpdatePublishedFileVisibility(updateHandle, eVisibility);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamRemoteStorage_UpdatePublishedFileTags(IntPtr pThis, int updateHandle, IntPtr pTags)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamRemoteStorageLogic)handle.Target!;
        return logic.UpdatePublishedFileTags(updateHandle, pTags);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamRemoteStorage_CommitPublishedFileUpdate(IntPtr pThis, int updateHandle)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamRemoteStorageLogic)handle.Target!;
        return logic.CommitPublishedFileUpdate(updateHandle);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamRemoteStorage_GetPublishedFileDetails(IntPtr pThis, int unPublishedFileId, uint unMaxSecondsOld)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamRemoteStorageLogic)handle.Target!;
        return logic.GetPublishedFileDetails(unPublishedFileId, unMaxSecondsOld);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamRemoteStorage_DeletePublishedFile(IntPtr pThis, int unPublishedFileId)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamRemoteStorageLogic)handle.Target!;
        return logic.DeletePublishedFile(unPublishedFileId);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamRemoteStorage_EnumerateUserPublishedFiles(IntPtr pThis, uint unStartIndex)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamRemoteStorageLogic)handle.Target!;
        return logic.EnumerateUserPublishedFiles(unStartIndex);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamRemoteStorage_SubscribePublishedFile(IntPtr pThis, int unPublishedFileId)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamRemoteStorageLogic)handle.Target!;
        return logic.SubscribePublishedFile(unPublishedFileId);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamRemoteStorage_EnumerateUserSubscribedFiles(IntPtr pThis, uint unStartIndex)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamRemoteStorageLogic)handle.Target!;
        return logic.EnumerateUserSubscribedFiles(unStartIndex);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamRemoteStorage_UnsubscribePublishedFile(IntPtr pThis, int unPublishedFileId)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamRemoteStorageLogic)handle.Target!;
        return logic.UnsubscribePublishedFile(unPublishedFileId);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamRemoteStorage_UpdatePublishedFileSetChangeDescription(IntPtr pThis, int updateHandle, IntPtr pchChangeDescription)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamRemoteStorageLogic)handle.Target!;
        return logic.UpdatePublishedFileSetChangeDescription(updateHandle, pchChangeDescription);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamRemoteStorage_GetPublishedItemVoteDetails(IntPtr pThis, int unPublishedFileId)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamRemoteStorageLogic)handle.Target!;
        return logic.GetPublishedItemVoteDetails(unPublishedFileId);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamRemoteStorage_UpdateUserPublishedItemVote(IntPtr pThis, int unPublishedFileId, byte bVoteUp)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamRemoteStorageLogic)handle.Target!;
        return logic.UpdateUserPublishedItemVote(unPublishedFileId, bVoteUp);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamRemoteStorage_GetUserPublishedItemVoteDetails(IntPtr pThis, int unPublishedFileId)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamRemoteStorageLogic)handle.Target!;
        return logic.GetUserPublishedItemVoteDetails(unPublishedFileId);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamRemoteStorage_EnumerateUserSharedWorkshopFiles(IntPtr pThis, ulong steamId, uint unStartIndex, IntPtr pRequiredTags, IntPtr pExcludedTags)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamRemoteStorageLogic)handle.Target!;
        return logic.EnumerateUserSharedWorkshopFiles(steamId, unStartIndex, pRequiredTags, pExcludedTags);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamRemoteStorage_PublishVideo(IntPtr pThis, int eVideoProvider, IntPtr pchVideoAccount, IntPtr pchVideoIdentifier, IntPtr pchPreviewFile, int nConsumerAppId, IntPtr pchTitle, IntPtr pchDescription, int eVisibility, IntPtr pTags)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamRemoteStorageLogic)handle.Target!;
        return logic.PublishVideo(eVideoProvider, pchVideoAccount, pchVideoIdentifier, pchPreviewFile, nConsumerAppId, pchTitle, pchDescription, eVisibility, pTags);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamRemoteStorage_SetUserPublishedFileAction(IntPtr pThis, int unPublishedFileId, int eAction)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamRemoteStorageLogic)handle.Target!;
        return logic.SetUserPublishedFileAction(unPublishedFileId, eAction);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamRemoteStorage_EnumeratePublishedFilesByUserAction(IntPtr pThis, int eAction, uint unStartIndex)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamRemoteStorageLogic)handle.Target!;
        return logic.EnumeratePublishedFilesByUserAction(eAction, unStartIndex);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamRemoteStorage_EnumeratePublishedWorkshopFiles(IntPtr pThis, int eEnumerationType, uint unStartIndex, uint unCount, uint unDays, IntPtr pTags, IntPtr pUserTags)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamRemoteStorageLogic)handle.Target!;
        return logic.EnumeratePublishedWorkshopFiles(eEnumerationType, unStartIndex, unCount, unDays, pTags, pUserTags);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamRemoteStorage_UGCDownloadToLocation(IntPtr pThis, int hContent, IntPtr pchLocation, uint unPriority)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamRemoteStorageLogic)handle.Target!;
        return logic.UGCDownloadToLocation(hContent, pchLocation, unPriority);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamRemoteStorage_GetLocalFileChangeCount(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamRemoteStorageLogic)handle.Target!;
        return logic.GetLocalFileChangeCount();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static IntPtr ISteamRemoteStorage_GetLocalFileChange(IntPtr pThis, int iFile, IntPtr pEChangeType, IntPtr pEFilePathType)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamRemoteStorageLogic)handle.Target!;
        return logic.GetLocalFileChange(iFile, pEChangeType, pEFilePathType);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamRemoteStorage_BeginFileWriteBatch(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamRemoteStorageLogic)handle.Target!;
        return logic.BeginFileWriteBatch();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamRemoteStorage_EndFileWriteBatch(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamRemoteStorageLogic)handle.Target!;
        return logic.EndFileWriteBatch();
    }
}

public unsafe class ISteamUserStatsShim
{
    public static ISteamUserStatsVTable VTable;
    public static IntPtr VTablePtr;

    static ISteamUserStatsShim()
    {
        VTablePtr = (IntPtr)Unsafe.AsPointer(ref VTable);
        VTable.GetStat = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, IntPtr, byte>)&ISteamUserStats_GetStat;
        VTable.GetStat = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, IntPtr, byte>)&ISteamUserStats_GetStat;
        VTable.SetStat = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, int, byte>)&ISteamUserStats_SetStat;
        VTable.SetStat = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, int, byte>)&ISteamUserStats_SetStat;
        VTable.UpdateAvgRateStat = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, int, int, byte>)&ISteamUserStats_UpdateAvgRateStat;
        VTable.GetAchievement = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, IntPtr, byte>)&ISteamUserStats_GetAchievement;
        VTable.SetAchievement = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, byte>)&ISteamUserStats_SetAchievement;
        VTable.ClearAchievement = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, byte>)&ISteamUserStats_ClearAchievement;
        VTable.GetAchievementAndUnlockTime = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, IntPtr, IntPtr, byte>)&ISteamUserStats_GetAchievementAndUnlockTime;
        VTable.StoreStats = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, byte>)&ISteamUserStats_StoreStats;
        VTable.GetAchievementIcon = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, int>)&ISteamUserStats_GetAchievementIcon;
        VTable.GetAchievementDisplayAttribute = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, IntPtr, IntPtr>)&ISteamUserStats_GetAchievementDisplayAttribute;
        VTable.IndicateAchievementProgress = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, uint, uint, byte>)&ISteamUserStats_IndicateAchievementProgress;
        VTable.GetNumAchievements = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint>)&ISteamUserStats_GetNumAchievements;
        VTable.GetAchievementName = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, IntPtr>)&ISteamUserStats_GetAchievementName;
        VTable.RequestUserStats = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, ulong>)&ISteamUserStats_RequestUserStats;
        VTable.GetUserStat = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, IntPtr, IntPtr, byte>)&ISteamUserStats_GetUserStat;
        VTable.GetUserStat = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, IntPtr, IntPtr, byte>)&ISteamUserStats_GetUserStat;
        VTable.GetUserAchievement = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, IntPtr, IntPtr, byte>)&ISteamUserStats_GetUserAchievement;
        VTable.GetUserAchievementAndUnlockTime = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, IntPtr, IntPtr, IntPtr, byte>)&ISteamUserStats_GetUserAchievementAndUnlockTime;
        VTable.ResetAllStats = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, byte, byte>)&ISteamUserStats_ResetAllStats;
        VTable.FindOrCreateLeaderboard = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, int, int, ulong>)&ISteamUserStats_FindOrCreateLeaderboard;
        VTable.FindLeaderboard = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, ulong>)&ISteamUserStats_FindLeaderboard;
        VTable.GetLeaderboardName = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr>)&ISteamUserStats_GetLeaderboardName;
        VTable.GetLeaderboardEntryCount = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int>)&ISteamUserStats_GetLeaderboardEntryCount;
        VTable.GetLeaderboardSortMethod = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int>)&ISteamUserStats_GetLeaderboardSortMethod;
        VTable.GetLeaderboardDisplayType = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int>)&ISteamUserStats_GetLeaderboardDisplayType;
        VTable.DownloadLeaderboardEntries = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, int, int, ulong>)&ISteamUserStats_DownloadLeaderboardEntries;
        VTable.DownloadLeaderboardEntriesForUsers = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, int, ulong>)&ISteamUserStats_DownloadLeaderboardEntriesForUsers;
        VTable.GetDownloadedLeaderboardEntry = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, IntPtr, IntPtr, int, byte>)&ISteamUserStats_GetDownloadedLeaderboardEntry;
        VTable.UploadLeaderboardScore = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, int, IntPtr, int, ulong>)&ISteamUserStats_UploadLeaderboardScore;
        VTable.AttachLeaderboardUGC = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, ulong>)&ISteamUserStats_AttachLeaderboardUGC;
        VTable.GetNumberOfCurrentPlayers = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong>)&ISteamUserStats_GetNumberOfCurrentPlayers;
        VTable.RequestGlobalAchievementPercentages = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong>)&ISteamUserStats_RequestGlobalAchievementPercentages;
        VTable.GetMostAchievedAchievementInfo = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, uint, IntPtr, IntPtr, int>)&ISteamUserStats_GetMostAchievedAchievementInfo;
        VTable.GetNextMostAchievedAchievementInfo = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, uint, IntPtr, IntPtr, int>)&ISteamUserStats_GetNextMostAchievedAchievementInfo;
        VTable.GetAchievementAchievedPercent = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, IntPtr, byte>)&ISteamUserStats_GetAchievementAchievedPercent;
        VTable.RequestGlobalStats = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, ulong>)&ISteamUserStats_RequestGlobalStats;
        VTable.GetGlobalStat = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, IntPtr, byte>)&ISteamUserStats_GetGlobalStat;
        VTable.GetGlobalStat = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, IntPtr, byte>)&ISteamUserStats_GetGlobalStat;
        VTable.GetGlobalStatHistory = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, IntPtr, uint, int>)&ISteamUserStats_GetGlobalStatHistory;
        VTable.GetGlobalStatHistory = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, IntPtr, uint, int>)&ISteamUserStats_GetGlobalStatHistory;
        VTable.GetAchievementProgressLimits = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, IntPtr, IntPtr, byte>)&ISteamUserStats_GetAchievementProgressLimits;
        VTable.GetAchievementProgressLimits = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, IntPtr, IntPtr, byte>)&ISteamUserStats_GetAchievementProgressLimits;
    }

    public static IntPtr Create(ISteamUserStatsLogic logic)
    {
        var handle = GCHandle.Alloc(logic);
        var ptr = Marshal.AllocHGlobal(IntPtr.Size * 2);
        *(IntPtr*)ptr = VTablePtr;
        *(IntPtr*)((byte*)ptr + IntPtr.Size) = GCHandle.ToIntPtr(handle);
        return ptr;
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUserStats_GetStat(IntPtr pThis, IntPtr pchName, IntPtr pData)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUserStatsLogic)handle.Target!;
        return logic.GetStat(pchName, pData);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUserStats_GetStat(IntPtr pThis, IntPtr pchName, IntPtr pData)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUserStatsLogic)handle.Target!;
        return logic.GetStat(pchName, pData);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUserStats_SetStat(IntPtr pThis, IntPtr pchName, int nData)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUserStatsLogic)handle.Target!;
        return logic.SetStat(pchName, nData);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUserStats_SetStat(IntPtr pThis, IntPtr pchName, int fData)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUserStatsLogic)handle.Target!;
        return logic.SetStat(pchName, fData);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUserStats_UpdateAvgRateStat(IntPtr pThis, IntPtr pchName, int flCountThisSession, int dSessionLength)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUserStatsLogic)handle.Target!;
        return logic.UpdateAvgRateStat(pchName, flCountThisSession, dSessionLength);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUserStats_GetAchievement(IntPtr pThis, IntPtr pchName, IntPtr pbAchieved)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUserStatsLogic)handle.Target!;
        return logic.GetAchievement(pchName, pbAchieved);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUserStats_SetAchievement(IntPtr pThis, IntPtr pchName)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUserStatsLogic)handle.Target!;
        return logic.SetAchievement(pchName);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUserStats_ClearAchievement(IntPtr pThis, IntPtr pchName)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUserStatsLogic)handle.Target!;
        return logic.ClearAchievement(pchName);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUserStats_GetAchievementAndUnlockTime(IntPtr pThis, IntPtr pchName, IntPtr pbAchieved, IntPtr punUnlockTime)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUserStatsLogic)handle.Target!;
        return logic.GetAchievementAndUnlockTime(pchName, pbAchieved, punUnlockTime);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUserStats_StoreStats(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUserStatsLogic)handle.Target!;
        return logic.StoreStats();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamUserStats_GetAchievementIcon(IntPtr pThis, IntPtr pchName)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUserStatsLogic)handle.Target!;
        return logic.GetAchievementIcon(pchName);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static IntPtr ISteamUserStats_GetAchievementDisplayAttribute(IntPtr pThis, IntPtr pchName, IntPtr pchKey)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUserStatsLogic)handle.Target!;
        return logic.GetAchievementDisplayAttribute(pchName, pchKey);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUserStats_IndicateAchievementProgress(IntPtr pThis, IntPtr pchName, uint nCurProgress, uint nMaxProgress)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUserStatsLogic)handle.Target!;
        return logic.IndicateAchievementProgress(pchName, nCurProgress, nMaxProgress);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static uint ISteamUserStats_GetNumAchievements(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUserStatsLogic)handle.Target!;
        return logic.GetNumAchievements();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static IntPtr ISteamUserStats_GetAchievementName(IntPtr pThis, uint iAchievement)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUserStatsLogic)handle.Target!;
        return logic.GetAchievementName(iAchievement);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamUserStats_RequestUserStats(IntPtr pThis, ulong steamIDUser)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUserStatsLogic)handle.Target!;
        return logic.RequestUserStats(steamIDUser);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUserStats_GetUserStat(IntPtr pThis, ulong steamIDUser, IntPtr pchName, IntPtr pData)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUserStatsLogic)handle.Target!;
        return logic.GetUserStat(steamIDUser, pchName, pData);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUserStats_GetUserStat(IntPtr pThis, ulong steamIDUser, IntPtr pchName, IntPtr pData)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUserStatsLogic)handle.Target!;
        return logic.GetUserStat(steamIDUser, pchName, pData);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUserStats_GetUserAchievement(IntPtr pThis, ulong steamIDUser, IntPtr pchName, IntPtr pbAchieved)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUserStatsLogic)handle.Target!;
        return logic.GetUserAchievement(steamIDUser, pchName, pbAchieved);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUserStats_GetUserAchievementAndUnlockTime(IntPtr pThis, ulong steamIDUser, IntPtr pchName, IntPtr pbAchieved, IntPtr punUnlockTime)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUserStatsLogic)handle.Target!;
        return logic.GetUserAchievementAndUnlockTime(steamIDUser, pchName, pbAchieved, punUnlockTime);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUserStats_ResetAllStats(IntPtr pThis, byte bAchievementsToo)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUserStatsLogic)handle.Target!;
        return logic.ResetAllStats(bAchievementsToo);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamUserStats_FindOrCreateLeaderboard(IntPtr pThis, IntPtr pchLeaderboardName, int eLeaderboardSortMethod, int eLeaderboardDisplayType)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUserStatsLogic)handle.Target!;
        return logic.FindOrCreateLeaderboard(pchLeaderboardName, eLeaderboardSortMethod, eLeaderboardDisplayType);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamUserStats_FindLeaderboard(IntPtr pThis, IntPtr pchLeaderboardName)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUserStatsLogic)handle.Target!;
        return logic.FindLeaderboard(pchLeaderboardName);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static IntPtr ISteamUserStats_GetLeaderboardName(IntPtr pThis, int hSteamLeaderboard)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUserStatsLogic)handle.Target!;
        return logic.GetLeaderboardName(hSteamLeaderboard);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamUserStats_GetLeaderboardEntryCount(IntPtr pThis, int hSteamLeaderboard)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUserStatsLogic)handle.Target!;
        return logic.GetLeaderboardEntryCount(hSteamLeaderboard);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamUserStats_GetLeaderboardSortMethod(IntPtr pThis, int hSteamLeaderboard)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUserStatsLogic)handle.Target!;
        return logic.GetLeaderboardSortMethod(hSteamLeaderboard);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamUserStats_GetLeaderboardDisplayType(IntPtr pThis, int hSteamLeaderboard)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUserStatsLogic)handle.Target!;
        return logic.GetLeaderboardDisplayType(hSteamLeaderboard);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamUserStats_DownloadLeaderboardEntries(IntPtr pThis, int hSteamLeaderboard, int eLeaderboardDataRequest, int nRangeStart, int nRangeEnd)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUserStatsLogic)handle.Target!;
        return logic.DownloadLeaderboardEntries(hSteamLeaderboard, eLeaderboardDataRequest, nRangeStart, nRangeEnd);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamUserStats_DownloadLeaderboardEntriesForUsers(IntPtr pThis, int hSteamLeaderboard, IntPtr prgUsers, int cUsers)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUserStatsLogic)handle.Target!;
        return logic.DownloadLeaderboardEntriesForUsers(hSteamLeaderboard, prgUsers, cUsers);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUserStats_GetDownloadedLeaderboardEntry(IntPtr pThis, int hSteamLeaderboardEntries, int index, IntPtr pLeaderboardEntry, IntPtr pDetails, int cDetailsMax)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUserStatsLogic)handle.Target!;
        return logic.GetDownloadedLeaderboardEntry(hSteamLeaderboardEntries, index, pLeaderboardEntry, pDetails, cDetailsMax);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamUserStats_UploadLeaderboardScore(IntPtr pThis, int hSteamLeaderboard, int eLeaderboardUploadScoreMethod, int nScore, IntPtr pScoreDetails, int cScoreDetailsCount)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUserStatsLogic)handle.Target!;
        return logic.UploadLeaderboardScore(hSteamLeaderboard, eLeaderboardUploadScoreMethod, nScore, pScoreDetails, cScoreDetailsCount);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamUserStats_AttachLeaderboardUGC(IntPtr pThis, int hSteamLeaderboard, int hUGC)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUserStatsLogic)handle.Target!;
        return logic.AttachLeaderboardUGC(hSteamLeaderboard, hUGC);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamUserStats_GetNumberOfCurrentPlayers(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUserStatsLogic)handle.Target!;
        return logic.GetNumberOfCurrentPlayers();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamUserStats_RequestGlobalAchievementPercentages(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUserStatsLogic)handle.Target!;
        return logic.RequestGlobalAchievementPercentages();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamUserStats_GetMostAchievedAchievementInfo(IntPtr pThis, IntPtr pchName, uint unNameBufLen, IntPtr pflPercent, IntPtr pbAchieved)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUserStatsLogic)handle.Target!;
        return logic.GetMostAchievedAchievementInfo(pchName, unNameBufLen, pflPercent, pbAchieved);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamUserStats_GetNextMostAchievedAchievementInfo(IntPtr pThis, int iIteratorPrevious, IntPtr pchName, uint unNameBufLen, IntPtr pflPercent, IntPtr pbAchieved)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUserStatsLogic)handle.Target!;
        return logic.GetNextMostAchievedAchievementInfo(iIteratorPrevious, pchName, unNameBufLen, pflPercent, pbAchieved);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUserStats_GetAchievementAchievedPercent(IntPtr pThis, IntPtr pchName, IntPtr pflPercent)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUserStatsLogic)handle.Target!;
        return logic.GetAchievementAchievedPercent(pchName, pflPercent);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamUserStats_RequestGlobalStats(IntPtr pThis, int nHistoryDays)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUserStatsLogic)handle.Target!;
        return logic.RequestGlobalStats(nHistoryDays);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUserStats_GetGlobalStat(IntPtr pThis, IntPtr pchStatName, IntPtr pData)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUserStatsLogic)handle.Target!;
        return logic.GetGlobalStat(pchStatName, pData);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUserStats_GetGlobalStat(IntPtr pThis, IntPtr pchStatName, IntPtr pData)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUserStatsLogic)handle.Target!;
        return logic.GetGlobalStat(pchStatName, pData);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamUserStats_GetGlobalStatHistory(IntPtr pThis, IntPtr pchStatName, IntPtr pData, uint cubData)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUserStatsLogic)handle.Target!;
        return logic.GetGlobalStatHistory(pchStatName, pData, cubData);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamUserStats_GetGlobalStatHistory(IntPtr pThis, IntPtr pchStatName, IntPtr pData, uint cubData)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUserStatsLogic)handle.Target!;
        return logic.GetGlobalStatHistory(pchStatName, pData, cubData);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUserStats_GetAchievementProgressLimits(IntPtr pThis, IntPtr pchName, IntPtr pnMinProgress, IntPtr pnMaxProgress)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUserStatsLogic)handle.Target!;
        return logic.GetAchievementProgressLimits(pchName, pnMinProgress, pnMaxProgress);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUserStats_GetAchievementProgressLimits(IntPtr pThis, IntPtr pchName, IntPtr pfMinProgress, IntPtr pfMaxProgress)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUserStatsLogic)handle.Target!;
        return logic.GetAchievementProgressLimits(pchName, pfMinProgress, pfMaxProgress);
    }
}

public unsafe class ISteamAppsShim
{
    public static ISteamAppsVTable VTable;
    public static IntPtr VTablePtr;

    static ISteamAppsShim()
    {
        VTablePtr = (IntPtr)Unsafe.AsPointer(ref VTable);
        VTable.BIsSubscribed = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, byte>)&ISteamApps_BIsSubscribed;
        VTable.BIsLowViolence = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, byte>)&ISteamApps_BIsLowViolence;
        VTable.BIsCybercafe = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, byte>)&ISteamApps_BIsCybercafe;
        VTable.BIsVACBanned = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, byte>)&ISteamApps_BIsVACBanned;
        VTable.GetCurrentGameLanguage = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr>)&ISteamApps_GetCurrentGameLanguage;
        VTable.GetAvailableGameLanguages = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr>)&ISteamApps_GetAvailableGameLanguages;
        VTable.BIsSubscribedApp = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, byte>)&ISteamApps_BIsSubscribedApp;
        VTable.BIsDlcInstalled = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, byte>)&ISteamApps_BIsDlcInstalled;
        VTable.GetEarliestPurchaseUnixTime = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, uint>)&ISteamApps_GetEarliestPurchaseUnixTime;
        VTable.BIsSubscribedFromFreeWeekend = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, byte>)&ISteamApps_BIsSubscribedFromFreeWeekend;
        VTable.GetDLCCount = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int>)&ISteamApps_GetDLCCount;
        VTable.BGetDLCDataByIndex = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, IntPtr, IntPtr, int, byte>)&ISteamApps_BGetDLCDataByIndex;
        VTable.InstallDLC = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, void>)&ISteamApps_InstallDLC;
        VTable.UninstallDLC = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, void>)&ISteamApps_UninstallDLC;
        VTable.RequestAppProofOfPurchaseKey = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, void>)&ISteamApps_RequestAppProofOfPurchaseKey;
        VTable.GetCurrentBetaName = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, int, byte>)&ISteamApps_GetCurrentBetaName;
        VTable.MarkContentCorrupt = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, byte, byte>)&ISteamApps_MarkContentCorrupt;
        VTable.GetInstalledDepots = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, uint, uint>)&ISteamApps_GetInstalledDepots;
        VTable.GetAppInstallDir = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, uint, uint>)&ISteamApps_GetAppInstallDir;
        VTable.BIsAppInstalled = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, byte>)&ISteamApps_BIsAppInstalled;
        VTable.GetAppOwner = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong>)&ISteamApps_GetAppOwner;
        VTable.GetLaunchQueryParam = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, IntPtr>)&ISteamApps_GetLaunchQueryParam;
        VTable.GetDlcDownloadProgress = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, IntPtr, byte>)&ISteamApps_GetDlcDownloadProgress;
        VTable.GetAppBuildId = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int>)&ISteamApps_GetAppBuildId;
        VTable.RequestAllProofOfPurchaseKeys = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, void>)&ISteamApps_RequestAllProofOfPurchaseKeys;
        VTable.GetFileDetails = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, ulong>)&ISteamApps_GetFileDetails;
        VTable.GetLaunchCommandLine = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, int, int>)&ISteamApps_GetLaunchCommandLine;
        VTable.BIsSubscribedFromFamilySharing = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, byte>)&ISteamApps_BIsSubscribedFromFamilySharing;
        VTable.BIsTimedTrial = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, IntPtr, byte>)&ISteamApps_BIsTimedTrial;
        VTable.SetDlcContext = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, byte>)&ISteamApps_SetDlcContext;
        VTable.GetNumBetas = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, IntPtr, int>)&ISteamApps_GetNumBetas;
        VTable.GetBetaInfo = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, IntPtr, IntPtr, int, IntPtr, int, byte>)&ISteamApps_GetBetaInfo;
        VTable.SetActiveBeta = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, byte>)&ISteamApps_SetActiveBeta;
    }

    public static IntPtr Create(ISteamAppsLogic logic)
    {
        var handle = GCHandle.Alloc(logic);
        var ptr = Marshal.AllocHGlobal(IntPtr.Size * 2);
        *(IntPtr*)ptr = VTablePtr;
        *(IntPtr*)((byte*)ptr + IntPtr.Size) = GCHandle.ToIntPtr(handle);
        return ptr;
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamApps_BIsSubscribed(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamAppsLogic)handle.Target!;
        return logic.BIsSubscribed();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamApps_BIsLowViolence(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamAppsLogic)handle.Target!;
        return logic.BIsLowViolence();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamApps_BIsCybercafe(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamAppsLogic)handle.Target!;
        return logic.BIsCybercafe();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamApps_BIsVACBanned(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamAppsLogic)handle.Target!;
        return logic.BIsVACBanned();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static IntPtr ISteamApps_GetCurrentGameLanguage(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamAppsLogic)handle.Target!;
        return logic.GetCurrentGameLanguage();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static IntPtr ISteamApps_GetAvailableGameLanguages(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamAppsLogic)handle.Target!;
        return logic.GetAvailableGameLanguages();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamApps_BIsSubscribedApp(IntPtr pThis, int appID)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamAppsLogic)handle.Target!;
        return logic.BIsSubscribedApp(appID);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamApps_BIsDlcInstalled(IntPtr pThis, int appID)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamAppsLogic)handle.Target!;
        return logic.BIsDlcInstalled(appID);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static uint ISteamApps_GetEarliestPurchaseUnixTime(IntPtr pThis, int nAppID)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamAppsLogic)handle.Target!;
        return logic.GetEarliestPurchaseUnixTime(nAppID);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamApps_BIsSubscribedFromFreeWeekend(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamAppsLogic)handle.Target!;
        return logic.BIsSubscribedFromFreeWeekend();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamApps_GetDLCCount(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamAppsLogic)handle.Target!;
        return logic.GetDLCCount();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamApps_BGetDLCDataByIndex(IntPtr pThis, int iDLC, IntPtr pAppID, IntPtr pbAvailable, IntPtr pchName, int cchNameBufferSize)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamAppsLogic)handle.Target!;
        return logic.BGetDLCDataByIndex(iDLC, pAppID, pbAvailable, pchName, cchNameBufferSize);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamApps_InstallDLC(IntPtr pThis, int nAppID)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamAppsLogic)handle.Target!;
        return logic.InstallDLC(nAppID);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamApps_UninstallDLC(IntPtr pThis, int nAppID)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamAppsLogic)handle.Target!;
        return logic.UninstallDLC(nAppID);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamApps_RequestAppProofOfPurchaseKey(IntPtr pThis, int nAppID)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamAppsLogic)handle.Target!;
        return logic.RequestAppProofOfPurchaseKey(nAppID);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamApps_GetCurrentBetaName(IntPtr pThis, IntPtr pchName, int cchNameBufferSize)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamAppsLogic)handle.Target!;
        return logic.GetCurrentBetaName(pchName, cchNameBufferSize);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamApps_MarkContentCorrupt(IntPtr pThis, byte bMissingFilesOnly)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamAppsLogic)handle.Target!;
        return logic.MarkContentCorrupt(bMissingFilesOnly);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static uint ISteamApps_GetInstalledDepots(IntPtr pThis, int appID, IntPtr pvecDepots, uint cMaxDepots)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamAppsLogic)handle.Target!;
        return logic.GetInstalledDepots(appID, pvecDepots, cMaxDepots);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static uint ISteamApps_GetAppInstallDir(IntPtr pThis, int appID, IntPtr pchFolder, uint cchFolderBufferSize)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamAppsLogic)handle.Target!;
        return logic.GetAppInstallDir(appID, pchFolder, cchFolderBufferSize);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamApps_BIsAppInstalled(IntPtr pThis, int appID)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamAppsLogic)handle.Target!;
        return logic.BIsAppInstalled(appID);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamApps_GetAppOwner(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamAppsLogic)handle.Target!;
        return logic.GetAppOwner();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static IntPtr ISteamApps_GetLaunchQueryParam(IntPtr pThis, IntPtr pchKey)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamAppsLogic)handle.Target!;
        return logic.GetLaunchQueryParam(pchKey);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamApps_GetDlcDownloadProgress(IntPtr pThis, int nAppID, IntPtr punBytesDownloaded, IntPtr punBytesTotal)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamAppsLogic)handle.Target!;
        return logic.GetDlcDownloadProgress(nAppID, punBytesDownloaded, punBytesTotal);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamApps_GetAppBuildId(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamAppsLogic)handle.Target!;
        return logic.GetAppBuildId();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamApps_RequestAllProofOfPurchaseKeys(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamAppsLogic)handle.Target!;
        return logic.RequestAllProofOfPurchaseKeys();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamApps_GetFileDetails(IntPtr pThis, IntPtr pszFileName)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamAppsLogic)handle.Target!;
        return logic.GetFileDetails(pszFileName);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamApps_GetLaunchCommandLine(IntPtr pThis, IntPtr pszCommandLine, int cubCommandLine)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamAppsLogic)handle.Target!;
        return logic.GetLaunchCommandLine(pszCommandLine, cubCommandLine);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamApps_BIsSubscribedFromFamilySharing(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamAppsLogic)handle.Target!;
        return logic.BIsSubscribedFromFamilySharing();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamApps_BIsTimedTrial(IntPtr pThis, IntPtr punSecondsAllowed, IntPtr punSecondsPlayed)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamAppsLogic)handle.Target!;
        return logic.BIsTimedTrial(punSecondsAllowed, punSecondsPlayed);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamApps_SetDlcContext(IntPtr pThis, int nAppID)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamAppsLogic)handle.Target!;
        return logic.SetDlcContext(nAppID);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamApps_GetNumBetas(IntPtr pThis, IntPtr pnAvailable, IntPtr pnPrivate)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamAppsLogic)handle.Target!;
        return logic.GetNumBetas(pnAvailable, pnPrivate);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamApps_GetBetaInfo(IntPtr pThis, int iBetaIndex, IntPtr punFlags, IntPtr punBuildID, IntPtr pchBetaName, int cchBetaName, IntPtr pchDescription, int cchDescription)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamAppsLogic)handle.Target!;
        return logic.GetBetaInfo(iBetaIndex, punFlags, punBuildID, pchBetaName, cchBetaName, pchDescription, cchDescription);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamApps_SetActiveBeta(IntPtr pThis, IntPtr pchBetaName)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamAppsLogic)handle.Target!;
        return logic.SetActiveBeta(pchBetaName);
    }
}

public unsafe class ISteamNetworkingShim
{
    public static ISteamNetworkingVTable VTable;
    public static IntPtr VTablePtr;

    static ISteamNetworkingShim()
    {
        VTablePtr = (IntPtr)Unsafe.AsPointer(ref VTable);
        VTable.SendP2PPacket = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, IntPtr, uint, int, int, byte>)&ISteamNetworking_SendP2PPacket;
        VTable.IsP2PPacketAvailable = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, int, byte>)&ISteamNetworking_IsP2PPacketAvailable;
        VTable.ReadP2PPacket = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, uint, IntPtr, IntPtr, int, byte>)&ISteamNetworking_ReadP2PPacket;
        VTable.AcceptP2PSessionWithUser = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, byte>)&ISteamNetworking_AcceptP2PSessionWithUser;
        VTable.CloseP2PSessionWithUser = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, byte>)&ISteamNetworking_CloseP2PSessionWithUser;
        VTable.CloseP2PChannelWithUser = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, int, byte>)&ISteamNetworking_CloseP2PChannelWithUser;
        VTable.GetP2PSessionState = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, IntPtr, byte>)&ISteamNetworking_GetP2PSessionState;
        VTable.AllowP2PPacketRelay = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, byte, byte>)&ISteamNetworking_AllowP2PPacketRelay;
        VTable.CreateListenSocket = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, int, byte, int>)&ISteamNetworking_CreateListenSocket;
        VTable.CreateP2PConnectionSocket = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, int, int, byte, int>)&ISteamNetworking_CreateP2PConnectionSocket;
        VTable.CreateConnectionSocket = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, int, int>)&ISteamNetworking_CreateConnectionSocket;
        VTable.DestroySocket = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, byte, byte>)&ISteamNetworking_DestroySocket;
        VTable.DestroyListenSocket = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, byte, byte>)&ISteamNetworking_DestroyListenSocket;
        VTable.SendDataOnSocket = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, uint, byte, byte>)&ISteamNetworking_SendDataOnSocket;
        VTable.IsDataAvailableOnSocket = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, byte>)&ISteamNetworking_IsDataAvailableOnSocket;
        VTable.RetrieveDataFromSocket = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, uint, IntPtr, byte>)&ISteamNetworking_RetrieveDataFromSocket;
        VTable.IsDataAvailable = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, IntPtr, byte>)&ISteamNetworking_IsDataAvailable;
        VTable.RetrieveData = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, uint, IntPtr, IntPtr, byte>)&ISteamNetworking_RetrieveData;
        VTable.GetSocketInfo = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, IntPtr, IntPtr, IntPtr, byte>)&ISteamNetworking_GetSocketInfo;
        VTable.GetListenSocketInfo = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, IntPtr, byte>)&ISteamNetworking_GetListenSocketInfo;
        VTable.GetSocketConnectionType = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int>)&ISteamNetworking_GetSocketConnectionType;
        VTable.GetMaxPacketSize = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int>)&ISteamNetworking_GetMaxPacketSize;
    }

    public static IntPtr Create(ISteamNetworkingLogic logic)
    {
        var handle = GCHandle.Alloc(logic);
        var ptr = Marshal.AllocHGlobal(IntPtr.Size * 2);
        *(IntPtr*)ptr = VTablePtr;
        *(IntPtr*)((byte*)ptr + IntPtr.Size) = GCHandle.ToIntPtr(handle);
        return ptr;
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamNetworking_SendP2PPacket(IntPtr pThis, ulong steamIDRemote, IntPtr pubData, uint cubData, int eP2PSendType, int nChannel)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingLogic)handle.Target!;
        return logic.SendP2PPacket(steamIDRemote, pubData, cubData, eP2PSendType, nChannel);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamNetworking_IsP2PPacketAvailable(IntPtr pThis, IntPtr pcubMsgSize, int nChannel)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingLogic)handle.Target!;
        return logic.IsP2PPacketAvailable(pcubMsgSize, nChannel);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamNetworking_ReadP2PPacket(IntPtr pThis, IntPtr pubDest, uint cubDest, IntPtr pcubMsgSize, IntPtr psteamIDRemote, int nChannel)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingLogic)handle.Target!;
        return logic.ReadP2PPacket(pubDest, cubDest, pcubMsgSize, psteamIDRemote, nChannel);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamNetworking_AcceptP2PSessionWithUser(IntPtr pThis, ulong steamIDRemote)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingLogic)handle.Target!;
        return logic.AcceptP2PSessionWithUser(steamIDRemote);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamNetworking_CloseP2PSessionWithUser(IntPtr pThis, ulong steamIDRemote)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingLogic)handle.Target!;
        return logic.CloseP2PSessionWithUser(steamIDRemote);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamNetworking_CloseP2PChannelWithUser(IntPtr pThis, ulong steamIDRemote, int nChannel)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingLogic)handle.Target!;
        return logic.CloseP2PChannelWithUser(steamIDRemote, nChannel);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamNetworking_GetP2PSessionState(IntPtr pThis, ulong steamIDRemote, IntPtr pConnectionState)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingLogic)handle.Target!;
        return logic.GetP2PSessionState(steamIDRemote, pConnectionState);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamNetworking_AllowP2PPacketRelay(IntPtr pThis, byte bAllow)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingLogic)handle.Target!;
        return logic.AllowP2PPacketRelay(bAllow);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamNetworking_CreateListenSocket(IntPtr pThis, int nVirtualP2PPort, int nIP, int nPort, byte bAllowUseOfPacketRelay)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingLogic)handle.Target!;
        return logic.CreateListenSocket(nVirtualP2PPort, nIP, nPort, bAllowUseOfPacketRelay);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamNetworking_CreateP2PConnectionSocket(IntPtr pThis, ulong steamIDTarget, int nVirtualPort, int nTimeoutSec, byte bAllowUseOfPacketRelay)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingLogic)handle.Target!;
        return logic.CreateP2PConnectionSocket(steamIDTarget, nVirtualPort, nTimeoutSec, bAllowUseOfPacketRelay);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamNetworking_CreateConnectionSocket(IntPtr pThis, int nIP, int nPort, int nTimeoutSec)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingLogic)handle.Target!;
        return logic.CreateConnectionSocket(nIP, nPort, nTimeoutSec);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamNetworking_DestroySocket(IntPtr pThis, int hSocket, byte bNotifyRemoteEnd)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingLogic)handle.Target!;
        return logic.DestroySocket(hSocket, bNotifyRemoteEnd);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamNetworking_DestroyListenSocket(IntPtr pThis, int hSocket, byte bNotifyRemoteEnd)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingLogic)handle.Target!;
        return logic.DestroyListenSocket(hSocket, bNotifyRemoteEnd);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamNetworking_SendDataOnSocket(IntPtr pThis, int hSocket, IntPtr pubData, uint cubData, byte bReliable)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingLogic)handle.Target!;
        return logic.SendDataOnSocket(hSocket, pubData, cubData, bReliable);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamNetworking_IsDataAvailableOnSocket(IntPtr pThis, int hSocket, IntPtr pcubMsgSize)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingLogic)handle.Target!;
        return logic.IsDataAvailableOnSocket(hSocket, pcubMsgSize);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamNetworking_RetrieveDataFromSocket(IntPtr pThis, int hSocket, IntPtr pubDest, uint cubDest, IntPtr pcubMsgSize)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingLogic)handle.Target!;
        return logic.RetrieveDataFromSocket(hSocket, pubDest, cubDest, pcubMsgSize);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamNetworking_IsDataAvailable(IntPtr pThis, int hListenSocket, IntPtr pcubMsgSize, IntPtr phSocket)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingLogic)handle.Target!;
        return logic.IsDataAvailable(hListenSocket, pcubMsgSize, phSocket);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamNetworking_RetrieveData(IntPtr pThis, int hListenSocket, IntPtr pubDest, uint cubDest, IntPtr pcubMsgSize, IntPtr phSocket)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingLogic)handle.Target!;
        return logic.RetrieveData(hListenSocket, pubDest, cubDest, pcubMsgSize, phSocket);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamNetworking_GetSocketInfo(IntPtr pThis, int hSocket, IntPtr pSteamIDRemote, IntPtr peSocketStatus, IntPtr punIPRemote, IntPtr punPortRemote)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingLogic)handle.Target!;
        return logic.GetSocketInfo(hSocket, pSteamIDRemote, peSocketStatus, punIPRemote, punPortRemote);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamNetworking_GetListenSocketInfo(IntPtr pThis, int hListenSocket, IntPtr pnIP, IntPtr pnPort)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingLogic)handle.Target!;
        return logic.GetListenSocketInfo(hListenSocket, pnIP, pnPort);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamNetworking_GetSocketConnectionType(IntPtr pThis, int hSocket)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingLogic)handle.Target!;
        return logic.GetSocketConnectionType(hSocket);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamNetworking_GetMaxPacketSize(IntPtr pThis, int hSocket)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingLogic)handle.Target!;
        return logic.GetMaxPacketSize(hSocket);
    }
}

public unsafe class ISteamScreenshotsShim
{
    public static ISteamScreenshotsVTable VTable;
    public static IntPtr VTablePtr;

    static ISteamScreenshotsShim()
    {
        VTablePtr = (IntPtr)Unsafe.AsPointer(ref VTable);
        VTable.WriteScreenshot = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, uint, int, int, int>)&ISteamScreenshots_WriteScreenshot;
        VTable.AddScreenshotToLibrary = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, IntPtr, int, int, int>)&ISteamScreenshots_AddScreenshotToLibrary;
        VTable.TriggerScreenshot = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, void>)&ISteamScreenshots_TriggerScreenshot;
        VTable.HookScreenshots = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, byte, void>)&ISteamScreenshots_HookScreenshots;
        VTable.SetLocation = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, byte>)&ISteamScreenshots_SetLocation;
        VTable.TagUser = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, ulong, byte>)&ISteamScreenshots_TagUser;
        VTable.TagPublishedFile = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, byte>)&ISteamScreenshots_TagPublishedFile;
        VTable.IsScreenshotsHooked = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, byte>)&ISteamScreenshots_IsScreenshotsHooked;
        VTable.AddVRScreenshotToLibrary = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, IntPtr, int>)&ISteamScreenshots_AddVRScreenshotToLibrary;
    }

    public static IntPtr Create(ISteamScreenshotsLogic logic)
    {
        var handle = GCHandle.Alloc(logic);
        var ptr = Marshal.AllocHGlobal(IntPtr.Size * 2);
        *(IntPtr*)ptr = VTablePtr;
        *(IntPtr*)((byte*)ptr + IntPtr.Size) = GCHandle.ToIntPtr(handle);
        return ptr;
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamScreenshots_WriteScreenshot(IntPtr pThis, IntPtr pubRGB, uint cubRGB, int nWidth, int nHeight)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamScreenshotsLogic)handle.Target!;
        return logic.WriteScreenshot(pubRGB, cubRGB, nWidth, nHeight);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamScreenshots_AddScreenshotToLibrary(IntPtr pThis, IntPtr pchFilename, IntPtr pchThumbnailFilename, int nWidth, int nHeight)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamScreenshotsLogic)handle.Target!;
        return logic.AddScreenshotToLibrary(pchFilename, pchThumbnailFilename, nWidth, nHeight);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamScreenshots_TriggerScreenshot(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamScreenshotsLogic)handle.Target!;
        return logic.TriggerScreenshot();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamScreenshots_HookScreenshots(IntPtr pThis, byte bHook)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamScreenshotsLogic)handle.Target!;
        return logic.HookScreenshots(bHook);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamScreenshots_SetLocation(IntPtr pThis, int hScreenshot, IntPtr pchLocation)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamScreenshotsLogic)handle.Target!;
        return logic.SetLocation(hScreenshot, pchLocation);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamScreenshots_TagUser(IntPtr pThis, int hScreenshot, ulong steamID)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamScreenshotsLogic)handle.Target!;
        return logic.TagUser(hScreenshot, steamID);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamScreenshots_TagPublishedFile(IntPtr pThis, int hScreenshot, int unPublishedFileID)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamScreenshotsLogic)handle.Target!;
        return logic.TagPublishedFile(hScreenshot, unPublishedFileID);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamScreenshots_IsScreenshotsHooked(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamScreenshotsLogic)handle.Target!;
        return logic.IsScreenshotsHooked();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamScreenshots_AddVRScreenshotToLibrary(IntPtr pThis, int eType, IntPtr pchFilename, IntPtr pchVRFilename)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamScreenshotsLogic)handle.Target!;
        return logic.AddVRScreenshotToLibrary(eType, pchFilename, pchVRFilename);
    }
}

public unsafe class ISteamMusicShim
{
    public static ISteamMusicVTable VTable;
    public static IntPtr VTablePtr;

    static ISteamMusicShim()
    {
        VTablePtr = (IntPtr)Unsafe.AsPointer(ref VTable);
        VTable.BIsEnabled = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, byte>)&ISteamMusic_BIsEnabled;
        VTable.BIsPlaying = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, byte>)&ISteamMusic_BIsPlaying;
        VTable.GetPlaybackStatus = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int>)&ISteamMusic_GetPlaybackStatus;
        VTable.Play = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, void>)&ISteamMusic_Play;
        VTable.Pause = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, void>)&ISteamMusic_Pause;
        VTable.PlayPrevious = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, void>)&ISteamMusic_PlayPrevious;
        VTable.PlayNext = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, void>)&ISteamMusic_PlayNext;
        VTable.SetVolume = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, void>)&ISteamMusic_SetVolume;
        VTable.GetVolume = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int>)&ISteamMusic_GetVolume;
    }

    public static IntPtr Create(ISteamMusicLogic logic)
    {
        var handle = GCHandle.Alloc(logic);
        var ptr = Marshal.AllocHGlobal(IntPtr.Size * 2);
        *(IntPtr*)ptr = VTablePtr;
        *(IntPtr*)((byte*)ptr + IntPtr.Size) = GCHandle.ToIntPtr(handle);
        return ptr;
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamMusic_BIsEnabled(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamMusicLogic)handle.Target!;
        return logic.BIsEnabled();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamMusic_BIsPlaying(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamMusicLogic)handle.Target!;
        return logic.BIsPlaying();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamMusic_GetPlaybackStatus(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamMusicLogic)handle.Target!;
        return logic.GetPlaybackStatus();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamMusic_Play(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamMusicLogic)handle.Target!;
        return logic.Play();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamMusic_Pause(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamMusicLogic)handle.Target!;
        return logic.Pause();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamMusic_PlayPrevious(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamMusicLogic)handle.Target!;
        return logic.PlayPrevious();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamMusic_PlayNext(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamMusicLogic)handle.Target!;
        return logic.PlayNext();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamMusic_SetVolume(IntPtr pThis, int flVolume)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamMusicLogic)handle.Target!;
        return logic.SetVolume(flVolume);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamMusic_GetVolume(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamMusicLogic)handle.Target!;
        return logic.GetVolume();
    }
}

public unsafe class ISteamHTTPShim
{
    public static ISteamHTTPVTable VTable;
    public static IntPtr VTablePtr;

    static ISteamHTTPShim()
    {
        VTablePtr = (IntPtr)Unsafe.AsPointer(ref VTable);
        VTable.CreateHTTPRequest = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, uint>)&ISteamHTTP_CreateHTTPRequest;
        VTable.SetHTTPRequestContextValue = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, ulong, byte>)&ISteamHTTP_SetHTTPRequestContextValue;
        VTable.SetHTTPRequestNetworkActivityTimeout = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, uint, byte>)&ISteamHTTP_SetHTTPRequestNetworkActivityTimeout;
        VTable.SetHTTPRequestHeaderValue = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, IntPtr, IntPtr, byte>)&ISteamHTTP_SetHTTPRequestHeaderValue;
        VTable.SetHTTPRequestGetOrPostParameter = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, IntPtr, IntPtr, byte>)&ISteamHTTP_SetHTTPRequestGetOrPostParameter;
        VTable.SendHTTPRequest = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, IntPtr, byte>)&ISteamHTTP_SendHTTPRequest;
        VTable.SendHTTPRequestAndStreamResponse = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, IntPtr, byte>)&ISteamHTTP_SendHTTPRequestAndStreamResponse;
        VTable.DeferHTTPRequest = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, byte>)&ISteamHTTP_DeferHTTPRequest;
        VTable.PrioritizeHTTPRequest = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, byte>)&ISteamHTTP_PrioritizeHTTPRequest;
        VTable.GetHTTPResponseHeaderSize = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, IntPtr, IntPtr, byte>)&ISteamHTTP_GetHTTPResponseHeaderSize;
        VTable.GetHTTPResponseHeaderValue = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, IntPtr, IntPtr, uint, byte>)&ISteamHTTP_GetHTTPResponseHeaderValue;
        VTable.GetHTTPResponseBodySize = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, IntPtr, byte>)&ISteamHTTP_GetHTTPResponseBodySize;
        VTable.GetHTTPResponseBodyData = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, IntPtr, uint, byte>)&ISteamHTTP_GetHTTPResponseBodyData;
        VTable.GetHTTPStreamingResponseBodyData = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, uint, IntPtr, uint, byte>)&ISteamHTTP_GetHTTPStreamingResponseBodyData;
        VTable.ReleaseHTTPRequest = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, byte>)&ISteamHTTP_ReleaseHTTPRequest;
        VTable.GetHTTPDownloadProgressPct = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, IntPtr, byte>)&ISteamHTTP_GetHTTPDownloadProgressPct;
        VTable.SetHTTPRequestRawPostBody = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, IntPtr, IntPtr, uint, byte>)&ISteamHTTP_SetHTTPRequestRawPostBody;
        VTable.CreateCookieContainer = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, byte, uint>)&ISteamHTTP_CreateCookieContainer;
        VTable.ReleaseCookieContainer = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, byte>)&ISteamHTTP_ReleaseCookieContainer;
        VTable.SetCookie = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, IntPtr, IntPtr, IntPtr, byte>)&ISteamHTTP_SetCookie;
        VTable.SetHTTPRequestCookieContainer = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, uint, byte>)&ISteamHTTP_SetHTTPRequestCookieContainer;
        VTable.SetHTTPRequestUserAgentInfo = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, IntPtr, byte>)&ISteamHTTP_SetHTTPRequestUserAgentInfo;
        VTable.SetHTTPRequestRequiresVerifiedCertificate = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, byte, byte>)&ISteamHTTP_SetHTTPRequestRequiresVerifiedCertificate;
        VTable.SetHTTPRequestAbsoluteTimeoutMS = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, uint, byte>)&ISteamHTTP_SetHTTPRequestAbsoluteTimeoutMS;
        VTable.GetHTTPRequestWasTimedOut = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, IntPtr, byte>)&ISteamHTTP_GetHTTPRequestWasTimedOut;
    }

    public static IntPtr Create(ISteamHTTPLogic logic)
    {
        var handle = GCHandle.Alloc(logic);
        var ptr = Marshal.AllocHGlobal(IntPtr.Size * 2);
        *(IntPtr*)ptr = VTablePtr;
        *(IntPtr*)((byte*)ptr + IntPtr.Size) = GCHandle.ToIntPtr(handle);
        return ptr;
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static uint ISteamHTTP_CreateHTTPRequest(IntPtr pThis, int eHTTPRequestMethod, IntPtr pchAbsoluteURL)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamHTTPLogic)handle.Target!;
        return logic.CreateHTTPRequest(eHTTPRequestMethod, pchAbsoluteURL);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamHTTP_SetHTTPRequestContextValue(IntPtr pThis, uint hRequest, ulong ulContextValue)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamHTTPLogic)handle.Target!;
        return logic.SetHTTPRequestContextValue(hRequest, ulContextValue);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamHTTP_SetHTTPRequestNetworkActivityTimeout(IntPtr pThis, uint hRequest, uint unTimeoutSeconds)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamHTTPLogic)handle.Target!;
        return logic.SetHTTPRequestNetworkActivityTimeout(hRequest, unTimeoutSeconds);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamHTTP_SetHTTPRequestHeaderValue(IntPtr pThis, uint hRequest, IntPtr pchHeaderName, IntPtr pchHeaderValue)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamHTTPLogic)handle.Target!;
        return logic.SetHTTPRequestHeaderValue(hRequest, pchHeaderName, pchHeaderValue);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamHTTP_SetHTTPRequestGetOrPostParameter(IntPtr pThis, uint hRequest, IntPtr pchParamName, IntPtr pchParamValue)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamHTTPLogic)handle.Target!;
        return logic.SetHTTPRequestGetOrPostParameter(hRequest, pchParamName, pchParamValue);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamHTTP_SendHTTPRequest(IntPtr pThis, uint hRequest, IntPtr pCallHandle)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamHTTPLogic)handle.Target!;
        return logic.SendHTTPRequest(hRequest, pCallHandle);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamHTTP_SendHTTPRequestAndStreamResponse(IntPtr pThis, uint hRequest, IntPtr pCallHandle)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamHTTPLogic)handle.Target!;
        return logic.SendHTTPRequestAndStreamResponse(hRequest, pCallHandle);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamHTTP_DeferHTTPRequest(IntPtr pThis, uint hRequest)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamHTTPLogic)handle.Target!;
        return logic.DeferHTTPRequest(hRequest);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamHTTP_PrioritizeHTTPRequest(IntPtr pThis, uint hRequest)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamHTTPLogic)handle.Target!;
        return logic.PrioritizeHTTPRequest(hRequest);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamHTTP_GetHTTPResponseHeaderSize(IntPtr pThis, uint hRequest, IntPtr pchHeaderName, IntPtr unResponseHeaderSize)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamHTTPLogic)handle.Target!;
        return logic.GetHTTPResponseHeaderSize(hRequest, pchHeaderName, unResponseHeaderSize);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamHTTP_GetHTTPResponseHeaderValue(IntPtr pThis, uint hRequest, IntPtr pchHeaderName, IntPtr pHeaderValueBuffer, uint unBufferSize)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamHTTPLogic)handle.Target!;
        return logic.GetHTTPResponseHeaderValue(hRequest, pchHeaderName, pHeaderValueBuffer, unBufferSize);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamHTTP_GetHTTPResponseBodySize(IntPtr pThis, uint hRequest, IntPtr unBodySize)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamHTTPLogic)handle.Target!;
        return logic.GetHTTPResponseBodySize(hRequest, unBodySize);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamHTTP_GetHTTPResponseBodyData(IntPtr pThis, uint hRequest, IntPtr pBodyDataBuffer, uint unBufferSize)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamHTTPLogic)handle.Target!;
        return logic.GetHTTPResponseBodyData(hRequest, pBodyDataBuffer, unBufferSize);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamHTTP_GetHTTPStreamingResponseBodyData(IntPtr pThis, uint hRequest, uint cOffset, IntPtr pBodyDataBuffer, uint unBufferSize)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamHTTPLogic)handle.Target!;
        return logic.GetHTTPStreamingResponseBodyData(hRequest, cOffset, pBodyDataBuffer, unBufferSize);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamHTTP_ReleaseHTTPRequest(IntPtr pThis, uint hRequest)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamHTTPLogic)handle.Target!;
        return logic.ReleaseHTTPRequest(hRequest);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamHTTP_GetHTTPDownloadProgressPct(IntPtr pThis, uint hRequest, IntPtr pflPercentOut)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamHTTPLogic)handle.Target!;
        return logic.GetHTTPDownloadProgressPct(hRequest, pflPercentOut);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamHTTP_SetHTTPRequestRawPostBody(IntPtr pThis, uint hRequest, IntPtr pchContentType, IntPtr pubBody, uint unBodyLen)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamHTTPLogic)handle.Target!;
        return logic.SetHTTPRequestRawPostBody(hRequest, pchContentType, pubBody, unBodyLen);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static uint ISteamHTTP_CreateCookieContainer(IntPtr pThis, byte bAllowResponsesToModify)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamHTTPLogic)handle.Target!;
        return logic.CreateCookieContainer(bAllowResponsesToModify);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamHTTP_ReleaseCookieContainer(IntPtr pThis, uint hCookieContainer)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamHTTPLogic)handle.Target!;
        return logic.ReleaseCookieContainer(hCookieContainer);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamHTTP_SetCookie(IntPtr pThis, uint hCookieContainer, IntPtr pchHost, IntPtr pchUrl, IntPtr pchCookie)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamHTTPLogic)handle.Target!;
        return logic.SetCookie(hCookieContainer, pchHost, pchUrl, pchCookie);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamHTTP_SetHTTPRequestCookieContainer(IntPtr pThis, uint hRequest, uint hCookieContainer)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamHTTPLogic)handle.Target!;
        return logic.SetHTTPRequestCookieContainer(hRequest, hCookieContainer);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamHTTP_SetHTTPRequestUserAgentInfo(IntPtr pThis, uint hRequest, IntPtr pchUserAgentInfo)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamHTTPLogic)handle.Target!;
        return logic.SetHTTPRequestUserAgentInfo(hRequest, pchUserAgentInfo);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamHTTP_SetHTTPRequestRequiresVerifiedCertificate(IntPtr pThis, uint hRequest, byte bRequireVerifiedCertificate)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamHTTPLogic)handle.Target!;
        return logic.SetHTTPRequestRequiresVerifiedCertificate(hRequest, bRequireVerifiedCertificate);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamHTTP_SetHTTPRequestAbsoluteTimeoutMS(IntPtr pThis, uint hRequest, uint unMilliseconds)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamHTTPLogic)handle.Target!;
        return logic.SetHTTPRequestAbsoluteTimeoutMS(hRequest, unMilliseconds);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamHTTP_GetHTTPRequestWasTimedOut(IntPtr pThis, uint hRequest, IntPtr pbWasTimedOut)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamHTTPLogic)handle.Target!;
        return logic.GetHTTPRequestWasTimedOut(hRequest, pbWasTimedOut);
    }
}

public unsafe class ISteamInputShim
{
    public static ISteamInputVTable VTable;
    public static IntPtr VTablePtr;

    static ISteamInputShim()
    {
        VTablePtr = (IntPtr)Unsafe.AsPointer(ref VTable);
        VTable.Init = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, byte, byte>)&ISteamInput_Init;
        VTable.Shutdown = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, byte>)&ISteamInput_Shutdown;
        VTable.SetInputActionManifestFilePath = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, byte>)&ISteamInput_SetInputActionManifestFilePath;
        VTable.RunFrame = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, byte, void>)&ISteamInput_RunFrame;
        VTable.BWaitForData = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, byte, uint, byte>)&ISteamInput_BWaitForData;
        VTable.BNewDataAvailable = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, byte>)&ISteamInput_BNewDataAvailable;
        VTable.GetConnectedControllers = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, int>)&ISteamInput_GetConnectedControllers;
        VTable.EnableDeviceCallbacks = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, void>)&ISteamInput_EnableDeviceCallbacks;
        VTable.EnableActionEventCallbacks = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, void>)&ISteamInput_EnableActionEventCallbacks;
        VTable.GetActionSetHandle = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, int>)&ISteamInput_GetActionSetHandle;
        VTable.ActivateActionSet = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, void>)&ISteamInput_ActivateActionSet;
        VTable.GetCurrentActionSet = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int>)&ISteamInput_GetCurrentActionSet;
        VTable.ActivateActionSetLayer = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, void>)&ISteamInput_ActivateActionSetLayer;
        VTable.DeactivateActionSetLayer = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, void>)&ISteamInput_DeactivateActionSetLayer;
        VTable.DeactivateAllActionSetLayers = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, void>)&ISteamInput_DeactivateAllActionSetLayers;
        VTable.GetActiveActionSetLayers = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, int>)&ISteamInput_GetActiveActionSetLayers;
        VTable.GetDigitalActionHandle = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, int>)&ISteamInput_GetDigitalActionHandle;
        VTable.GetDigitalActionData = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, int>)&ISteamInput_GetDigitalActionData;
        VTable.GetDigitalActionOrigins = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, int, IntPtr, int>)&ISteamInput_GetDigitalActionOrigins;
        VTable.GetStringForDigitalActionName = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr>)&ISteamInput_GetStringForDigitalActionName;
        VTable.GetAnalogActionHandle = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, int>)&ISteamInput_GetAnalogActionHandle;
        VTable.GetAnalogActionData = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, int>)&ISteamInput_GetAnalogActionData;
        VTable.GetAnalogActionOrigins = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, int, IntPtr, int>)&ISteamInput_GetAnalogActionOrigins;
        VTable.GetGlyphPNGForActionOrigin = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, uint, IntPtr>)&ISteamInput_GetGlyphPNGForActionOrigin;
        VTable.GetGlyphSVGForActionOrigin = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, uint, IntPtr>)&ISteamInput_GetGlyphSVGForActionOrigin;
        VTable.GetGlyphForActionOrigin_Legacy = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr>)&ISteamInput_GetGlyphForActionOrigin_Legacy;
        VTable.GetStringForActionOrigin = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr>)&ISteamInput_GetStringForActionOrigin;
        VTable.GetStringForAnalogActionName = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr>)&ISteamInput_GetStringForAnalogActionName;
        VTable.StopAnalogActionMomentum = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, void>)&ISteamInput_StopAnalogActionMomentum;
        VTable.GetMotionData = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int>)&ISteamInput_GetMotionData;
        VTable.TriggerVibration = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, int, void>)&ISteamInput_TriggerVibration;
        VTable.TriggerVibrationExtended = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, int, int, int, void>)&ISteamInput_TriggerVibrationExtended;
        VTable.TriggerSimpleHapticEvent = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, int, int, int, int, void>)&ISteamInput_TriggerSimpleHapticEvent;
        VTable.SetLEDColor = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, int, int, int, void>)&ISteamInput_SetLEDColor;
        VTable.Legacy_TriggerHapticPulse = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, int, void>)&ISteamInput_Legacy_TriggerHapticPulse;
        VTable.Legacy_TriggerRepeatedHapticPulse = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, int, int, int, int, void>)&ISteamInput_Legacy_TriggerRepeatedHapticPulse;
        VTable.ShowBindingPanel = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, byte>)&ISteamInput_ShowBindingPanel;
        VTable.GetInputTypeForHandle = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int>)&ISteamInput_GetInputTypeForHandle;
        VTable.GetControllerForGamepadIndex = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int>)&ISteamInput_GetControllerForGamepadIndex;
        VTable.GetGamepadIndexForController = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int>)&ISteamInput_GetGamepadIndexForController;
        VTable.GetStringForXboxOrigin = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr>)&ISteamInput_GetStringForXboxOrigin;
        VTable.GetGlyphForXboxOrigin = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr>)&ISteamInput_GetGlyphForXboxOrigin;
        VTable.GetActionOriginFromXboxOrigin = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, int>)&ISteamInput_GetActionOriginFromXboxOrigin;
        VTable.TranslateActionOrigin = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, int>)&ISteamInput_TranslateActionOrigin;
        VTable.GetDeviceBindingRevision = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, IntPtr, byte>)&ISteamInput_GetDeviceBindingRevision;
        VTable.GetRemotePlaySessionID = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, uint>)&ISteamInput_GetRemotePlaySessionID;
        VTable.GetSessionInputConfigurationSettings = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int>)&ISteamInput_GetSessionInputConfigurationSettings;
        VTable.SetDualSenseTriggerEffect = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, void>)&ISteamInput_SetDualSenseTriggerEffect;
    }

    public static IntPtr Create(ISteamInputLogic logic)
    {
        var handle = GCHandle.Alloc(logic);
        var ptr = Marshal.AllocHGlobal(IntPtr.Size * 2);
        *(IntPtr*)ptr = VTablePtr;
        *(IntPtr*)((byte*)ptr + IntPtr.Size) = GCHandle.ToIntPtr(handle);
        return ptr;
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamInput_Init(IntPtr pThis, byte bExplicitlyCallRunFrame)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInputLogic)handle.Target!;
        return logic.Init(bExplicitlyCallRunFrame);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamInput_Shutdown(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInputLogic)handle.Target!;
        return logic.Shutdown();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamInput_SetInputActionManifestFilePath(IntPtr pThis, IntPtr pchInputActionManifestAbsolutePath)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInputLogic)handle.Target!;
        return logic.SetInputActionManifestFilePath(pchInputActionManifestAbsolutePath);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamInput_RunFrame(IntPtr pThis, byte bReservedValue)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInputLogic)handle.Target!;
        return logic.RunFrame(bReservedValue);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamInput_BWaitForData(IntPtr pThis, byte bWaitForever, uint unTimeout)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInputLogic)handle.Target!;
        return logic.BWaitForData(bWaitForever, unTimeout);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamInput_BNewDataAvailable(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInputLogic)handle.Target!;
        return logic.BNewDataAvailable();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamInput_GetConnectedControllers(IntPtr pThis, IntPtr handlesOut)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInputLogic)handle.Target!;
        return logic.GetConnectedControllers(handlesOut);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamInput_EnableDeviceCallbacks(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInputLogic)handle.Target!;
        return logic.EnableDeviceCallbacks();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamInput_EnableActionEventCallbacks(IntPtr pThis, int pCallback)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInputLogic)handle.Target!;
        return logic.EnableActionEventCallbacks(pCallback);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamInput_GetActionSetHandle(IntPtr pThis, IntPtr pszActionSetName)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInputLogic)handle.Target!;
        return logic.GetActionSetHandle(pszActionSetName);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamInput_ActivateActionSet(IntPtr pThis, int inputHandle, int actionSetHandle)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInputLogic)handle.Target!;
        return logic.ActivateActionSet(inputHandle, actionSetHandle);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamInput_GetCurrentActionSet(IntPtr pThis, int inputHandle)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInputLogic)handle.Target!;
        return logic.GetCurrentActionSet(inputHandle);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamInput_ActivateActionSetLayer(IntPtr pThis, int inputHandle, int actionSetLayerHandle)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInputLogic)handle.Target!;
        return logic.ActivateActionSetLayer(inputHandle, actionSetLayerHandle);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamInput_DeactivateActionSetLayer(IntPtr pThis, int inputHandle, int actionSetLayerHandle)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInputLogic)handle.Target!;
        return logic.DeactivateActionSetLayer(inputHandle, actionSetLayerHandle);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamInput_DeactivateAllActionSetLayers(IntPtr pThis, int inputHandle)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInputLogic)handle.Target!;
        return logic.DeactivateAllActionSetLayers(inputHandle);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamInput_GetActiveActionSetLayers(IntPtr pThis, int inputHandle, IntPtr handlesOut)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInputLogic)handle.Target!;
        return logic.GetActiveActionSetLayers(inputHandle, handlesOut);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamInput_GetDigitalActionHandle(IntPtr pThis, IntPtr pszActionName)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInputLogic)handle.Target!;
        return logic.GetDigitalActionHandle(pszActionName);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamInput_GetDigitalActionData(IntPtr pThis, int inputHandle, int digitalActionHandle)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInputLogic)handle.Target!;
        return logic.GetDigitalActionData(inputHandle, digitalActionHandle);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamInput_GetDigitalActionOrigins(IntPtr pThis, int inputHandle, int actionSetHandle, int digitalActionHandle, IntPtr originsOut)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInputLogic)handle.Target!;
        return logic.GetDigitalActionOrigins(inputHandle, actionSetHandle, digitalActionHandle, originsOut);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static IntPtr ISteamInput_GetStringForDigitalActionName(IntPtr pThis, int eActionHandle)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInputLogic)handle.Target!;
        return logic.GetStringForDigitalActionName(eActionHandle);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamInput_GetAnalogActionHandle(IntPtr pThis, IntPtr pszActionName)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInputLogic)handle.Target!;
        return logic.GetAnalogActionHandle(pszActionName);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamInput_GetAnalogActionData(IntPtr pThis, int inputHandle, int analogActionHandle)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInputLogic)handle.Target!;
        return logic.GetAnalogActionData(inputHandle, analogActionHandle);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamInput_GetAnalogActionOrigins(IntPtr pThis, int inputHandle, int actionSetHandle, int analogActionHandle, IntPtr originsOut)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInputLogic)handle.Target!;
        return logic.GetAnalogActionOrigins(inputHandle, actionSetHandle, analogActionHandle, originsOut);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static IntPtr ISteamInput_GetGlyphPNGForActionOrigin(IntPtr pThis, int eOrigin, int eSize, uint unFlags)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInputLogic)handle.Target!;
        return logic.GetGlyphPNGForActionOrigin(eOrigin, eSize, unFlags);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static IntPtr ISteamInput_GetGlyphSVGForActionOrigin(IntPtr pThis, int eOrigin, uint unFlags)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInputLogic)handle.Target!;
        return logic.GetGlyphSVGForActionOrigin(eOrigin, unFlags);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static IntPtr ISteamInput_GetGlyphForActionOrigin_Legacy(IntPtr pThis, int eOrigin)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInputLogic)handle.Target!;
        return logic.GetGlyphForActionOrigin_Legacy(eOrigin);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static IntPtr ISteamInput_GetStringForActionOrigin(IntPtr pThis, int eOrigin)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInputLogic)handle.Target!;
        return logic.GetStringForActionOrigin(eOrigin);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static IntPtr ISteamInput_GetStringForAnalogActionName(IntPtr pThis, int eActionHandle)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInputLogic)handle.Target!;
        return logic.GetStringForAnalogActionName(eActionHandle);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamInput_StopAnalogActionMomentum(IntPtr pThis, int inputHandle, int eAction)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInputLogic)handle.Target!;
        return logic.StopAnalogActionMomentum(inputHandle, eAction);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamInput_GetMotionData(IntPtr pThis, int inputHandle)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInputLogic)handle.Target!;
        return logic.GetMotionData(inputHandle);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamInput_TriggerVibration(IntPtr pThis, int inputHandle, int usLeftSpeed, int usRightSpeed)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInputLogic)handle.Target!;
        return logic.TriggerVibration(inputHandle, usLeftSpeed, usRightSpeed);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamInput_TriggerVibrationExtended(IntPtr pThis, int inputHandle, int usLeftSpeed, int usRightSpeed, int usLeftTriggerSpeed, int usRightTriggerSpeed)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInputLogic)handle.Target!;
        return logic.TriggerVibrationExtended(inputHandle, usLeftSpeed, usRightSpeed, usLeftTriggerSpeed, usRightTriggerSpeed);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamInput_TriggerSimpleHapticEvent(IntPtr pThis, int inputHandle, int eHapticLocation, int nIntensity, int nGainDB, int nOtherIntensity, int nOtherGainDB)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInputLogic)handle.Target!;
        return logic.TriggerSimpleHapticEvent(inputHandle, eHapticLocation, nIntensity, nGainDB, nOtherIntensity, nOtherGainDB);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamInput_SetLEDColor(IntPtr pThis, int inputHandle, int nColorR, int nColorG, int nColorB, int nFlags)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInputLogic)handle.Target!;
        return logic.SetLEDColor(inputHandle, nColorR, nColorG, nColorB, nFlags);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamInput_Legacy_TriggerHapticPulse(IntPtr pThis, int inputHandle, int eTargetPad, int usDurationMicroSec)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInputLogic)handle.Target!;
        return logic.Legacy_TriggerHapticPulse(inputHandle, eTargetPad, usDurationMicroSec);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamInput_Legacy_TriggerRepeatedHapticPulse(IntPtr pThis, int inputHandle, int eTargetPad, int usDurationMicroSec, int usOffMicroSec, int unRepeat, int nFlags)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInputLogic)handle.Target!;
        return logic.Legacy_TriggerRepeatedHapticPulse(inputHandle, eTargetPad, usDurationMicroSec, usOffMicroSec, unRepeat, nFlags);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamInput_ShowBindingPanel(IntPtr pThis, int inputHandle)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInputLogic)handle.Target!;
        return logic.ShowBindingPanel(inputHandle);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamInput_GetInputTypeForHandle(IntPtr pThis, int inputHandle)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInputLogic)handle.Target!;
        return logic.GetInputTypeForHandle(inputHandle);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamInput_GetControllerForGamepadIndex(IntPtr pThis, int nIndex)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInputLogic)handle.Target!;
        return logic.GetControllerForGamepadIndex(nIndex);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamInput_GetGamepadIndexForController(IntPtr pThis, int ulinputHandle)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInputLogic)handle.Target!;
        return logic.GetGamepadIndexForController(ulinputHandle);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static IntPtr ISteamInput_GetStringForXboxOrigin(IntPtr pThis, int eOrigin)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInputLogic)handle.Target!;
        return logic.GetStringForXboxOrigin(eOrigin);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static IntPtr ISteamInput_GetGlyphForXboxOrigin(IntPtr pThis, int eOrigin)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInputLogic)handle.Target!;
        return logic.GetGlyphForXboxOrigin(eOrigin);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamInput_GetActionOriginFromXboxOrigin(IntPtr pThis, int inputHandle, int eOrigin)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInputLogic)handle.Target!;
        return logic.GetActionOriginFromXboxOrigin(inputHandle, eOrigin);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamInput_TranslateActionOrigin(IntPtr pThis, int eDestinationInputType, int eSourceOrigin)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInputLogic)handle.Target!;
        return logic.TranslateActionOrigin(eDestinationInputType, eSourceOrigin);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamInput_GetDeviceBindingRevision(IntPtr pThis, int inputHandle, IntPtr pMajor, IntPtr pMinor)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInputLogic)handle.Target!;
        return logic.GetDeviceBindingRevision(inputHandle, pMajor, pMinor);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static uint ISteamInput_GetRemotePlaySessionID(IntPtr pThis, int inputHandle)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInputLogic)handle.Target!;
        return logic.GetRemotePlaySessionID(inputHandle);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamInput_GetSessionInputConfigurationSettings(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInputLogic)handle.Target!;
        return logic.GetSessionInputConfigurationSettings();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamInput_SetDualSenseTriggerEffect(IntPtr pThis, int inputHandle, IntPtr pParam)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInputLogic)handle.Target!;
        return logic.SetDualSenseTriggerEffect(inputHandle, pParam);
    }
}

public unsafe class ISteamControllerShim
{
    public static ISteamControllerVTable VTable;
    public static IntPtr VTablePtr;

    static ISteamControllerShim()
    {
        VTablePtr = (IntPtr)Unsafe.AsPointer(ref VTable);
        VTable.Init = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, byte>)&ISteamController_Init;
        VTable.Shutdown = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, byte>)&ISteamController_Shutdown;
        VTable.RunFrame = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, void>)&ISteamController_RunFrame;
        VTable.GetConnectedControllers = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, int>)&ISteamController_GetConnectedControllers;
        VTable.GetActionSetHandle = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, int>)&ISteamController_GetActionSetHandle;
        VTable.ActivateActionSet = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, void>)&ISteamController_ActivateActionSet;
        VTable.GetCurrentActionSet = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int>)&ISteamController_GetCurrentActionSet;
        VTable.ActivateActionSetLayer = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, void>)&ISteamController_ActivateActionSetLayer;
        VTable.DeactivateActionSetLayer = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, void>)&ISteamController_DeactivateActionSetLayer;
        VTable.DeactivateAllActionSetLayers = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, void>)&ISteamController_DeactivateAllActionSetLayers;
        VTable.GetActiveActionSetLayers = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, int>)&ISteamController_GetActiveActionSetLayers;
        VTable.GetDigitalActionHandle = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, int>)&ISteamController_GetDigitalActionHandle;
        VTable.GetDigitalActionData = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, int>)&ISteamController_GetDigitalActionData;
        VTable.GetDigitalActionOrigins = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, int, IntPtr, int>)&ISteamController_GetDigitalActionOrigins;
        VTable.GetAnalogActionHandle = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, int>)&ISteamController_GetAnalogActionHandle;
        VTable.GetAnalogActionData = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, int>)&ISteamController_GetAnalogActionData;
        VTable.GetAnalogActionOrigins = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, int, IntPtr, int>)&ISteamController_GetAnalogActionOrigins;
        VTable.GetGlyphForActionOrigin = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr>)&ISteamController_GetGlyphForActionOrigin;
        VTable.GetStringForActionOrigin = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr>)&ISteamController_GetStringForActionOrigin;
        VTable.StopAnalogActionMomentum = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, void>)&ISteamController_StopAnalogActionMomentum;
        VTable.GetMotionData = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int>)&ISteamController_GetMotionData;
        VTable.TriggerHapticPulse = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, int, void>)&ISteamController_TriggerHapticPulse;
        VTable.TriggerRepeatedHapticPulse = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, int, int, int, int, void>)&ISteamController_TriggerRepeatedHapticPulse;
        VTable.TriggerVibration = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, int, void>)&ISteamController_TriggerVibration;
        VTable.SetLEDColor = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, int, int, int, void>)&ISteamController_SetLEDColor;
        VTable.ShowBindingPanel = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, byte>)&ISteamController_ShowBindingPanel;
        VTable.GetInputTypeForHandle = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int>)&ISteamController_GetInputTypeForHandle;
        VTable.GetControllerForGamepadIndex = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int>)&ISteamController_GetControllerForGamepadIndex;
        VTable.GetGamepadIndexForController = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int>)&ISteamController_GetGamepadIndexForController;
        VTable.GetStringForXboxOrigin = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr>)&ISteamController_GetStringForXboxOrigin;
        VTable.GetGlyphForXboxOrigin = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr>)&ISteamController_GetGlyphForXboxOrigin;
        VTable.GetActionOriginFromXboxOrigin = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, int>)&ISteamController_GetActionOriginFromXboxOrigin;
        VTable.TranslateActionOrigin = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, int>)&ISteamController_TranslateActionOrigin;
        VTable.GetControllerBindingRevision = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, IntPtr, byte>)&ISteamController_GetControllerBindingRevision;
    }

    public static IntPtr Create(ISteamControllerLogic logic)
    {
        var handle = GCHandle.Alloc(logic);
        var ptr = Marshal.AllocHGlobal(IntPtr.Size * 2);
        *(IntPtr*)ptr = VTablePtr;
        *(IntPtr*)((byte*)ptr + IntPtr.Size) = GCHandle.ToIntPtr(handle);
        return ptr;
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamController_Init(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamControllerLogic)handle.Target!;
        return logic.Init();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamController_Shutdown(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamControllerLogic)handle.Target!;
        return logic.Shutdown();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamController_RunFrame(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamControllerLogic)handle.Target!;
        return logic.RunFrame();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamController_GetConnectedControllers(IntPtr pThis, IntPtr handlesOut)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamControllerLogic)handle.Target!;
        return logic.GetConnectedControllers(handlesOut);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamController_GetActionSetHandle(IntPtr pThis, IntPtr pszActionSetName)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamControllerLogic)handle.Target!;
        return logic.GetActionSetHandle(pszActionSetName);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamController_ActivateActionSet(IntPtr pThis, int controllerHandle, int actionSetHandle)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamControllerLogic)handle.Target!;
        return logic.ActivateActionSet(controllerHandle, actionSetHandle);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamController_GetCurrentActionSet(IntPtr pThis, int controllerHandle)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamControllerLogic)handle.Target!;
        return logic.GetCurrentActionSet(controllerHandle);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamController_ActivateActionSetLayer(IntPtr pThis, int controllerHandle, int actionSetLayerHandle)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamControllerLogic)handle.Target!;
        return logic.ActivateActionSetLayer(controllerHandle, actionSetLayerHandle);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamController_DeactivateActionSetLayer(IntPtr pThis, int controllerHandle, int actionSetLayerHandle)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamControllerLogic)handle.Target!;
        return logic.DeactivateActionSetLayer(controllerHandle, actionSetLayerHandle);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamController_DeactivateAllActionSetLayers(IntPtr pThis, int controllerHandle)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamControllerLogic)handle.Target!;
        return logic.DeactivateAllActionSetLayers(controllerHandle);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamController_GetActiveActionSetLayers(IntPtr pThis, int controllerHandle, IntPtr handlesOut)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamControllerLogic)handle.Target!;
        return logic.GetActiveActionSetLayers(controllerHandle, handlesOut);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamController_GetDigitalActionHandle(IntPtr pThis, IntPtr pszActionName)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamControllerLogic)handle.Target!;
        return logic.GetDigitalActionHandle(pszActionName);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamController_GetDigitalActionData(IntPtr pThis, int controllerHandle, int digitalActionHandle)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamControllerLogic)handle.Target!;
        return logic.GetDigitalActionData(controllerHandle, digitalActionHandle);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamController_GetDigitalActionOrigins(IntPtr pThis, int controllerHandle, int actionSetHandle, int digitalActionHandle, IntPtr originsOut)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamControllerLogic)handle.Target!;
        return logic.GetDigitalActionOrigins(controllerHandle, actionSetHandle, digitalActionHandle, originsOut);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamController_GetAnalogActionHandle(IntPtr pThis, IntPtr pszActionName)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamControllerLogic)handle.Target!;
        return logic.GetAnalogActionHandle(pszActionName);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamController_GetAnalogActionData(IntPtr pThis, int controllerHandle, int analogActionHandle)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamControllerLogic)handle.Target!;
        return logic.GetAnalogActionData(controllerHandle, analogActionHandle);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamController_GetAnalogActionOrigins(IntPtr pThis, int controllerHandle, int actionSetHandle, int analogActionHandle, IntPtr originsOut)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamControllerLogic)handle.Target!;
        return logic.GetAnalogActionOrigins(controllerHandle, actionSetHandle, analogActionHandle, originsOut);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static IntPtr ISteamController_GetGlyphForActionOrigin(IntPtr pThis, int eOrigin)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamControllerLogic)handle.Target!;
        return logic.GetGlyphForActionOrigin(eOrigin);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static IntPtr ISteamController_GetStringForActionOrigin(IntPtr pThis, int eOrigin)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamControllerLogic)handle.Target!;
        return logic.GetStringForActionOrigin(eOrigin);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamController_StopAnalogActionMomentum(IntPtr pThis, int controllerHandle, int eAction)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamControllerLogic)handle.Target!;
        return logic.StopAnalogActionMomentum(controllerHandle, eAction);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamController_GetMotionData(IntPtr pThis, int controllerHandle)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamControllerLogic)handle.Target!;
        return logic.GetMotionData(controllerHandle);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamController_TriggerHapticPulse(IntPtr pThis, int controllerHandle, int eTargetPad, int usDurationMicroSec)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamControllerLogic)handle.Target!;
        return logic.TriggerHapticPulse(controllerHandle, eTargetPad, usDurationMicroSec);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamController_TriggerRepeatedHapticPulse(IntPtr pThis, int controllerHandle, int eTargetPad, int usDurationMicroSec, int usOffMicroSec, int unRepeat, int nFlags)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamControllerLogic)handle.Target!;
        return logic.TriggerRepeatedHapticPulse(controllerHandle, eTargetPad, usDurationMicroSec, usOffMicroSec, unRepeat, nFlags);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamController_TriggerVibration(IntPtr pThis, int controllerHandle, int usLeftSpeed, int usRightSpeed)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamControllerLogic)handle.Target!;
        return logic.TriggerVibration(controllerHandle, usLeftSpeed, usRightSpeed);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamController_SetLEDColor(IntPtr pThis, int controllerHandle, int nColorR, int nColorG, int nColorB, int nFlags)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamControllerLogic)handle.Target!;
        return logic.SetLEDColor(controllerHandle, nColorR, nColorG, nColorB, nFlags);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamController_ShowBindingPanel(IntPtr pThis, int controllerHandle)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamControllerLogic)handle.Target!;
        return logic.ShowBindingPanel(controllerHandle);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamController_GetInputTypeForHandle(IntPtr pThis, int controllerHandle)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamControllerLogic)handle.Target!;
        return logic.GetInputTypeForHandle(controllerHandle);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamController_GetControllerForGamepadIndex(IntPtr pThis, int nIndex)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamControllerLogic)handle.Target!;
        return logic.GetControllerForGamepadIndex(nIndex);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamController_GetGamepadIndexForController(IntPtr pThis, int ulControllerHandle)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamControllerLogic)handle.Target!;
        return logic.GetGamepadIndexForController(ulControllerHandle);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static IntPtr ISteamController_GetStringForXboxOrigin(IntPtr pThis, int eOrigin)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamControllerLogic)handle.Target!;
        return logic.GetStringForXboxOrigin(eOrigin);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static IntPtr ISteamController_GetGlyphForXboxOrigin(IntPtr pThis, int eOrigin)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamControllerLogic)handle.Target!;
        return logic.GetGlyphForXboxOrigin(eOrigin);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamController_GetActionOriginFromXboxOrigin(IntPtr pThis, int controllerHandle, int eOrigin)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamControllerLogic)handle.Target!;
        return logic.GetActionOriginFromXboxOrigin(controllerHandle, eOrigin);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamController_TranslateActionOrigin(IntPtr pThis, int eDestinationInputType, int eSourceOrigin)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamControllerLogic)handle.Target!;
        return logic.TranslateActionOrigin(eDestinationInputType, eSourceOrigin);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamController_GetControllerBindingRevision(IntPtr pThis, int controllerHandle, IntPtr pMajor, IntPtr pMinor)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamControllerLogic)handle.Target!;
        return logic.GetControllerBindingRevision(controllerHandle, pMajor, pMinor);
    }
}

public unsafe class ISteamUGCShim
{
    public static ISteamUGCVTable VTable;
    public static IntPtr VTablePtr;

    static ISteamUGCShim()
    {
        VTablePtr = (IntPtr)Unsafe.AsPointer(ref VTable);
        VTable.CreateQueryUserUGCRequest = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, int, int, int, int, uint, int>)&ISteamUGC_CreateQueryUserUGCRequest;
        VTable.CreateQueryAllUGCRequest = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, int, int, uint, int>)&ISteamUGC_CreateQueryAllUGCRequest;
        VTable.CreateQueryAllUGCRequest = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, int, int, IntPtr, int>)&ISteamUGC_CreateQueryAllUGCRequest;
        VTable.CreateQueryUGCDetailsRequest = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, uint, int>)&ISteamUGC_CreateQueryUGCDetailsRequest;
        VTable.SendQueryUGCRequest = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, ulong>)&ISteamUGC_SendQueryUGCRequest;
        VTable.GetQueryUGCResult = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, uint, IntPtr, byte>)&ISteamUGC_GetQueryUGCResult;
        VTable.GetQueryUGCNumTags = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, uint, uint>)&ISteamUGC_GetQueryUGCNumTags;
        VTable.GetQueryUGCTag = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, uint, uint, IntPtr, uint, byte>)&ISteamUGC_GetQueryUGCTag;
        VTable.GetQueryUGCTagDisplayName = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, uint, uint, IntPtr, uint, byte>)&ISteamUGC_GetQueryUGCTagDisplayName;
        VTable.GetQueryUGCPreviewURL = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, uint, IntPtr, uint, byte>)&ISteamUGC_GetQueryUGCPreviewURL;
        VTable.GetQueryUGCMetadata = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, uint, IntPtr, uint, byte>)&ISteamUGC_GetQueryUGCMetadata;
        VTable.GetQueryUGCChildren = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, uint, IntPtr, uint, byte>)&ISteamUGC_GetQueryUGCChildren;
        VTable.GetQueryUGCStatistic = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, uint, int, IntPtr, byte>)&ISteamUGC_GetQueryUGCStatistic;
        VTable.GetQueryUGCNumAdditionalPreviews = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, uint, uint>)&ISteamUGC_GetQueryUGCNumAdditionalPreviews;
        VTable.GetQueryUGCAdditionalPreview = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, uint, uint, IntPtr, uint, IntPtr, uint, IntPtr, byte>)&ISteamUGC_GetQueryUGCAdditionalPreview;
        VTable.GetQueryUGCNumKeyValueTags = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, uint, uint>)&ISteamUGC_GetQueryUGCNumKeyValueTags;
        VTable.GetQueryUGCKeyValueTag = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, uint, uint, IntPtr, uint, IntPtr, uint, byte>)&ISteamUGC_GetQueryUGCKeyValueTag;
        VTable.GetQueryUGCKeyValueTag = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, uint, IntPtr, IntPtr, uint, byte>)&ISteamUGC_GetQueryUGCKeyValueTag;
        VTable.GetNumSupportedGameVersions = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, uint, uint>)&ISteamUGC_GetNumSupportedGameVersions;
        VTable.GetSupportedGameVersionData = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, uint, uint, IntPtr, IntPtr, uint, byte>)&ISteamUGC_GetSupportedGameVersionData;
        VTable.GetQueryUGCContentDescriptors = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, uint, IntPtr, uint, uint>)&ISteamUGC_GetQueryUGCContentDescriptors;
        VTable.ReleaseQueryUGCRequest = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, byte>)&ISteamUGC_ReleaseQueryUGCRequest;
        VTable.AddRequiredTag = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, byte>)&ISteamUGC_AddRequiredTag;
        VTable.AddRequiredTagGroup = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, byte>)&ISteamUGC_AddRequiredTagGroup;
        VTable.AddExcludedTag = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, byte>)&ISteamUGC_AddExcludedTag;
        VTable.SetReturnOnlyIDs = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, byte, byte>)&ISteamUGC_SetReturnOnlyIDs;
        VTable.SetReturnKeyValueTags = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, byte, byte>)&ISteamUGC_SetReturnKeyValueTags;
        VTable.SetReturnLongDescription = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, byte, byte>)&ISteamUGC_SetReturnLongDescription;
        VTable.SetReturnMetadata = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, byte, byte>)&ISteamUGC_SetReturnMetadata;
        VTable.SetReturnChildren = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, byte, byte>)&ISteamUGC_SetReturnChildren;
        VTable.SetReturnAdditionalPreviews = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, byte, byte>)&ISteamUGC_SetReturnAdditionalPreviews;
        VTable.SetReturnTotalOnly = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, byte, byte>)&ISteamUGC_SetReturnTotalOnly;
        VTable.SetReturnPlaytimeStats = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, uint, byte>)&ISteamUGC_SetReturnPlaytimeStats;
        VTable.SetLanguage = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, byte>)&ISteamUGC_SetLanguage;
        VTable.SetAllowCachedResponse = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, uint, byte>)&ISteamUGC_SetAllowCachedResponse;
        VTable.SetAdminQuery = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, byte, byte>)&ISteamUGC_SetAdminQuery;
        VTable.SetCloudFileNameFilter = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, byte>)&ISteamUGC_SetCloudFileNameFilter;
        VTable.SetMatchAnyTag = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, byte, byte>)&ISteamUGC_SetMatchAnyTag;
        VTable.SetSearchText = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, byte>)&ISteamUGC_SetSearchText;
        VTable.SetRankedByTrendDays = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, uint, byte>)&ISteamUGC_SetRankedByTrendDays;
        VTable.SetTimeCreatedDateRange = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, int, byte>)&ISteamUGC_SetTimeCreatedDateRange;
        VTable.SetTimeUpdatedDateRange = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, int, byte>)&ISteamUGC_SetTimeUpdatedDateRange;
        VTable.AddRequiredKeyValueTag = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, IntPtr, byte>)&ISteamUGC_AddRequiredKeyValueTag;
        VTable.RequestUGCDetails = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, uint, ulong>)&ISteamUGC_RequestUGCDetails;
        VTable.CreateItem = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, ulong>)&ISteamUGC_CreateItem;
        VTable.StartItemUpdate = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, int>)&ISteamUGC_StartItemUpdate;
        VTable.SetItemTitle = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, byte>)&ISteamUGC_SetItemTitle;
        VTable.SetItemDescription = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, byte>)&ISteamUGC_SetItemDescription;
        VTable.SetItemUpdateLanguage = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, byte>)&ISteamUGC_SetItemUpdateLanguage;
        VTable.SetItemMetadata = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, byte>)&ISteamUGC_SetItemMetadata;
        VTable.SetItemVisibility = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, byte>)&ISteamUGC_SetItemVisibility;
        VTable.SetItemTags = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, byte, byte>)&ISteamUGC_SetItemTags;
        VTable.SetItemContent = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, byte>)&ISteamUGC_SetItemContent;
        VTable.SetItemPreview = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, byte>)&ISteamUGC_SetItemPreview;
        VTable.SetAllowLegacyUpload = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, byte, byte>)&ISteamUGC_SetAllowLegacyUpload;
        VTable.RemoveAllItemKeyValueTags = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, byte>)&ISteamUGC_RemoveAllItemKeyValueTags;
        VTable.RemoveItemKeyValueTags = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, byte>)&ISteamUGC_RemoveItemKeyValueTags;
        VTable.AddItemKeyValueTag = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, IntPtr, byte>)&ISteamUGC_AddItemKeyValueTag;
        VTable.AddItemPreviewFile = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, int, byte>)&ISteamUGC_AddItemPreviewFile;
        VTable.AddItemPreviewVideo = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, byte>)&ISteamUGC_AddItemPreviewVideo;
        VTable.UpdateItemPreviewFile = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, uint, IntPtr, byte>)&ISteamUGC_UpdateItemPreviewFile;
        VTable.UpdateItemPreviewVideo = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, uint, IntPtr, byte>)&ISteamUGC_UpdateItemPreviewVideo;
        VTable.RemoveItemPreview = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, uint, byte>)&ISteamUGC_RemoveItemPreview;
        VTable.AddContentDescriptor = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, byte>)&ISteamUGC_AddContentDescriptor;
        VTable.RemoveContentDescriptor = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, byte>)&ISteamUGC_RemoveContentDescriptor;
        VTable.SetRequiredGameVersions = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, IntPtr, byte>)&ISteamUGC_SetRequiredGameVersions;
        VTable.SubmitItemUpdate = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, ulong>)&ISteamUGC_SubmitItemUpdate;
        VTable.GetItemUpdateProgress = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, IntPtr, int>)&ISteamUGC_GetItemUpdateProgress;
        VTable.SetUserItemVote = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, byte, ulong>)&ISteamUGC_SetUserItemVote;
        VTable.GetUserItemVote = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, ulong>)&ISteamUGC_GetUserItemVote;
        VTable.AddItemToFavorites = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, ulong>)&ISteamUGC_AddItemToFavorites;
        VTable.RemoveItemFromFavorites = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, ulong>)&ISteamUGC_RemoveItemFromFavorites;
        VTable.SubscribeItem = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, ulong>)&ISteamUGC_SubscribeItem;
        VTable.UnsubscribeItem = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, ulong>)&ISteamUGC_UnsubscribeItem;
        VTable.GetNumSubscribedItems = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, byte, uint>)&ISteamUGC_GetNumSubscribedItems;
        VTable.GetSubscribedItems = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, uint, byte, uint>)&ISteamUGC_GetSubscribedItems;
        VTable.GetItemState = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, uint>)&ISteamUGC_GetItemState;
        VTable.GetItemInstallInfo = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, IntPtr, uint, IntPtr, byte>)&ISteamUGC_GetItemInstallInfo;
        VTable.GetItemDownloadInfo = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, IntPtr, byte>)&ISteamUGC_GetItemDownloadInfo;
        VTable.DownloadItem = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, byte, byte>)&ISteamUGC_DownloadItem;
        VTable.BInitWorkshopForGameServer = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, byte>)&ISteamUGC_BInitWorkshopForGameServer;
        VTable.SuspendDownloads = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, byte, void>)&ISteamUGC_SuspendDownloads;
        VTable.StartPlaytimeTracking = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, uint, ulong>)&ISteamUGC_StartPlaytimeTracking;
        VTable.StopPlaytimeTracking = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, uint, ulong>)&ISteamUGC_StopPlaytimeTracking;
        VTable.StopPlaytimeTrackingForAllItems = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong>)&ISteamUGC_StopPlaytimeTrackingForAllItems;
        VTable.AddDependency = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, ulong>)&ISteamUGC_AddDependency;
        VTable.RemoveDependency = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, ulong>)&ISteamUGC_RemoveDependency;
        VTable.AddAppDependency = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, ulong>)&ISteamUGC_AddAppDependency;
        VTable.RemoveAppDependency = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, ulong>)&ISteamUGC_RemoveAppDependency;
        VTable.GetAppDependencies = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, ulong>)&ISteamUGC_GetAppDependencies;
        VTable.DeleteItem = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, ulong>)&ISteamUGC_DeleteItem;
        VTable.ShowWorkshopEULA = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, byte>)&ISteamUGC_ShowWorkshopEULA;
        VTable.GetWorkshopEULAStatus = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong>)&ISteamUGC_GetWorkshopEULAStatus;
        VTable.GetUserContentDescriptorPreferences = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, uint, uint>)&ISteamUGC_GetUserContentDescriptorPreferences;
        VTable.SetItemsDisabledLocally = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, uint, byte, byte>)&ISteamUGC_SetItemsDisabledLocally;
        VTable.SetSubscriptionsLoadOrder = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, uint, byte>)&ISteamUGC_SetSubscriptionsLoadOrder;
    }

    public static IntPtr Create(ISteamUGCLogic logic)
    {
        var handle = GCHandle.Alloc(logic);
        var ptr = Marshal.AllocHGlobal(IntPtr.Size * 2);
        *(IntPtr*)ptr = VTablePtr;
        *(IntPtr*)((byte*)ptr + IntPtr.Size) = GCHandle.ToIntPtr(handle);
        return ptr;
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamUGC_CreateQueryUserUGCRequest(IntPtr pThis, int unAccountID, int eListType, int eMatchingUGCType, int eSortOrder, int nCreatorAppID, int nConsumerAppID, uint unPage)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.CreateQueryUserUGCRequest(unAccountID, eListType, eMatchingUGCType, eSortOrder, nCreatorAppID, nConsumerAppID, unPage);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamUGC_CreateQueryAllUGCRequest(IntPtr pThis, int eQueryType, int eMatchingeMatchingUGCTypeFileType, int nCreatorAppID, int nConsumerAppID, uint unPage)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.CreateQueryAllUGCRequest(eQueryType, eMatchingeMatchingUGCTypeFileType, nCreatorAppID, nConsumerAppID, unPage);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamUGC_CreateQueryAllUGCRequest(IntPtr pThis, int eQueryType, int eMatchingeMatchingUGCTypeFileType, int nCreatorAppID, int nConsumerAppID, IntPtr pchCursor)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.CreateQueryAllUGCRequest(eQueryType, eMatchingeMatchingUGCTypeFileType, nCreatorAppID, nConsumerAppID, pchCursor);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamUGC_CreateQueryUGCDetailsRequest(IntPtr pThis, IntPtr pvecPublishedFileID, uint unNumPublishedFileIDs)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.CreateQueryUGCDetailsRequest(pvecPublishedFileID, unNumPublishedFileIDs);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamUGC_SendQueryUGCRequest(IntPtr pThis, int handle)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.SendQueryUGCRequest(handle);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUGC_GetQueryUGCResult(IntPtr pThis, int handle, uint index, IntPtr pDetails)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.GetQueryUGCResult(handle, index, pDetails);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static uint ISteamUGC_GetQueryUGCNumTags(IntPtr pThis, int handle, uint index)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.GetQueryUGCNumTags(handle, index);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUGC_GetQueryUGCTag(IntPtr pThis, int handle, uint index, uint indexTag, IntPtr pchValue, uint cchValueSize)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.GetQueryUGCTag(handle, index, indexTag, pchValue, cchValueSize);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUGC_GetQueryUGCTagDisplayName(IntPtr pThis, int handle, uint index, uint indexTag, IntPtr pchValue, uint cchValueSize)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.GetQueryUGCTagDisplayName(handle, index, indexTag, pchValue, cchValueSize);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUGC_GetQueryUGCPreviewURL(IntPtr pThis, int handle, uint index, IntPtr pchURL, uint cchURLSize)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.GetQueryUGCPreviewURL(handle, index, pchURL, cchURLSize);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUGC_GetQueryUGCMetadata(IntPtr pThis, int handle, uint index, IntPtr pchMetadata, uint cchMetadatasize)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.GetQueryUGCMetadata(handle, index, pchMetadata, cchMetadatasize);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUGC_GetQueryUGCChildren(IntPtr pThis, int handle, uint index, IntPtr pvecPublishedFileID, uint cMaxEntries)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.GetQueryUGCChildren(handle, index, pvecPublishedFileID, cMaxEntries);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUGC_GetQueryUGCStatistic(IntPtr pThis, int handle, uint index, int eStatType, IntPtr pStatValue)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.GetQueryUGCStatistic(handle, index, eStatType, pStatValue);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static uint ISteamUGC_GetQueryUGCNumAdditionalPreviews(IntPtr pThis, int handle, uint index)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.GetQueryUGCNumAdditionalPreviews(handle, index);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUGC_GetQueryUGCAdditionalPreview(IntPtr pThis, int handle, uint index, uint previewIndex, IntPtr pchURLOrVideoID, uint cchURLSize, IntPtr pchOriginalFileName, uint cchOriginalFileNameSize, IntPtr pPreviewType)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.GetQueryUGCAdditionalPreview(handle, index, previewIndex, pchURLOrVideoID, cchURLSize, pchOriginalFileName, cchOriginalFileNameSize, pPreviewType);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static uint ISteamUGC_GetQueryUGCNumKeyValueTags(IntPtr pThis, int handle, uint index)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.GetQueryUGCNumKeyValueTags(handle, index);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUGC_GetQueryUGCKeyValueTag(IntPtr pThis, int handle, uint index, uint keyValueTagIndex, IntPtr pchKey, uint cchKeySize, IntPtr pchValue, uint cchValueSize)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.GetQueryUGCKeyValueTag(handle, index, keyValueTagIndex, pchKey, cchKeySize, pchValue, cchValueSize);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUGC_GetQueryUGCKeyValueTag(IntPtr pThis, int handle, uint index, IntPtr pchKey, IntPtr pchValue, uint cchValueSize)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.GetQueryUGCKeyValueTag(handle, index, pchKey, pchValue, cchValueSize);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static uint ISteamUGC_GetNumSupportedGameVersions(IntPtr pThis, int handle, uint index)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.GetNumSupportedGameVersions(handle, index);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUGC_GetSupportedGameVersionData(IntPtr pThis, int handle, uint index, uint versionIndex, IntPtr pchGameBranchMin, IntPtr pchGameBranchMax, uint cchGameBranchSize)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.GetSupportedGameVersionData(handle, index, versionIndex, pchGameBranchMin, pchGameBranchMax, cchGameBranchSize);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static uint ISteamUGC_GetQueryUGCContentDescriptors(IntPtr pThis, int handle, uint index, IntPtr pvecDescriptors, uint cMaxEntries)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.GetQueryUGCContentDescriptors(handle, index, pvecDescriptors, cMaxEntries);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUGC_ReleaseQueryUGCRequest(IntPtr pThis, int handle)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.ReleaseQueryUGCRequest(handle);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUGC_AddRequiredTag(IntPtr pThis, int handle, IntPtr pTagName)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.AddRequiredTag(handle, pTagName);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUGC_AddRequiredTagGroup(IntPtr pThis, int handle, IntPtr pTagGroups)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.AddRequiredTagGroup(handle, pTagGroups);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUGC_AddExcludedTag(IntPtr pThis, int handle, IntPtr pTagName)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.AddExcludedTag(handle, pTagName);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUGC_SetReturnOnlyIDs(IntPtr pThis, int handle, byte bReturnOnlyIDs)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.SetReturnOnlyIDs(handle, bReturnOnlyIDs);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUGC_SetReturnKeyValueTags(IntPtr pThis, int handle, byte bReturnKeyValueTags)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.SetReturnKeyValueTags(handle, bReturnKeyValueTags);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUGC_SetReturnLongDescription(IntPtr pThis, int handle, byte bReturnLongDescription)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.SetReturnLongDescription(handle, bReturnLongDescription);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUGC_SetReturnMetadata(IntPtr pThis, int handle, byte bReturnMetadata)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.SetReturnMetadata(handle, bReturnMetadata);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUGC_SetReturnChildren(IntPtr pThis, int handle, byte bReturnChildren)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.SetReturnChildren(handle, bReturnChildren);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUGC_SetReturnAdditionalPreviews(IntPtr pThis, int handle, byte bReturnAdditionalPreviews)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.SetReturnAdditionalPreviews(handle, bReturnAdditionalPreviews);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUGC_SetReturnTotalOnly(IntPtr pThis, int handle, byte bReturnTotalOnly)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.SetReturnTotalOnly(handle, bReturnTotalOnly);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUGC_SetReturnPlaytimeStats(IntPtr pThis, int handle, uint unDays)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.SetReturnPlaytimeStats(handle, unDays);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUGC_SetLanguage(IntPtr pThis, int handle, IntPtr pchLanguage)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.SetLanguage(handle, pchLanguage);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUGC_SetAllowCachedResponse(IntPtr pThis, int handle, uint unMaxAgeSeconds)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.SetAllowCachedResponse(handle, unMaxAgeSeconds);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUGC_SetAdminQuery(IntPtr pThis, int handle, byte bAdminQuery)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.SetAdminQuery(handle, bAdminQuery);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUGC_SetCloudFileNameFilter(IntPtr pThis, int handle, IntPtr pMatchCloudFileName)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.SetCloudFileNameFilter(handle, pMatchCloudFileName);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUGC_SetMatchAnyTag(IntPtr pThis, int handle, byte bMatchAnyTag)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.SetMatchAnyTag(handle, bMatchAnyTag);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUGC_SetSearchText(IntPtr pThis, int handle, IntPtr pSearchText)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.SetSearchText(handle, pSearchText);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUGC_SetRankedByTrendDays(IntPtr pThis, int handle, uint unDays)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.SetRankedByTrendDays(handle, unDays);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUGC_SetTimeCreatedDateRange(IntPtr pThis, int handle, int rtStart, int rtEnd)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.SetTimeCreatedDateRange(handle, rtStart, rtEnd);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUGC_SetTimeUpdatedDateRange(IntPtr pThis, int handle, int rtStart, int rtEnd)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.SetTimeUpdatedDateRange(handle, rtStart, rtEnd);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUGC_AddRequiredKeyValueTag(IntPtr pThis, int handle, IntPtr pKey, IntPtr pValue)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.AddRequiredKeyValueTag(handle, pKey, pValue);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamUGC_RequestUGCDetails(IntPtr pThis, int nPublishedFileID, uint unMaxAgeSeconds)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.RequestUGCDetails(nPublishedFileID, unMaxAgeSeconds);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamUGC_CreateItem(IntPtr pThis, int nConsumerAppId, int eFileType)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.CreateItem(nConsumerAppId, eFileType);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamUGC_StartItemUpdate(IntPtr pThis, int nConsumerAppId, int nPublishedFileID)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.StartItemUpdate(nConsumerAppId, nPublishedFileID);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUGC_SetItemTitle(IntPtr pThis, int handle, IntPtr pchTitle)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.SetItemTitle(handle, pchTitle);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUGC_SetItemDescription(IntPtr pThis, int handle, IntPtr pchDescription)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.SetItemDescription(handle, pchDescription);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUGC_SetItemUpdateLanguage(IntPtr pThis, int handle, IntPtr pchLanguage)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.SetItemUpdateLanguage(handle, pchLanguage);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUGC_SetItemMetadata(IntPtr pThis, int handle, IntPtr pchMetaData)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.SetItemMetadata(handle, pchMetaData);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUGC_SetItemVisibility(IntPtr pThis, int handle, int eVisibility)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.SetItemVisibility(handle, eVisibility);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUGC_SetItemTags(IntPtr pThis, int updateHandle, IntPtr pTags, byte bAllowAdminTags)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.SetItemTags(updateHandle, pTags, bAllowAdminTags);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUGC_SetItemContent(IntPtr pThis, int handle, IntPtr pszContentFolder)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.SetItemContent(handle, pszContentFolder);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUGC_SetItemPreview(IntPtr pThis, int handle, IntPtr pszPreviewFile)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.SetItemPreview(handle, pszPreviewFile);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUGC_SetAllowLegacyUpload(IntPtr pThis, int handle, byte bAllowLegacyUpload)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.SetAllowLegacyUpload(handle, bAllowLegacyUpload);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUGC_RemoveAllItemKeyValueTags(IntPtr pThis, int handle)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.RemoveAllItemKeyValueTags(handle);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUGC_RemoveItemKeyValueTags(IntPtr pThis, int handle, IntPtr pchKey)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.RemoveItemKeyValueTags(handle, pchKey);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUGC_AddItemKeyValueTag(IntPtr pThis, int handle, IntPtr pchKey, IntPtr pchValue)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.AddItemKeyValueTag(handle, pchKey, pchValue);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUGC_AddItemPreviewFile(IntPtr pThis, int handle, IntPtr pszPreviewFile, int type)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.AddItemPreviewFile(handle, pszPreviewFile, type);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUGC_AddItemPreviewVideo(IntPtr pThis, int handle, IntPtr pszVideoID)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.AddItemPreviewVideo(handle, pszVideoID);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUGC_UpdateItemPreviewFile(IntPtr pThis, int handle, uint index, IntPtr pszPreviewFile)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.UpdateItemPreviewFile(handle, index, pszPreviewFile);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUGC_UpdateItemPreviewVideo(IntPtr pThis, int handle, uint index, IntPtr pszVideoID)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.UpdateItemPreviewVideo(handle, index, pszVideoID);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUGC_RemoveItemPreview(IntPtr pThis, int handle, uint index)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.RemoveItemPreview(handle, index);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUGC_AddContentDescriptor(IntPtr pThis, int handle, int descid)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.AddContentDescriptor(handle, descid);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUGC_RemoveContentDescriptor(IntPtr pThis, int handle, int descid)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.RemoveContentDescriptor(handle, descid);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUGC_SetRequiredGameVersions(IntPtr pThis, int handle, IntPtr pszGameBranchMin, IntPtr pszGameBranchMax)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.SetRequiredGameVersions(handle, pszGameBranchMin, pszGameBranchMax);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamUGC_SubmitItemUpdate(IntPtr pThis, int handle, IntPtr pchChangeNote)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.SubmitItemUpdate(handle, pchChangeNote);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamUGC_GetItemUpdateProgress(IntPtr pThis, int handle, IntPtr punBytesProcessed, IntPtr punBytesTotal)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.GetItemUpdateProgress(handle, punBytesProcessed, punBytesTotal);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamUGC_SetUserItemVote(IntPtr pThis, int nPublishedFileID, byte bVoteUp)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.SetUserItemVote(nPublishedFileID, bVoteUp);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamUGC_GetUserItemVote(IntPtr pThis, int nPublishedFileID)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.GetUserItemVote(nPublishedFileID);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamUGC_AddItemToFavorites(IntPtr pThis, int nAppId, int nPublishedFileID)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.AddItemToFavorites(nAppId, nPublishedFileID);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamUGC_RemoveItemFromFavorites(IntPtr pThis, int nAppId, int nPublishedFileID)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.RemoveItemFromFavorites(nAppId, nPublishedFileID);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamUGC_SubscribeItem(IntPtr pThis, int nPublishedFileID)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.SubscribeItem(nPublishedFileID);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamUGC_UnsubscribeItem(IntPtr pThis, int nPublishedFileID)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.UnsubscribeItem(nPublishedFileID);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static uint ISteamUGC_GetNumSubscribedItems(IntPtr pThis, byte bIncludeLocallyDisabled)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.GetNumSubscribedItems(bIncludeLocallyDisabled);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static uint ISteamUGC_GetSubscribedItems(IntPtr pThis, IntPtr pvecPublishedFileID, uint cMaxEntries, byte bIncludeLocallyDisabled)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.GetSubscribedItems(pvecPublishedFileID, cMaxEntries, bIncludeLocallyDisabled);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static uint ISteamUGC_GetItemState(IntPtr pThis, int nPublishedFileID)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.GetItemState(nPublishedFileID);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUGC_GetItemInstallInfo(IntPtr pThis, int nPublishedFileID, IntPtr punSizeOnDisk, IntPtr pchFolder, uint cchFolderSize, IntPtr punTimeStamp)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.GetItemInstallInfo(nPublishedFileID, punSizeOnDisk, pchFolder, cchFolderSize, punTimeStamp);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUGC_GetItemDownloadInfo(IntPtr pThis, int nPublishedFileID, IntPtr punBytesDownloaded, IntPtr punBytesTotal)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.GetItemDownloadInfo(nPublishedFileID, punBytesDownloaded, punBytesTotal);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUGC_DownloadItem(IntPtr pThis, int nPublishedFileID, byte bHighPriority)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.DownloadItem(nPublishedFileID, bHighPriority);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUGC_BInitWorkshopForGameServer(IntPtr pThis, int unWorkshopDepotID, IntPtr pszFolder)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.BInitWorkshopForGameServer(unWorkshopDepotID, pszFolder);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamUGC_SuspendDownloads(IntPtr pThis, byte bSuspend)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.SuspendDownloads(bSuspend);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamUGC_StartPlaytimeTracking(IntPtr pThis, IntPtr pvecPublishedFileID, uint unNumPublishedFileIDs)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.StartPlaytimeTracking(pvecPublishedFileID, unNumPublishedFileIDs);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamUGC_StopPlaytimeTracking(IntPtr pThis, IntPtr pvecPublishedFileID, uint unNumPublishedFileIDs)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.StopPlaytimeTracking(pvecPublishedFileID, unNumPublishedFileIDs);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamUGC_StopPlaytimeTrackingForAllItems(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.StopPlaytimeTrackingForAllItems();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamUGC_AddDependency(IntPtr pThis, int nParentPublishedFileID, int nChildPublishedFileID)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.AddDependency(nParentPublishedFileID, nChildPublishedFileID);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamUGC_RemoveDependency(IntPtr pThis, int nParentPublishedFileID, int nChildPublishedFileID)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.RemoveDependency(nParentPublishedFileID, nChildPublishedFileID);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamUGC_AddAppDependency(IntPtr pThis, int nPublishedFileID, int nAppID)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.AddAppDependency(nPublishedFileID, nAppID);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamUGC_RemoveAppDependency(IntPtr pThis, int nPublishedFileID, int nAppID)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.RemoveAppDependency(nPublishedFileID, nAppID);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamUGC_GetAppDependencies(IntPtr pThis, int nPublishedFileID)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.GetAppDependencies(nPublishedFileID);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamUGC_DeleteItem(IntPtr pThis, int nPublishedFileID)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.DeleteItem(nPublishedFileID);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUGC_ShowWorkshopEULA(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.ShowWorkshopEULA();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamUGC_GetWorkshopEULAStatus(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.GetWorkshopEULAStatus();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static uint ISteamUGC_GetUserContentDescriptorPreferences(IntPtr pThis, IntPtr pvecDescriptors, uint cMaxEntries)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.GetUserContentDescriptorPreferences(pvecDescriptors, cMaxEntries);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUGC_SetItemsDisabledLocally(IntPtr pThis, IntPtr pvecPublishedFileIDs, uint unNumPublishedFileIDs, byte bDisabledLocally)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.SetItemsDisabledLocally(pvecPublishedFileIDs, unNumPublishedFileIDs, bDisabledLocally);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamUGC_SetSubscriptionsLoadOrder(IntPtr pThis, IntPtr pvecPublishedFileIDs, uint unNumPublishedFileIDs)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamUGCLogic)handle.Target!;
        return logic.SetSubscriptionsLoadOrder(pvecPublishedFileIDs, unNumPublishedFileIDs);
    }
}

public unsafe class ISteamHTMLSurfaceShim
{
    public static ISteamHTMLSurfaceVTable VTable;
    public static IntPtr VTablePtr;

    static ISteamHTMLSurfaceShim()
    {
        VTablePtr = (IntPtr)Unsafe.AsPointer(ref VTable);
        VTable.Init = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, byte>)&ISteamHTMLSurface_Init;
        VTable.Shutdown = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, byte>)&ISteamHTMLSurface_Shutdown;
        VTable.CreateBrowser = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, IntPtr, ulong>)&ISteamHTMLSurface_CreateBrowser;
        VTable.RemoveBrowser = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, void>)&ISteamHTMLSurface_RemoveBrowser;
        VTable.LoadURL = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, IntPtr, IntPtr, void>)&ISteamHTMLSurface_LoadURL;
        VTable.SetSize = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, uint, uint, void>)&ISteamHTMLSurface_SetSize;
        VTable.StopLoad = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, void>)&ISteamHTMLSurface_StopLoad;
        VTable.Reload = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, void>)&ISteamHTMLSurface_Reload;
        VTable.GoBack = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, void>)&ISteamHTMLSurface_GoBack;
        VTable.GoForward = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, void>)&ISteamHTMLSurface_GoForward;
        VTable.AddHeader = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, IntPtr, IntPtr, void>)&ISteamHTMLSurface_AddHeader;
        VTable.ExecuteJavascript = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, IntPtr, void>)&ISteamHTMLSurface_ExecuteJavascript;
        VTable.MouseUp = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, int, void>)&ISteamHTMLSurface_MouseUp;
        VTable.MouseDown = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, int, void>)&ISteamHTMLSurface_MouseDown;
        VTable.MouseDoubleClick = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, int, void>)&ISteamHTMLSurface_MouseDoubleClick;
        VTable.MouseMove = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, int, int, void>)&ISteamHTMLSurface_MouseMove;
        VTable.MouseWheel = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, int, void>)&ISteamHTMLSurface_MouseWheel;
        VTable.KeyDown = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, uint, int, byte, void>)&ISteamHTMLSurface_KeyDown;
        VTable.KeyUp = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, uint, int, void>)&ISteamHTMLSurface_KeyUp;
        VTable.KeyChar = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, uint, int, void>)&ISteamHTMLSurface_KeyChar;
        VTable.SetHorizontalScroll = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, uint, void>)&ISteamHTMLSurface_SetHorizontalScroll;
        VTable.SetVerticalScroll = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, uint, void>)&ISteamHTMLSurface_SetVerticalScroll;
        VTable.SetKeyFocus = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, byte, void>)&ISteamHTMLSurface_SetKeyFocus;
        VTable.ViewSource = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, void>)&ISteamHTMLSurface_ViewSource;
        VTable.CopyToClipboard = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, void>)&ISteamHTMLSurface_CopyToClipboard;
        VTable.PasteFromClipboard = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, void>)&ISteamHTMLSurface_PasteFromClipboard;
        VTable.Find = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, IntPtr, byte, byte, void>)&ISteamHTMLSurface_Find;
        VTable.StopFind = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, void>)&ISteamHTMLSurface_StopFind;
        VTable.GetLinkAtPosition = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, int, int, void>)&ISteamHTMLSurface_GetLinkAtPosition;
        VTable.SetCookie = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, IntPtr, IntPtr, IntPtr, int, byte, byte, void>)&ISteamHTMLSurface_SetCookie;
        VTable.SetPageScaleFactor = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, int, int, int, void>)&ISteamHTMLSurface_SetPageScaleFactor;
        VTable.SetBackgroundMode = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, byte, void>)&ISteamHTMLSurface_SetBackgroundMode;
        VTable.SetDPIScalingFactor = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, int, void>)&ISteamHTMLSurface_SetDPIScalingFactor;
        VTable.OpenDeveloperTools = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, void>)&ISteamHTMLSurface_OpenDeveloperTools;
        VTable.AllowStartRequest = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, byte, void>)&ISteamHTMLSurface_AllowStartRequest;
        VTable.JSDialogResponse = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, byte, void>)&ISteamHTMLSurface_JSDialogResponse;
        VTable.FileLoadDialogResponse = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, IntPtr, void>)&ISteamHTMLSurface_FileLoadDialogResponse;
    }

    public static IntPtr Create(ISteamHTMLSurfaceLogic logic)
    {
        var handle = GCHandle.Alloc(logic);
        var ptr = Marshal.AllocHGlobal(IntPtr.Size * 2);
        *(IntPtr*)ptr = VTablePtr;
        *(IntPtr*)((byte*)ptr + IntPtr.Size) = GCHandle.ToIntPtr(handle);
        return ptr;
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamHTMLSurface_Init(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamHTMLSurfaceLogic)handle.Target!;
        return logic.Init();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamHTMLSurface_Shutdown(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamHTMLSurfaceLogic)handle.Target!;
        return logic.Shutdown();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamHTMLSurface_CreateBrowser(IntPtr pThis, IntPtr pchUserAgent, IntPtr pchUserCSS)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamHTMLSurfaceLogic)handle.Target!;
        return logic.CreateBrowser(pchUserAgent, pchUserCSS);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamHTMLSurface_RemoveBrowser(IntPtr pThis, uint unBrowserHandle)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamHTMLSurfaceLogic)handle.Target!;
        return logic.RemoveBrowser(unBrowserHandle);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamHTMLSurface_LoadURL(IntPtr pThis, uint unBrowserHandle, IntPtr pchURL, IntPtr pchPostData)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamHTMLSurfaceLogic)handle.Target!;
        return logic.LoadURL(unBrowserHandle, pchURL, pchPostData);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamHTMLSurface_SetSize(IntPtr pThis, uint unBrowserHandle, uint unWidth, uint unHeight)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamHTMLSurfaceLogic)handle.Target!;
        return logic.SetSize(unBrowserHandle, unWidth, unHeight);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamHTMLSurface_StopLoad(IntPtr pThis, uint unBrowserHandle)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamHTMLSurfaceLogic)handle.Target!;
        return logic.StopLoad(unBrowserHandle);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamHTMLSurface_Reload(IntPtr pThis, uint unBrowserHandle)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamHTMLSurfaceLogic)handle.Target!;
        return logic.Reload(unBrowserHandle);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamHTMLSurface_GoBack(IntPtr pThis, uint unBrowserHandle)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamHTMLSurfaceLogic)handle.Target!;
        return logic.GoBack(unBrowserHandle);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamHTMLSurface_GoForward(IntPtr pThis, uint unBrowserHandle)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamHTMLSurfaceLogic)handle.Target!;
        return logic.GoForward(unBrowserHandle);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamHTMLSurface_AddHeader(IntPtr pThis, uint unBrowserHandle, IntPtr pchKey, IntPtr pchValue)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamHTMLSurfaceLogic)handle.Target!;
        return logic.AddHeader(unBrowserHandle, pchKey, pchValue);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamHTMLSurface_ExecuteJavascript(IntPtr pThis, uint unBrowserHandle, IntPtr pchScript)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamHTMLSurfaceLogic)handle.Target!;
        return logic.ExecuteJavascript(unBrowserHandle, pchScript);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamHTMLSurface_MouseUp(IntPtr pThis, uint unBrowserHandle, int eMouseButton)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamHTMLSurfaceLogic)handle.Target!;
        return logic.MouseUp(unBrowserHandle, eMouseButton);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamHTMLSurface_MouseDown(IntPtr pThis, uint unBrowserHandle, int eMouseButton)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamHTMLSurfaceLogic)handle.Target!;
        return logic.MouseDown(unBrowserHandle, eMouseButton);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamHTMLSurface_MouseDoubleClick(IntPtr pThis, uint unBrowserHandle, int eMouseButton)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamHTMLSurfaceLogic)handle.Target!;
        return logic.MouseDoubleClick(unBrowserHandle, eMouseButton);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamHTMLSurface_MouseMove(IntPtr pThis, uint unBrowserHandle, int x, int y)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamHTMLSurfaceLogic)handle.Target!;
        return logic.MouseMove(unBrowserHandle, x, y);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamHTMLSurface_MouseWheel(IntPtr pThis, uint unBrowserHandle, int nDelta)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamHTMLSurfaceLogic)handle.Target!;
        return logic.MouseWheel(unBrowserHandle, nDelta);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamHTMLSurface_KeyDown(IntPtr pThis, uint unBrowserHandle, uint nNativeKeyCode, int eHTMLKeyModifiers, byte bIsSystemKey)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamHTMLSurfaceLogic)handle.Target!;
        return logic.KeyDown(unBrowserHandle, nNativeKeyCode, eHTMLKeyModifiers, bIsSystemKey);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamHTMLSurface_KeyUp(IntPtr pThis, uint unBrowserHandle, uint nNativeKeyCode, int eHTMLKeyModifiers)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamHTMLSurfaceLogic)handle.Target!;
        return logic.KeyUp(unBrowserHandle, nNativeKeyCode, eHTMLKeyModifiers);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamHTMLSurface_KeyChar(IntPtr pThis, uint unBrowserHandle, uint cUnicodeChar, int eHTMLKeyModifiers)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamHTMLSurfaceLogic)handle.Target!;
        return logic.KeyChar(unBrowserHandle, cUnicodeChar, eHTMLKeyModifiers);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamHTMLSurface_SetHorizontalScroll(IntPtr pThis, uint unBrowserHandle, uint nAbsolutePixelScroll)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamHTMLSurfaceLogic)handle.Target!;
        return logic.SetHorizontalScroll(unBrowserHandle, nAbsolutePixelScroll);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamHTMLSurface_SetVerticalScroll(IntPtr pThis, uint unBrowserHandle, uint nAbsolutePixelScroll)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamHTMLSurfaceLogic)handle.Target!;
        return logic.SetVerticalScroll(unBrowserHandle, nAbsolutePixelScroll);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamHTMLSurface_SetKeyFocus(IntPtr pThis, uint unBrowserHandle, byte bHasKeyFocus)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamHTMLSurfaceLogic)handle.Target!;
        return logic.SetKeyFocus(unBrowserHandle, bHasKeyFocus);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamHTMLSurface_ViewSource(IntPtr pThis, uint unBrowserHandle)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamHTMLSurfaceLogic)handle.Target!;
        return logic.ViewSource(unBrowserHandle);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamHTMLSurface_CopyToClipboard(IntPtr pThis, uint unBrowserHandle)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamHTMLSurfaceLogic)handle.Target!;
        return logic.CopyToClipboard(unBrowserHandle);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamHTMLSurface_PasteFromClipboard(IntPtr pThis, uint unBrowserHandle)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamHTMLSurfaceLogic)handle.Target!;
        return logic.PasteFromClipboard(unBrowserHandle);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamHTMLSurface_Find(IntPtr pThis, uint unBrowserHandle, IntPtr pchSearchStr, byte bCurrentlyInFind, byte bReverse)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamHTMLSurfaceLogic)handle.Target!;
        return logic.Find(unBrowserHandle, pchSearchStr, bCurrentlyInFind, bReverse);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamHTMLSurface_StopFind(IntPtr pThis, uint unBrowserHandle)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamHTMLSurfaceLogic)handle.Target!;
        return logic.StopFind(unBrowserHandle);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamHTMLSurface_GetLinkAtPosition(IntPtr pThis, uint unBrowserHandle, int x, int y)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamHTMLSurfaceLogic)handle.Target!;
        return logic.GetLinkAtPosition(unBrowserHandle, x, y);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamHTMLSurface_SetCookie(IntPtr pThis, IntPtr pchHostname, IntPtr pchKey, IntPtr pchValue, IntPtr pchPath, int nExpires, byte bSecure, byte bHTTPOnly)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamHTMLSurfaceLogic)handle.Target!;
        return logic.SetCookie(pchHostname, pchKey, pchValue, pchPath, nExpires, bSecure, bHTTPOnly);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamHTMLSurface_SetPageScaleFactor(IntPtr pThis, uint unBrowserHandle, int flZoom, int nPointX, int nPointY)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamHTMLSurfaceLogic)handle.Target!;
        return logic.SetPageScaleFactor(unBrowserHandle, flZoom, nPointX, nPointY);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamHTMLSurface_SetBackgroundMode(IntPtr pThis, uint unBrowserHandle, byte bBackgroundMode)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamHTMLSurfaceLogic)handle.Target!;
        return logic.SetBackgroundMode(unBrowserHandle, bBackgroundMode);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamHTMLSurface_SetDPIScalingFactor(IntPtr pThis, uint unBrowserHandle, int flDPIScaling)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamHTMLSurfaceLogic)handle.Target!;
        return logic.SetDPIScalingFactor(unBrowserHandle, flDPIScaling);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamHTMLSurface_OpenDeveloperTools(IntPtr pThis, uint unBrowserHandle)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamHTMLSurfaceLogic)handle.Target!;
        return logic.OpenDeveloperTools(unBrowserHandle);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamHTMLSurface_AllowStartRequest(IntPtr pThis, uint unBrowserHandle, byte bAllowed)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamHTMLSurfaceLogic)handle.Target!;
        return logic.AllowStartRequest(unBrowserHandle, bAllowed);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamHTMLSurface_JSDialogResponse(IntPtr pThis, uint unBrowserHandle, byte bResult)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamHTMLSurfaceLogic)handle.Target!;
        return logic.JSDialogResponse(unBrowserHandle, bResult);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamHTMLSurface_FileLoadDialogResponse(IntPtr pThis, uint unBrowserHandle, IntPtr pchSelectedFiles)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamHTMLSurfaceLogic)handle.Target!;
        return logic.FileLoadDialogResponse(unBrowserHandle, pchSelectedFiles);
    }
}

public unsafe class ISteamInventoryShim
{
    public static ISteamInventoryVTable VTable;
    public static IntPtr VTablePtr;

    static ISteamInventoryShim()
    {
        VTablePtr = (IntPtr)Unsafe.AsPointer(ref VTable);
        VTable.GetResultStatus = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int>)&ISteamInventory_GetResultStatus;
        VTable.GetResultItems = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, IntPtr, byte>)&ISteamInventory_GetResultItems;
        VTable.GetResultItemProperty = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, uint, IntPtr, IntPtr, IntPtr, byte>)&ISteamInventory_GetResultItemProperty;
        VTable.GetResultTimestamp = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, uint>)&ISteamInventory_GetResultTimestamp;
        VTable.CheckResultSteamID = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, ulong, byte>)&ISteamInventory_CheckResultSteamID;
        VTable.DestroyResult = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, void>)&ISteamInventory_DestroyResult;
        VTable.GetAllItems = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, byte>)&ISteamInventory_GetAllItems;
        VTable.GetItemsByID = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, IntPtr, uint, byte>)&ISteamInventory_GetItemsByID;
        VTable.SerializeResult = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, IntPtr, byte>)&ISteamInventory_SerializeResult;
        VTable.DeserializeResult = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, IntPtr, uint, byte, byte>)&ISteamInventory_DeserializeResult;
        VTable.GenerateItems = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, IntPtr, IntPtr, uint, byte>)&ISteamInventory_GenerateItems;
        VTable.GrantPromoItems = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, byte>)&ISteamInventory_GrantPromoItems;
        VTable.AddPromoItem = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, int, byte>)&ISteamInventory_AddPromoItem;
        VTable.AddPromoItems = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, IntPtr, uint, byte>)&ISteamInventory_AddPromoItems;
        VTable.ConsumeItem = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, int, uint, byte>)&ISteamInventory_ConsumeItem;
        VTable.ExchangeItems = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, IntPtr, IntPtr, uint, IntPtr, IntPtr, uint, byte>)&ISteamInventory_ExchangeItems;
        VTable.TransferItemQuantity = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, int, uint, int, byte>)&ISteamInventory_TransferItemQuantity;
        VTable.SendItemDropHeartbeat = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, void>)&ISteamInventory_SendItemDropHeartbeat;
        VTable.TriggerItemDrop = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, int, byte>)&ISteamInventory_TriggerItemDrop;
        VTable.TradeItems = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, ulong, IntPtr, IntPtr, uint, IntPtr, IntPtr, uint, byte>)&ISteamInventory_TradeItems;
        VTable.LoadItemDefinitions = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, byte>)&ISteamInventory_LoadItemDefinitions;
        VTable.GetItemDefinitionIDs = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, IntPtr, byte>)&ISteamInventory_GetItemDefinitionIDs;
        VTable.GetItemDefinitionProperty = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, IntPtr, IntPtr, byte>)&ISteamInventory_GetItemDefinitionProperty;
        VTable.RequestEligiblePromoItemDefinitionsIDs = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, ulong>)&ISteamInventory_RequestEligiblePromoItemDefinitionsIDs;
        VTable.GetEligiblePromoItemDefinitionIDs = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, IntPtr, IntPtr, byte>)&ISteamInventory_GetEligiblePromoItemDefinitionIDs;
        VTable.StartPurchase = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, IntPtr, uint, ulong>)&ISteamInventory_StartPurchase;
        VTable.RequestPrices = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong>)&ISteamInventory_RequestPrices;
        VTable.GetNumItemsWithPrices = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint>)&ISteamInventory_GetNumItemsWithPrices;
        VTable.GetItemsWithPrices = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, IntPtr, IntPtr, uint, byte>)&ISteamInventory_GetItemsWithPrices;
        VTable.GetItemPrice = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, IntPtr, byte>)&ISteamInventory_GetItemPrice;
        VTable.StartUpdateProperties = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int>)&ISteamInventory_StartUpdateProperties;
        VTable.RemoveProperty = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, IntPtr, byte>)&ISteamInventory_RemoveProperty;
        VTable.SetProperty = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, IntPtr, IntPtr, byte>)&ISteamInventory_SetProperty;
        VTable.SetProperty = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, IntPtr, byte, byte>)&ISteamInventory_SetProperty;
        VTable.SetProperty = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, IntPtr, long, byte>)&ISteamInventory_SetProperty;
        VTable.SetProperty = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, IntPtr, int, byte>)&ISteamInventory_SetProperty;
        VTable.SubmitUpdateProperties = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, byte>)&ISteamInventory_SubmitUpdateProperties;
        VTable.InspectItem = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, IntPtr, byte>)&ISteamInventory_InspectItem;
    }

    public static IntPtr Create(ISteamInventoryLogic logic)
    {
        var handle = GCHandle.Alloc(logic);
        var ptr = Marshal.AllocHGlobal(IntPtr.Size * 2);
        *(IntPtr*)ptr = VTablePtr;
        *(IntPtr*)((byte*)ptr + IntPtr.Size) = GCHandle.ToIntPtr(handle);
        return ptr;
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamInventory_GetResultStatus(IntPtr pThis, int resultHandle)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInventoryLogic)handle.Target!;
        return logic.GetResultStatus(resultHandle);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamInventory_GetResultItems(IntPtr pThis, int resultHandle, IntPtr pOutItemsArray, IntPtr punOutItemsArraySize)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInventoryLogic)handle.Target!;
        return logic.GetResultItems(resultHandle, pOutItemsArray, punOutItemsArraySize);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamInventory_GetResultItemProperty(IntPtr pThis, int resultHandle, uint unItemIndex, IntPtr pchPropertyName, IntPtr pchValueBuffer, IntPtr punValueBufferSizeOut)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInventoryLogic)handle.Target!;
        return logic.GetResultItemProperty(resultHandle, unItemIndex, pchPropertyName, pchValueBuffer, punValueBufferSizeOut);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static uint ISteamInventory_GetResultTimestamp(IntPtr pThis, int resultHandle)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInventoryLogic)handle.Target!;
        return logic.GetResultTimestamp(resultHandle);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamInventory_CheckResultSteamID(IntPtr pThis, int resultHandle, ulong steamIDExpected)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInventoryLogic)handle.Target!;
        return logic.CheckResultSteamID(resultHandle, steamIDExpected);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamInventory_DestroyResult(IntPtr pThis, int resultHandle)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInventoryLogic)handle.Target!;
        return logic.DestroyResult(resultHandle);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamInventory_GetAllItems(IntPtr pThis, IntPtr pResultHandle)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInventoryLogic)handle.Target!;
        return logic.GetAllItems(pResultHandle);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamInventory_GetItemsByID(IntPtr pThis, IntPtr pResultHandle, IntPtr pInstanceIDs, uint unCountInstanceIDs)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInventoryLogic)handle.Target!;
        return logic.GetItemsByID(pResultHandle, pInstanceIDs, unCountInstanceIDs);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamInventory_SerializeResult(IntPtr pThis, int resultHandle, IntPtr pOutBuffer, IntPtr punOutBufferSize)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInventoryLogic)handle.Target!;
        return logic.SerializeResult(resultHandle, pOutBuffer, punOutBufferSize);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamInventory_DeserializeResult(IntPtr pThis, IntPtr pOutResultHandle, IntPtr pBuffer, uint unBufferSize, byte bRESERVED_MUST_BE_FALSE)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInventoryLogic)handle.Target!;
        return logic.DeserializeResult(pOutResultHandle, pBuffer, unBufferSize, bRESERVED_MUST_BE_FALSE);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamInventory_GenerateItems(IntPtr pThis, IntPtr pResultHandle, IntPtr pArrayItemDefs, IntPtr punArrayQuantity, uint unArrayLength)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInventoryLogic)handle.Target!;
        return logic.GenerateItems(pResultHandle, pArrayItemDefs, punArrayQuantity, unArrayLength);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamInventory_GrantPromoItems(IntPtr pThis, IntPtr pResultHandle)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInventoryLogic)handle.Target!;
        return logic.GrantPromoItems(pResultHandle);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamInventory_AddPromoItem(IntPtr pThis, IntPtr pResultHandle, int itemDef)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInventoryLogic)handle.Target!;
        return logic.AddPromoItem(pResultHandle, itemDef);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamInventory_AddPromoItems(IntPtr pThis, IntPtr pResultHandle, IntPtr pArrayItemDefs, uint unArrayLength)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInventoryLogic)handle.Target!;
        return logic.AddPromoItems(pResultHandle, pArrayItemDefs, unArrayLength);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamInventory_ConsumeItem(IntPtr pThis, IntPtr pResultHandle, int itemConsume, uint unQuantity)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInventoryLogic)handle.Target!;
        return logic.ConsumeItem(pResultHandle, itemConsume, unQuantity);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamInventory_ExchangeItems(IntPtr pThis, IntPtr pResultHandle, IntPtr pArrayGenerate, IntPtr punArrayGenerateQuantity, uint unArrayGenerateLength, IntPtr pArrayDestroy, IntPtr punArrayDestroyQuantity, uint unArrayDestroyLength)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInventoryLogic)handle.Target!;
        return logic.ExchangeItems(pResultHandle, pArrayGenerate, punArrayGenerateQuantity, unArrayGenerateLength, pArrayDestroy, punArrayDestroyQuantity, unArrayDestroyLength);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamInventory_TransferItemQuantity(IntPtr pThis, IntPtr pResultHandle, int itemIdSource, uint unQuantity, int itemIdDest)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInventoryLogic)handle.Target!;
        return logic.TransferItemQuantity(pResultHandle, itemIdSource, unQuantity, itemIdDest);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamInventory_SendItemDropHeartbeat(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInventoryLogic)handle.Target!;
        return logic.SendItemDropHeartbeat();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamInventory_TriggerItemDrop(IntPtr pThis, IntPtr pResultHandle, int dropListDefinition)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInventoryLogic)handle.Target!;
        return logic.TriggerItemDrop(pResultHandle, dropListDefinition);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamInventory_TradeItems(IntPtr pThis, IntPtr pResultHandle, ulong steamIDTradePartner, IntPtr pArrayGive, IntPtr pArrayGiveQuantity, uint nArrayGiveLength, IntPtr pArrayGet, IntPtr pArrayGetQuantity, uint nArrayGetLength)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInventoryLogic)handle.Target!;
        return logic.TradeItems(pResultHandle, steamIDTradePartner, pArrayGive, pArrayGiveQuantity, nArrayGiveLength, pArrayGet, pArrayGetQuantity, nArrayGetLength);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamInventory_LoadItemDefinitions(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInventoryLogic)handle.Target!;
        return logic.LoadItemDefinitions();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamInventory_GetItemDefinitionIDs(IntPtr pThis, IntPtr pItemDefIDs, IntPtr punItemDefIDsArraySize)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInventoryLogic)handle.Target!;
        return logic.GetItemDefinitionIDs(pItemDefIDs, punItemDefIDsArraySize);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamInventory_GetItemDefinitionProperty(IntPtr pThis, int iDefinition, IntPtr pchPropertyName, IntPtr pchValueBuffer, IntPtr punValueBufferSizeOut)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInventoryLogic)handle.Target!;
        return logic.GetItemDefinitionProperty(iDefinition, pchPropertyName, pchValueBuffer, punValueBufferSizeOut);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamInventory_RequestEligiblePromoItemDefinitionsIDs(IntPtr pThis, ulong steamID)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInventoryLogic)handle.Target!;
        return logic.RequestEligiblePromoItemDefinitionsIDs(steamID);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamInventory_GetEligiblePromoItemDefinitionIDs(IntPtr pThis, ulong steamID, IntPtr pItemDefIDs, IntPtr punItemDefIDsArraySize)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInventoryLogic)handle.Target!;
        return logic.GetEligiblePromoItemDefinitionIDs(steamID, pItemDefIDs, punItemDefIDsArraySize);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamInventory_StartPurchase(IntPtr pThis, IntPtr pArrayItemDefs, IntPtr punArrayQuantity, uint unArrayLength)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInventoryLogic)handle.Target!;
        return logic.StartPurchase(pArrayItemDefs, punArrayQuantity, unArrayLength);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamInventory_RequestPrices(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInventoryLogic)handle.Target!;
        return logic.RequestPrices();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static uint ISteamInventory_GetNumItemsWithPrices(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInventoryLogic)handle.Target!;
        return logic.GetNumItemsWithPrices();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamInventory_GetItemsWithPrices(IntPtr pThis, IntPtr pArrayItemDefs, IntPtr pCurrentPrices, IntPtr pBasePrices, uint unArrayLength)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInventoryLogic)handle.Target!;
        return logic.GetItemsWithPrices(pArrayItemDefs, pCurrentPrices, pBasePrices, unArrayLength);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamInventory_GetItemPrice(IntPtr pThis, int iDefinition, IntPtr pCurrentPrice, IntPtr pBasePrice)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInventoryLogic)handle.Target!;
        return logic.GetItemPrice(iDefinition, pCurrentPrice, pBasePrice);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamInventory_StartUpdateProperties(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInventoryLogic)handle.Target!;
        return logic.StartUpdateProperties();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamInventory_RemoveProperty(IntPtr pThis, int handle, int nItemID, IntPtr pchPropertyName)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInventoryLogic)handle.Target!;
        return logic.RemoveProperty(handle, nItemID, pchPropertyName);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamInventory_SetProperty(IntPtr pThis, int handle, int nItemID, IntPtr pchPropertyName, IntPtr pchPropertyValue)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInventoryLogic)handle.Target!;
        return logic.SetProperty(handle, nItemID, pchPropertyName, pchPropertyValue);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamInventory_SetProperty(IntPtr pThis, int handle, int nItemID, IntPtr pchPropertyName, byte bValue)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInventoryLogic)handle.Target!;
        return logic.SetProperty(handle, nItemID, pchPropertyName, bValue);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamInventory_SetProperty(IntPtr pThis, int handle, int nItemID, IntPtr pchPropertyName, long nValue)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInventoryLogic)handle.Target!;
        return logic.SetProperty(handle, nItemID, pchPropertyName, nValue);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamInventory_SetProperty(IntPtr pThis, int handle, int nItemID, IntPtr pchPropertyName, int flValue)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInventoryLogic)handle.Target!;
        return logic.SetProperty(handle, nItemID, pchPropertyName, flValue);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamInventory_SubmitUpdateProperties(IntPtr pThis, int handle, IntPtr pResultHandle)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInventoryLogic)handle.Target!;
        return logic.SubmitUpdateProperties(handle, pResultHandle);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamInventory_InspectItem(IntPtr pThis, IntPtr pResultHandle, IntPtr pchItemToken)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamInventoryLogic)handle.Target!;
        return logic.InspectItem(pResultHandle, pchItemToken);
    }
}

public unsafe class ISteamTimelineShim
{
    public static ISteamTimelineVTable VTable;
    public static IntPtr VTablePtr;

    static ISteamTimelineShim()
    {
        VTablePtr = (IntPtr)Unsafe.AsPointer(ref VTable);
        VTable.SetTimelineTooltip = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, int, void>)&ISteamTimeline_SetTimelineTooltip;
        VTable.ClearTimelineTooltip = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, void>)&ISteamTimeline_ClearTimelineTooltip;
        VTable.SetTimelineGameMode = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, void>)&ISteamTimeline_SetTimelineGameMode;
        VTable.AddInstantaneousTimelineEvent = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, IntPtr, IntPtr, uint, int, int, int>)&ISteamTimeline_AddInstantaneousTimelineEvent;
        VTable.AddRangeTimelineEvent = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, IntPtr, IntPtr, uint, int, int, int, int>)&ISteamTimeline_AddRangeTimelineEvent;
        VTable.StartRangeTimelineEvent = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, IntPtr, IntPtr, uint, int, int, int>)&ISteamTimeline_StartRangeTimelineEvent;
        VTable.UpdateRangeTimelineEvent = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, IntPtr, IntPtr, uint, int, void>)&ISteamTimeline_UpdateRangeTimelineEvent;
        VTable.EndRangeTimelineEvent = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, void>)&ISteamTimeline_EndRangeTimelineEvent;
        VTable.RemoveTimelineEvent = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, void>)&ISteamTimeline_RemoveTimelineEvent;
        VTable.DoesEventRecordingExist = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, ulong>)&ISteamTimeline_DoesEventRecordingExist;
        VTable.StartGamePhase = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, void>)&ISteamTimeline_StartGamePhase;
        VTable.EndGamePhase = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, void>)&ISteamTimeline_EndGamePhase;
        VTable.SetGamePhaseID = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, void>)&ISteamTimeline_SetGamePhaseID;
        VTable.DoesGamePhaseRecordingExist = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, ulong>)&ISteamTimeline_DoesGamePhaseRecordingExist;
        VTable.AddGamePhaseTag = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, IntPtr, IntPtr, uint, void>)&ISteamTimeline_AddGamePhaseTag;
        VTable.SetGamePhaseAttribute = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, IntPtr, uint, void>)&ISteamTimeline_SetGamePhaseAttribute;
        VTable.OpenOverlayToGamePhase = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, void>)&ISteamTimeline_OpenOverlayToGamePhase;
        VTable.OpenOverlayToTimelineEvent = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, void>)&ISteamTimeline_OpenOverlayToTimelineEvent;
    }

    public static IntPtr Create(ISteamTimelineLogic logic)
    {
        var handle = GCHandle.Alloc(logic);
        var ptr = Marshal.AllocHGlobal(IntPtr.Size * 2);
        *(IntPtr*)ptr = VTablePtr;
        *(IntPtr*)((byte*)ptr + IntPtr.Size) = GCHandle.ToIntPtr(handle);
        return ptr;
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamTimeline_SetTimelineTooltip(IntPtr pThis, IntPtr pchDescription, int flTimeDelta)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamTimelineLogic)handle.Target!;
        return logic.SetTimelineTooltip(pchDescription, flTimeDelta);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamTimeline_ClearTimelineTooltip(IntPtr pThis, int flTimeDelta)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamTimelineLogic)handle.Target!;
        return logic.ClearTimelineTooltip(flTimeDelta);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamTimeline_SetTimelineGameMode(IntPtr pThis, int eMode)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamTimelineLogic)handle.Target!;
        return logic.SetTimelineGameMode(eMode);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamTimeline_AddInstantaneousTimelineEvent(IntPtr pThis, IntPtr pchTitle, IntPtr pchDescription, IntPtr pchIcon, uint unIconPriority, int flStartOffsetSeconds, int ePossibleClip)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamTimelineLogic)handle.Target!;
        return logic.AddInstantaneousTimelineEvent(pchTitle, pchDescription, pchIcon, unIconPriority, flStartOffsetSeconds, ePossibleClip);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamTimeline_AddRangeTimelineEvent(IntPtr pThis, IntPtr pchTitle, IntPtr pchDescription, IntPtr pchIcon, uint unIconPriority, int flStartOffsetSeconds, int flDuration, int ePossibleClip)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamTimelineLogic)handle.Target!;
        return logic.AddRangeTimelineEvent(pchTitle, pchDescription, pchIcon, unIconPriority, flStartOffsetSeconds, flDuration, ePossibleClip);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamTimeline_StartRangeTimelineEvent(IntPtr pThis, IntPtr pchTitle, IntPtr pchDescription, IntPtr pchIcon, uint unPriority, int flStartOffsetSeconds, int ePossibleClip)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamTimelineLogic)handle.Target!;
        return logic.StartRangeTimelineEvent(pchTitle, pchDescription, pchIcon, unPriority, flStartOffsetSeconds, ePossibleClip);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamTimeline_UpdateRangeTimelineEvent(IntPtr pThis, int ulEvent, IntPtr pchTitle, IntPtr pchDescription, IntPtr pchIcon, uint unPriority, int ePossibleClip)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamTimelineLogic)handle.Target!;
        return logic.UpdateRangeTimelineEvent(ulEvent, pchTitle, pchDescription, pchIcon, unPriority, ePossibleClip);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamTimeline_EndRangeTimelineEvent(IntPtr pThis, int ulEvent, int flEndOffsetSeconds)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamTimelineLogic)handle.Target!;
        return logic.EndRangeTimelineEvent(ulEvent, flEndOffsetSeconds);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamTimeline_RemoveTimelineEvent(IntPtr pThis, int ulEvent)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamTimelineLogic)handle.Target!;
        return logic.RemoveTimelineEvent(ulEvent);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamTimeline_DoesEventRecordingExist(IntPtr pThis, int ulEvent)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamTimelineLogic)handle.Target!;
        return logic.DoesEventRecordingExist(ulEvent);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamTimeline_StartGamePhase(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamTimelineLogic)handle.Target!;
        return logic.StartGamePhase();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamTimeline_EndGamePhase(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamTimelineLogic)handle.Target!;
        return logic.EndGamePhase();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamTimeline_SetGamePhaseID(IntPtr pThis, IntPtr pchPhaseID)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamTimelineLogic)handle.Target!;
        return logic.SetGamePhaseID(pchPhaseID);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamTimeline_DoesGamePhaseRecordingExist(IntPtr pThis, IntPtr pchPhaseID)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamTimelineLogic)handle.Target!;
        return logic.DoesGamePhaseRecordingExist(pchPhaseID);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamTimeline_AddGamePhaseTag(IntPtr pThis, IntPtr pchTagName, IntPtr pchTagIcon, IntPtr pchTagGroup, uint unPriority)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamTimelineLogic)handle.Target!;
        return logic.AddGamePhaseTag(pchTagName, pchTagIcon, pchTagGroup, unPriority);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamTimeline_SetGamePhaseAttribute(IntPtr pThis, IntPtr pchAttributeGroup, IntPtr pchAttributeValue, uint unPriority)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamTimelineLogic)handle.Target!;
        return logic.SetGamePhaseAttribute(pchAttributeGroup, pchAttributeValue, unPriority);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamTimeline_OpenOverlayToGamePhase(IntPtr pThis, IntPtr pchPhaseID)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamTimelineLogic)handle.Target!;
        return logic.OpenOverlayToGamePhase(pchPhaseID);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamTimeline_OpenOverlayToTimelineEvent(IntPtr pThis, int ulEvent)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamTimelineLogic)handle.Target!;
        return logic.OpenOverlayToTimelineEvent(ulEvent);
    }
}

public unsafe class ISteamVideoShim
{
    public static ISteamVideoVTable VTable;
    public static IntPtr VTablePtr;

    static ISteamVideoShim()
    {
        VTablePtr = (IntPtr)Unsafe.AsPointer(ref VTable);
        VTable.GetVideoURL = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, void>)&ISteamVideo_GetVideoURL;
        VTable.IsBroadcasting = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, byte>)&ISteamVideo_IsBroadcasting;
        VTable.GetOPFSettings = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, void>)&ISteamVideo_GetOPFSettings;
        VTable.GetOPFStringForApp = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, IntPtr, byte>)&ISteamVideo_GetOPFStringForApp;
    }

    public static IntPtr Create(ISteamVideoLogic logic)
    {
        var handle = GCHandle.Alloc(logic);
        var ptr = Marshal.AllocHGlobal(IntPtr.Size * 2);
        *(IntPtr*)ptr = VTablePtr;
        *(IntPtr*)((byte*)ptr + IntPtr.Size) = GCHandle.ToIntPtr(handle);
        return ptr;
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamVideo_GetVideoURL(IntPtr pThis, int unVideoAppID)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamVideoLogic)handle.Target!;
        return logic.GetVideoURL(unVideoAppID);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamVideo_IsBroadcasting(IntPtr pThis, IntPtr pnNumViewers)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamVideoLogic)handle.Target!;
        return logic.IsBroadcasting(pnNumViewers);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamVideo_GetOPFSettings(IntPtr pThis, int unVideoAppID)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamVideoLogic)handle.Target!;
        return logic.GetOPFSettings(unVideoAppID);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamVideo_GetOPFStringForApp(IntPtr pThis, int unVideoAppID, IntPtr pchBuffer, IntPtr pnBufferSize)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamVideoLogic)handle.Target!;
        return logic.GetOPFStringForApp(unVideoAppID, pchBuffer, pnBufferSize);
    }
}

public unsafe class ISteamParentalSettingsShim
{
    public static ISteamParentalSettingsVTable VTable;
    public static IntPtr VTablePtr;

    static ISteamParentalSettingsShim()
    {
        VTablePtr = (IntPtr)Unsafe.AsPointer(ref VTable);
        VTable.BIsParentalLockEnabled = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, byte>)&ISteamParentalSettings_BIsParentalLockEnabled;
        VTable.BIsParentalLockLocked = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, byte>)&ISteamParentalSettings_BIsParentalLockLocked;
        VTable.BIsAppBlocked = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, byte>)&ISteamParentalSettings_BIsAppBlocked;
        VTable.BIsAppInBlockList = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, byte>)&ISteamParentalSettings_BIsAppInBlockList;
        VTable.BIsFeatureBlocked = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, byte>)&ISteamParentalSettings_BIsFeatureBlocked;
        VTable.BIsFeatureInBlockList = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, byte>)&ISteamParentalSettings_BIsFeatureInBlockList;
    }

    public static IntPtr Create(ISteamParentalSettingsLogic logic)
    {
        var handle = GCHandle.Alloc(logic);
        var ptr = Marshal.AllocHGlobal(IntPtr.Size * 2);
        *(IntPtr*)ptr = VTablePtr;
        *(IntPtr*)((byte*)ptr + IntPtr.Size) = GCHandle.ToIntPtr(handle);
        return ptr;
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamParentalSettings_BIsParentalLockEnabled(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamParentalSettingsLogic)handle.Target!;
        return logic.BIsParentalLockEnabled();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamParentalSettings_BIsParentalLockLocked(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamParentalSettingsLogic)handle.Target!;
        return logic.BIsParentalLockLocked();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamParentalSettings_BIsAppBlocked(IntPtr pThis, int nAppID)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamParentalSettingsLogic)handle.Target!;
        return logic.BIsAppBlocked(nAppID);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamParentalSettings_BIsAppInBlockList(IntPtr pThis, int nAppID)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamParentalSettingsLogic)handle.Target!;
        return logic.BIsAppInBlockList(nAppID);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamParentalSettings_BIsFeatureBlocked(IntPtr pThis, int eFeature)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamParentalSettingsLogic)handle.Target!;
        return logic.BIsFeatureBlocked(eFeature);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamParentalSettings_BIsFeatureInBlockList(IntPtr pThis, int eFeature)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamParentalSettingsLogic)handle.Target!;
        return logic.BIsFeatureInBlockList(eFeature);
    }
}

public unsafe class ISteamRemotePlayShim
{
    public static ISteamRemotePlayVTable VTable;
    public static IntPtr VTablePtr;

    static ISteamRemotePlayShim()
    {
        VTablePtr = (IntPtr)Unsafe.AsPointer(ref VTable);
        VTable.GetSessionCount = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint>)&ISteamRemotePlay_GetSessionCount;
        VTable.GetSessionID = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int>)&ISteamRemotePlay_GetSessionID;
        VTable.GetSessionSteamID = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, ulong>)&ISteamRemotePlay_GetSessionSteamID;
        VTable.GetSessionClientName = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr>)&ISteamRemotePlay_GetSessionClientName;
        VTable.GetSessionClientFormFactor = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int>)&ISteamRemotePlay_GetSessionClientFormFactor;
        VTable.BGetSessionClientResolution = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, IntPtr, byte>)&ISteamRemotePlay_BGetSessionClientResolution;
        VTable.ShowRemotePlayTogetherUI = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, byte>)&ISteamRemotePlay_ShowRemotePlayTogetherUI;
        VTable.BSendRemotePlayTogetherInvite = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, byte>)&ISteamRemotePlay_BSendRemotePlayTogetherInvite;
        VTable.BEnableRemotePlayTogetherDirectInput = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, byte>)&ISteamRemotePlay_BEnableRemotePlayTogetherDirectInput;
        VTable.DisableRemotePlayTogetherDirectInput = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, void>)&ISteamRemotePlay_DisableRemotePlayTogetherDirectInput;
        VTable.GetInput = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, uint, uint>)&ISteamRemotePlay_GetInput;
        VTable.SetMouseVisibility = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, byte, void>)&ISteamRemotePlay_SetMouseVisibility;
        VTable.SetMousePosition = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, int, void>)&ISteamRemotePlay_SetMousePosition;
        VTable.CreateMouseCursor = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, int, int, IntPtr, int, int>)&ISteamRemotePlay_CreateMouseCursor;
        VTable.SetMouseCursor = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, void>)&ISteamRemotePlay_SetMouseCursor;
    }

    public static IntPtr Create(ISteamRemotePlayLogic logic)
    {
        var handle = GCHandle.Alloc(logic);
        var ptr = Marshal.AllocHGlobal(IntPtr.Size * 2);
        *(IntPtr*)ptr = VTablePtr;
        *(IntPtr*)((byte*)ptr + IntPtr.Size) = GCHandle.ToIntPtr(handle);
        return ptr;
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static uint ISteamRemotePlay_GetSessionCount(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamRemotePlayLogic)handle.Target!;
        return logic.GetSessionCount();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamRemotePlay_GetSessionID(IntPtr pThis, int iSessionIndex)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamRemotePlayLogic)handle.Target!;
        return logic.GetSessionID(iSessionIndex);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamRemotePlay_GetSessionSteamID(IntPtr pThis, int unSessionID)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamRemotePlayLogic)handle.Target!;
        return logic.GetSessionSteamID(unSessionID);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static IntPtr ISteamRemotePlay_GetSessionClientName(IntPtr pThis, int unSessionID)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamRemotePlayLogic)handle.Target!;
        return logic.GetSessionClientName(unSessionID);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamRemotePlay_GetSessionClientFormFactor(IntPtr pThis, int unSessionID)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamRemotePlayLogic)handle.Target!;
        return logic.GetSessionClientFormFactor(unSessionID);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamRemotePlay_BGetSessionClientResolution(IntPtr pThis, int unSessionID, IntPtr pnResolutionX, IntPtr pnResolutionY)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamRemotePlayLogic)handle.Target!;
        return logic.BGetSessionClientResolution(unSessionID, pnResolutionX, pnResolutionY);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamRemotePlay_ShowRemotePlayTogetherUI(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamRemotePlayLogic)handle.Target!;
        return logic.ShowRemotePlayTogetherUI();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamRemotePlay_BSendRemotePlayTogetherInvite(IntPtr pThis, ulong steamIDFriend)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamRemotePlayLogic)handle.Target!;
        return logic.BSendRemotePlayTogetherInvite(steamIDFriend);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamRemotePlay_BEnableRemotePlayTogetherDirectInput(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamRemotePlayLogic)handle.Target!;
        return logic.BEnableRemotePlayTogetherDirectInput();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamRemotePlay_DisableRemotePlayTogetherDirectInput(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamRemotePlayLogic)handle.Target!;
        return logic.DisableRemotePlayTogetherDirectInput();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static uint ISteamRemotePlay_GetInput(IntPtr pThis, IntPtr pInput, uint unMaxEvents)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamRemotePlayLogic)handle.Target!;
        return logic.GetInput(pInput, unMaxEvents);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamRemotePlay_SetMouseVisibility(IntPtr pThis, int unSessionID, byte bVisible)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamRemotePlayLogic)handle.Target!;
        return logic.SetMouseVisibility(unSessionID, bVisible);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamRemotePlay_SetMousePosition(IntPtr pThis, int unSessionID, int flNormalizedX, int flNormalizedY)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamRemotePlayLogic)handle.Target!;
        return logic.SetMousePosition(unSessionID, flNormalizedX, flNormalizedY);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamRemotePlay_CreateMouseCursor(IntPtr pThis, int nWidth, int nHeight, int nHotX, int nHotY, IntPtr pBGRA, int nPitch)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamRemotePlayLogic)handle.Target!;
        return logic.CreateMouseCursor(nWidth, nHeight, nHotX, nHotY, pBGRA, nPitch);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamRemotePlay_SetMouseCursor(IntPtr pThis, int unSessionID, int unCursorID)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamRemotePlayLogic)handle.Target!;
        return logic.SetMouseCursor(unSessionID, unCursorID);
    }
}

public unsafe class ISteamNetworkingMessagesShim
{
    public static ISteamNetworkingMessagesVTable VTable;
    public static IntPtr VTablePtr;

    static ISteamNetworkingMessagesShim()
    {
        VTablePtr = (IntPtr)Unsafe.AsPointer(ref VTable);
        VTable.SendMessageToUser = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, uint, int, int, int>)&ISteamNetworkingMessages_SendMessageToUser;
        VTable.ReceiveMessagesOnChannel = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, int, int>)&ISteamNetworkingMessages_ReceiveMessagesOnChannel;
        VTable.AcceptSessionWithUser = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, byte>)&ISteamNetworkingMessages_AcceptSessionWithUser;
        VTable.CloseSessionWithUser = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, byte>)&ISteamNetworkingMessages_CloseSessionWithUser;
        VTable.CloseChannelWithUser = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, byte>)&ISteamNetworkingMessages_CloseChannelWithUser;
        VTable.GetSessionConnectionInfo = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, IntPtr, int>)&ISteamNetworkingMessages_GetSessionConnectionInfo;
    }

    public static IntPtr Create(ISteamNetworkingMessagesLogic logic)
    {
        var handle = GCHandle.Alloc(logic);
        var ptr = Marshal.AllocHGlobal(IntPtr.Size * 2);
        *(IntPtr*)ptr = VTablePtr;
        *(IntPtr*)((byte*)ptr + IntPtr.Size) = GCHandle.ToIntPtr(handle);
        return ptr;
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamNetworkingMessages_SendMessageToUser(IntPtr pThis, int identityRemote, IntPtr pubData, uint cubData, int nSendFlags, int nRemoteChannel)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingMessagesLogic)handle.Target!;
        return logic.SendMessageToUser(identityRemote, pubData, cubData, nSendFlags, nRemoteChannel);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamNetworkingMessages_ReceiveMessagesOnChannel(IntPtr pThis, int nLocalChannel, IntPtr ppOutMessages, int nMaxMessages)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingMessagesLogic)handle.Target!;
        return logic.ReceiveMessagesOnChannel(nLocalChannel, ppOutMessages, nMaxMessages);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamNetworkingMessages_AcceptSessionWithUser(IntPtr pThis, int identityRemote)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingMessagesLogic)handle.Target!;
        return logic.AcceptSessionWithUser(identityRemote);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamNetworkingMessages_CloseSessionWithUser(IntPtr pThis, int identityRemote)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingMessagesLogic)handle.Target!;
        return logic.CloseSessionWithUser(identityRemote);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamNetworkingMessages_CloseChannelWithUser(IntPtr pThis, int identityRemote, int nLocalChannel)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingMessagesLogic)handle.Target!;
        return logic.CloseChannelWithUser(identityRemote, nLocalChannel);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamNetworkingMessages_GetSessionConnectionInfo(IntPtr pThis, int identityRemote, IntPtr pConnectionInfo, IntPtr pQuickStatus)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingMessagesLogic)handle.Target!;
        return logic.GetSessionConnectionInfo(identityRemote, pConnectionInfo, pQuickStatus);
    }
}

public unsafe class ISteamNetworkingSocketsShim
{
    public static ISteamNetworkingSocketsVTable VTable;
    public static IntPtr VTablePtr;

    static ISteamNetworkingSocketsShim()
    {
        VTablePtr = (IntPtr)Unsafe.AsPointer(ref VTable);
        VTable.CreateListenSocketIP = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, IntPtr, uint>)&ISteamNetworkingSockets_CreateListenSocketIP;
        VTable.ConnectByIPAddress = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, IntPtr, uint>)&ISteamNetworkingSockets_ConnectByIPAddress;
        VTable.CreateListenSocketP2P = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, IntPtr, uint>)&ISteamNetworkingSockets_CreateListenSocketP2P;
        VTable.ConnectP2P = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, int, IntPtr, uint>)&ISteamNetworkingSockets_ConnectP2P;
        VTable.AcceptConnection = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, int>)&ISteamNetworkingSockets_AcceptConnection;
        VTable.CloseConnection = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, int, IntPtr, byte, byte>)&ISteamNetworkingSockets_CloseConnection;
        VTable.CloseListenSocket = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, byte>)&ISteamNetworkingSockets_CloseListenSocket;
        VTable.SetConnectionUserData = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, long, byte>)&ISteamNetworkingSockets_SetConnectionUserData;
        VTable.GetConnectionUserData = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, long>)&ISteamNetworkingSockets_GetConnectionUserData;
        VTable.SetConnectionName = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, IntPtr, void>)&ISteamNetworkingSockets_SetConnectionName;
        VTable.GetConnectionName = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, IntPtr, int, byte>)&ISteamNetworkingSockets_GetConnectionName;
        VTable.SendMessageToConnection = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, IntPtr, uint, int, IntPtr, int>)&ISteamNetworkingSockets_SendMessageToConnection;
        VTable.SendMessages = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, IntPtr, void>)&ISteamNetworkingSockets_SendMessages;
        VTable.FlushMessagesOnConnection = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, int>)&ISteamNetworkingSockets_FlushMessagesOnConnection;
        VTable.ReceiveMessagesOnConnection = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, IntPtr, int, int>)&ISteamNetworkingSockets_ReceiveMessagesOnConnection;
        VTable.GetConnectionInfo = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, IntPtr, byte>)&ISteamNetworkingSockets_GetConnectionInfo;
        VTable.GetConnectionRealTimeStatus = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, IntPtr, int, IntPtr, int>)&ISteamNetworkingSockets_GetConnectionRealTimeStatus;
        VTable.GetDetailedConnectionStatus = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, IntPtr, int, int>)&ISteamNetworkingSockets_GetDetailedConnectionStatus;
        VTable.GetListenSocketAddress = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, IntPtr, byte>)&ISteamNetworkingSockets_GetListenSocketAddress;
        VTable.CreateSocketPair = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, IntPtr, byte, IntPtr, IntPtr, byte>)&ISteamNetworkingSockets_CreateSocketPair;
        VTable.ConfigureConnectionLanes = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, int, IntPtr, IntPtr, int>)&ISteamNetworkingSockets_ConfigureConnectionLanes;
        VTable.GetIdentity = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, byte>)&ISteamNetworkingSockets_GetIdentity;
        VTable.InitAuthentication = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int>)&ISteamNetworkingSockets_InitAuthentication;
        VTable.GetAuthenticationStatus = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, int>)&ISteamNetworkingSockets_GetAuthenticationStatus;
        VTable.CreatePollGroup = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint>)&ISteamNetworkingSockets_CreatePollGroup;
        VTable.DestroyPollGroup = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, byte>)&ISteamNetworkingSockets_DestroyPollGroup;
        VTable.SetConnectionPollGroup = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, uint, byte>)&ISteamNetworkingSockets_SetConnectionPollGroup;
        VTable.ReceiveMessagesOnPollGroup = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, IntPtr, int, int>)&ISteamNetworkingSockets_ReceiveMessagesOnPollGroup;
        VTable.ReceivedRelayAuthTicket = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, int, IntPtr, byte>)&ISteamNetworkingSockets_ReceivedRelayAuthTicket;
        VTable.FindRelayAuthTicketForServer = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, IntPtr, int>)&ISteamNetworkingSockets_FindRelayAuthTicketForServer;
        VTable.ConnectToHostedDedicatedServer = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, int, IntPtr, uint>)&ISteamNetworkingSockets_ConnectToHostedDedicatedServer;
        VTable.GetHostedDedicatedServerPort = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int>)&ISteamNetworkingSockets_GetHostedDedicatedServerPort;
        VTable.GetHostedDedicatedServerPOPID = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int>)&ISteamNetworkingSockets_GetHostedDedicatedServerPOPID;
        VTable.GetHostedDedicatedServerAddress = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, int>)&ISteamNetworkingSockets_GetHostedDedicatedServerAddress;
        VTable.CreateHostedDedicatedServerListenSocket = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, IntPtr, uint>)&ISteamNetworkingSockets_CreateHostedDedicatedServerListenSocket;
        VTable.GetGameCoordinatorServerLogin = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, IntPtr, IntPtr, int>)&ISteamNetworkingSockets_GetGameCoordinatorServerLogin;
        VTable.ConnectP2PCustomSignaling = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, IntPtr, int, int, IntPtr, uint>)&ISteamNetworkingSockets_ConnectP2PCustomSignaling;
        VTable.ReceivedP2PCustomSignal = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, int, IntPtr, byte>)&ISteamNetworkingSockets_ReceivedP2PCustomSignal;
        VTable.GetCertificateRequest = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, IntPtr, int, byte>)&ISteamNetworkingSockets_GetCertificateRequest;
        VTable.SetCertificate = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, int, int, byte>)&ISteamNetworkingSockets_SetCertificate;
        VTable.ResetIdentity = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, void>)&ISteamNetworkingSockets_ResetIdentity;
        VTable.RunCallbacks = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, void>)&ISteamNetworkingSockets_RunCallbacks;
        VTable.BeginAsyncRequestFakeIP = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, byte>)&ISteamNetworkingSockets_BeginAsyncRequestFakeIP;
        VTable.GetFakeIP = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, void>)&ISteamNetworkingSockets_GetFakeIP;
        VTable.CreateListenSocketP2PFakeIP = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, IntPtr, uint>)&ISteamNetworkingSockets_CreateListenSocketP2PFakeIP;
        VTable.GetRemoteFakeIPForConnection = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, IntPtr, int>)&ISteamNetworkingSockets_GetRemoteFakeIPForConnection;
        VTable.CreateFakeUDPPort = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr>)&ISteamNetworkingSockets_CreateFakeUDPPort;
    }

    public static IntPtr Create(ISteamNetworkingSocketsLogic logic)
    {
        var handle = GCHandle.Alloc(logic);
        var ptr = Marshal.AllocHGlobal(IntPtr.Size * 2);
        *(IntPtr*)ptr = VTablePtr;
        *(IntPtr*)((byte*)ptr + IntPtr.Size) = GCHandle.ToIntPtr(handle);
        return ptr;
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static uint ISteamNetworkingSockets_CreateListenSocketIP(IntPtr pThis, int localAddress, int nOptions, IntPtr pOptions)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingSocketsLogic)handle.Target!;
        return logic.CreateListenSocketIP(localAddress, nOptions, pOptions);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static uint ISteamNetworkingSockets_ConnectByIPAddress(IntPtr pThis, int address, int nOptions, IntPtr pOptions)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingSocketsLogic)handle.Target!;
        return logic.ConnectByIPAddress(address, nOptions, pOptions);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static uint ISteamNetworkingSockets_CreateListenSocketP2P(IntPtr pThis, int nLocalVirtualPort, int nOptions, IntPtr pOptions)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingSocketsLogic)handle.Target!;
        return logic.CreateListenSocketP2P(nLocalVirtualPort, nOptions, pOptions);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static uint ISteamNetworkingSockets_ConnectP2P(IntPtr pThis, int identityRemote, int nRemoteVirtualPort, int nOptions, IntPtr pOptions)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingSocketsLogic)handle.Target!;
        return logic.ConnectP2P(identityRemote, nRemoteVirtualPort, nOptions, pOptions);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamNetworkingSockets_AcceptConnection(IntPtr pThis, uint hConn)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingSocketsLogic)handle.Target!;
        return logic.AcceptConnection(hConn);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamNetworkingSockets_CloseConnection(IntPtr pThis, uint hPeer, int nReason, IntPtr pszDebug, byte bEnableLinger)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingSocketsLogic)handle.Target!;
        return logic.CloseConnection(hPeer, nReason, pszDebug, bEnableLinger);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamNetworkingSockets_CloseListenSocket(IntPtr pThis, uint hSocket)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingSocketsLogic)handle.Target!;
        return logic.CloseListenSocket(hSocket);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamNetworkingSockets_SetConnectionUserData(IntPtr pThis, uint hPeer, long nUserData)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingSocketsLogic)handle.Target!;
        return logic.SetConnectionUserData(hPeer, nUserData);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static long ISteamNetworkingSockets_GetConnectionUserData(IntPtr pThis, uint hPeer)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingSocketsLogic)handle.Target!;
        return logic.GetConnectionUserData(hPeer);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamNetworkingSockets_SetConnectionName(IntPtr pThis, uint hPeer, IntPtr pszName)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingSocketsLogic)handle.Target!;
        return logic.SetConnectionName(hPeer, pszName);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamNetworkingSockets_GetConnectionName(IntPtr pThis, uint hPeer, IntPtr pszName, int nMaxLen)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingSocketsLogic)handle.Target!;
        return logic.GetConnectionName(hPeer, pszName, nMaxLen);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamNetworkingSockets_SendMessageToConnection(IntPtr pThis, uint hConn, IntPtr pData, uint cbData, int nSendFlags, IntPtr pOutMessageNumber)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingSocketsLogic)handle.Target!;
        return logic.SendMessageToConnection(hConn, pData, cbData, nSendFlags, pOutMessageNumber);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamNetworkingSockets_SendMessages(IntPtr pThis, int nMessages, IntPtr pMessages, IntPtr pOutMessageNumberOrResult)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingSocketsLogic)handle.Target!;
        return logic.SendMessages(nMessages, pMessages, pOutMessageNumberOrResult);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamNetworkingSockets_FlushMessagesOnConnection(IntPtr pThis, uint hConn)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingSocketsLogic)handle.Target!;
        return logic.FlushMessagesOnConnection(hConn);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamNetworkingSockets_ReceiveMessagesOnConnection(IntPtr pThis, uint hConn, IntPtr ppOutMessages, int nMaxMessages)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingSocketsLogic)handle.Target!;
        return logic.ReceiveMessagesOnConnection(hConn, ppOutMessages, nMaxMessages);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamNetworkingSockets_GetConnectionInfo(IntPtr pThis, uint hConn, IntPtr pInfo)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingSocketsLogic)handle.Target!;
        return logic.GetConnectionInfo(hConn, pInfo);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamNetworkingSockets_GetConnectionRealTimeStatus(IntPtr pThis, uint hConn, IntPtr pStatus, int nLanes, IntPtr pLanes)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingSocketsLogic)handle.Target!;
        return logic.GetConnectionRealTimeStatus(hConn, pStatus, nLanes, pLanes);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamNetworkingSockets_GetDetailedConnectionStatus(IntPtr pThis, uint hConn, IntPtr pszBuf, int cbBuf)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingSocketsLogic)handle.Target!;
        return logic.GetDetailedConnectionStatus(hConn, pszBuf, cbBuf);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamNetworkingSockets_GetListenSocketAddress(IntPtr pThis, uint hSocket, IntPtr address)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingSocketsLogic)handle.Target!;
        return logic.GetListenSocketAddress(hSocket, address);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamNetworkingSockets_CreateSocketPair(IntPtr pThis, IntPtr pOutConnection1, IntPtr pOutConnection2, byte bUseNetworkLoopback, IntPtr pIdentity1, IntPtr pIdentity2)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingSocketsLogic)handle.Target!;
        return logic.CreateSocketPair(pOutConnection1, pOutConnection2, bUseNetworkLoopback, pIdentity1, pIdentity2);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamNetworkingSockets_ConfigureConnectionLanes(IntPtr pThis, uint hConn, int nNumLanes, IntPtr pLanePriorities, IntPtr pLaneWeights)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingSocketsLogic)handle.Target!;
        return logic.ConfigureConnectionLanes(hConn, nNumLanes, pLanePriorities, pLaneWeights);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamNetworkingSockets_GetIdentity(IntPtr pThis, IntPtr pIdentity)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingSocketsLogic)handle.Target!;
        return logic.GetIdentity(pIdentity);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamNetworkingSockets_InitAuthentication(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingSocketsLogic)handle.Target!;
        return logic.InitAuthentication();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamNetworkingSockets_GetAuthenticationStatus(IntPtr pThis, IntPtr pDetails)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingSocketsLogic)handle.Target!;
        return logic.GetAuthenticationStatus(pDetails);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static uint ISteamNetworkingSockets_CreatePollGroup(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingSocketsLogic)handle.Target!;
        return logic.CreatePollGroup();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamNetworkingSockets_DestroyPollGroup(IntPtr pThis, uint hPollGroup)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingSocketsLogic)handle.Target!;
        return logic.DestroyPollGroup(hPollGroup);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamNetworkingSockets_SetConnectionPollGroup(IntPtr pThis, uint hConn, uint hPollGroup)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingSocketsLogic)handle.Target!;
        return logic.SetConnectionPollGroup(hConn, hPollGroup);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamNetworkingSockets_ReceiveMessagesOnPollGroup(IntPtr pThis, uint hPollGroup, IntPtr ppOutMessages, int nMaxMessages)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingSocketsLogic)handle.Target!;
        return logic.ReceiveMessagesOnPollGroup(hPollGroup, ppOutMessages, nMaxMessages);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamNetworkingSockets_ReceivedRelayAuthTicket(IntPtr pThis, IntPtr pvTicket, int cbTicket, IntPtr pOutParsedTicket)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingSocketsLogic)handle.Target!;
        return logic.ReceivedRelayAuthTicket(pvTicket, cbTicket, pOutParsedTicket);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamNetworkingSockets_FindRelayAuthTicketForServer(IntPtr pThis, int identityGameServer, int nRemoteVirtualPort, IntPtr pOutParsedTicket)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingSocketsLogic)handle.Target!;
        return logic.FindRelayAuthTicketForServer(identityGameServer, nRemoteVirtualPort, pOutParsedTicket);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static uint ISteamNetworkingSockets_ConnectToHostedDedicatedServer(IntPtr pThis, int identityTarget, int nRemoteVirtualPort, int nOptions, IntPtr pOptions)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingSocketsLogic)handle.Target!;
        return logic.ConnectToHostedDedicatedServer(identityTarget, nRemoteVirtualPort, nOptions, pOptions);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamNetworkingSockets_GetHostedDedicatedServerPort(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingSocketsLogic)handle.Target!;
        return logic.GetHostedDedicatedServerPort();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamNetworkingSockets_GetHostedDedicatedServerPOPID(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingSocketsLogic)handle.Target!;
        return logic.GetHostedDedicatedServerPOPID();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamNetworkingSockets_GetHostedDedicatedServerAddress(IntPtr pThis, IntPtr pRouting)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingSocketsLogic)handle.Target!;
        return logic.GetHostedDedicatedServerAddress(pRouting);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static uint ISteamNetworkingSockets_CreateHostedDedicatedServerListenSocket(IntPtr pThis, int nLocalVirtualPort, int nOptions, IntPtr pOptions)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingSocketsLogic)handle.Target!;
        return logic.CreateHostedDedicatedServerListenSocket(nLocalVirtualPort, nOptions, pOptions);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamNetworkingSockets_GetGameCoordinatorServerLogin(IntPtr pThis, IntPtr pLoginInfo, IntPtr pcbSignedBlob, IntPtr pBlob)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingSocketsLogic)handle.Target!;
        return logic.GetGameCoordinatorServerLogin(pLoginInfo, pcbSignedBlob, pBlob);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static uint ISteamNetworkingSockets_ConnectP2PCustomSignaling(IntPtr pThis, IntPtr pSignaling, IntPtr pPeerIdentity, int nRemoteVirtualPort, int nOptions, IntPtr pOptions)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingSocketsLogic)handle.Target!;
        return logic.ConnectP2PCustomSignaling(pSignaling, pPeerIdentity, nRemoteVirtualPort, nOptions, pOptions);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamNetworkingSockets_ReceivedP2PCustomSignal(IntPtr pThis, IntPtr pMsg, int cbMsg, IntPtr pContext)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingSocketsLogic)handle.Target!;
        return logic.ReceivedP2PCustomSignal(pMsg, cbMsg, pContext);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamNetworkingSockets_GetCertificateRequest(IntPtr pThis, IntPtr pcbBlob, IntPtr pBlob, int errMsg)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingSocketsLogic)handle.Target!;
        return logic.GetCertificateRequest(pcbBlob, pBlob, errMsg);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamNetworkingSockets_SetCertificate(IntPtr pThis, IntPtr pCertificate, int cbCertificate, int errMsg)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingSocketsLogic)handle.Target!;
        return logic.SetCertificate(pCertificate, cbCertificate, errMsg);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamNetworkingSockets_ResetIdentity(IntPtr pThis, IntPtr pIdentity)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingSocketsLogic)handle.Target!;
        return logic.ResetIdentity(pIdentity);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamNetworkingSockets_RunCallbacks(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingSocketsLogic)handle.Target!;
        return logic.RunCallbacks();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamNetworkingSockets_BeginAsyncRequestFakeIP(IntPtr pThis, int nNumPorts)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingSocketsLogic)handle.Target!;
        return logic.BeginAsyncRequestFakeIP(nNumPorts);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamNetworkingSockets_GetFakeIP(IntPtr pThis, int idxFirstPort, IntPtr pInfo)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingSocketsLogic)handle.Target!;
        return logic.GetFakeIP(idxFirstPort, pInfo);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static uint ISteamNetworkingSockets_CreateListenSocketP2PFakeIP(IntPtr pThis, int idxFakePort, int nOptions, IntPtr pOptions)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingSocketsLogic)handle.Target!;
        return logic.CreateListenSocketP2PFakeIP(idxFakePort, nOptions, pOptions);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamNetworkingSockets_GetRemoteFakeIPForConnection(IntPtr pThis, uint hConn, IntPtr pOutAddr)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingSocketsLogic)handle.Target!;
        return logic.GetRemoteFakeIPForConnection(hConn, pOutAddr);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static IntPtr ISteamNetworkingSockets_CreateFakeUDPPort(IntPtr pThis, int idxFakeServerPort)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingSocketsLogic)handle.Target!;
        return logic.CreateFakeUDPPort(idxFakeServerPort);
    }
}

public unsafe class ISteamNetworkingUtilsShim
{
    public static ISteamNetworkingUtilsVTable VTable;
    public static IntPtr VTablePtr;

    static ISteamNetworkingUtilsShim()
    {
        VTablePtr = (IntPtr)Unsafe.AsPointer(ref VTable);
        VTable.AllocateMessage = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr>)&ISteamNetworkingUtils_AllocateMessage;
        VTable.InitRelayNetworkAccess = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, void>)&ISteamNetworkingUtils_InitRelayNetworkAccess;
        VTable.GetRelayNetworkStatus = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, int>)&ISteamNetworkingUtils_GetRelayNetworkStatus;
        VTable.GetLocalPingLocation = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int>)&ISteamNetworkingUtils_GetLocalPingLocation;
        VTable.EstimatePingTimeBetweenTwoLocations = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, int>)&ISteamNetworkingUtils_EstimatePingTimeBetweenTwoLocations;
        VTable.EstimatePingTimeFromLocalHost = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int>)&ISteamNetworkingUtils_EstimatePingTimeFromLocalHost;
        VTable.ConvertPingLocationToString = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, int, void>)&ISteamNetworkingUtils_ConvertPingLocationToString;
        VTable.ParsePingLocationString = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, int, byte>)&ISteamNetworkingUtils_ParsePingLocationString;
        VTable.CheckPingDataUpToDate = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, byte>)&ISteamNetworkingUtils_CheckPingDataUpToDate;
        VTable.GetPingToDataCenter = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, int>)&ISteamNetworkingUtils_GetPingToDataCenter;
        VTable.GetDirectPingToPOP = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int>)&ISteamNetworkingUtils_GetDirectPingToPOP;
        VTable.GetPOPCount = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int>)&ISteamNetworkingUtils_GetPOPCount;
        VTable.GetPOPList = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, int, int>)&ISteamNetworkingUtils_GetPOPList;
        VTable.GetLocalTimestamp = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int>)&ISteamNetworkingUtils_GetLocalTimestamp;
        VTable.SetDebugOutputFunction = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, void>)&ISteamNetworkingUtils_SetDebugOutputFunction;
        VTable.IsFakeIPv4 = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, byte>)&ISteamNetworkingUtils_IsFakeIPv4;
        VTable.GetIPv4FakeIPType = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, int>)&ISteamNetworkingUtils_GetIPv4FakeIPType;
        VTable.GetRealIdentityForFakeIP = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, int>)&ISteamNetworkingUtils_GetRealIdentityForFakeIP;
        VTable.SetGlobalConfigValueInt32 = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, byte>)&ISteamNetworkingUtils_SetGlobalConfigValueInt32;
        VTable.SetGlobalConfigValueFloat = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, byte>)&ISteamNetworkingUtils_SetGlobalConfigValueFloat;
        VTable.SetGlobalConfigValueString = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, byte>)&ISteamNetworkingUtils_SetGlobalConfigValueString;
        VTable.SetGlobalConfigValuePtr = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, byte>)&ISteamNetworkingUtils_SetGlobalConfigValuePtr;
        VTable.SetConnectionConfigValueInt32 = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, int, int, byte>)&ISteamNetworkingUtils_SetConnectionConfigValueInt32;
        VTable.SetConnectionConfigValueFloat = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, int, int, byte>)&ISteamNetworkingUtils_SetConnectionConfigValueFloat;
        VTable.SetConnectionConfigValueString = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, int, IntPtr, byte>)&ISteamNetworkingUtils_SetConnectionConfigValueString;
        VTable.SetGlobalCallback_SteamNetConnectionStatusChanged = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, byte>)&ISteamNetworkingUtils_SetGlobalCallback_SteamNetConnectionStatusChanged;
        VTable.SetGlobalCallback_SteamNetAuthenticationStatusChanged = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, byte>)&ISteamNetworkingUtils_SetGlobalCallback_SteamNetAuthenticationStatusChanged;
        VTable.SetGlobalCallback_SteamRelayNetworkStatusChanged = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, byte>)&ISteamNetworkingUtils_SetGlobalCallback_SteamRelayNetworkStatusChanged;
        VTable.SetGlobalCallback_FakeIPResult = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, byte>)&ISteamNetworkingUtils_SetGlobalCallback_FakeIPResult;
        VTable.SetGlobalCallback_MessagesSessionRequest = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, byte>)&ISteamNetworkingUtils_SetGlobalCallback_MessagesSessionRequest;
        VTable.SetGlobalCallback_MessagesSessionFailed = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, byte>)&ISteamNetworkingUtils_SetGlobalCallback_MessagesSessionFailed;
        VTable.SetConfigValue = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, int, int, IntPtr, byte>)&ISteamNetworkingUtils_SetConfigValue;
        VTable.SetConfigValueStruct = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, int, byte>)&ISteamNetworkingUtils_SetConfigValueStruct;
        VTable.GetConfigValue = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int, int, IntPtr, IntPtr, IntPtr, int>)&ISteamNetworkingUtils_GetConfigValue;
        VTable.GetConfigValueInfo = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, IntPtr, IntPtr>)&ISteamNetworkingUtils_GetConfigValueInfo;
        VTable.IterateGenericEditableConfigValues = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, byte, int>)&ISteamNetworkingUtils_IterateGenericEditableConfigValues;
        VTable.SteamNetworkingIPAddr_ToString = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, uint, byte, void>)&ISteamNetworkingUtils_SteamNetworkingIPAddr_ToString;
        VTable.SteamNetworkingIPAddr_ParseString = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, IntPtr, byte>)&ISteamNetworkingUtils_SteamNetworkingIPAddr_ParseString;
        VTable.SteamNetworkingIPAddr_GetFakeIPType = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, int>)&ISteamNetworkingUtils_SteamNetworkingIPAddr_GetFakeIPType;
        VTable.SteamNetworkingIdentity_ToString = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, uint, void>)&ISteamNetworkingUtils_SteamNetworkingIdentity_ToString;
        VTable.SteamNetworkingIdentity_ParseString = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, IntPtr, byte>)&ISteamNetworkingUtils_SteamNetworkingIdentity_ParseString;
    }

    public static IntPtr Create(ISteamNetworkingUtilsLogic logic)
    {
        var handle = GCHandle.Alloc(logic);
        var ptr = Marshal.AllocHGlobal(IntPtr.Size * 2);
        *(IntPtr*)ptr = VTablePtr;
        *(IntPtr*)((byte*)ptr + IntPtr.Size) = GCHandle.ToIntPtr(handle);
        return ptr;
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static IntPtr ISteamNetworkingUtils_AllocateMessage(IntPtr pThis, int cbAllocateBuffer)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingUtilsLogic)handle.Target!;
        return logic.AllocateMessage(cbAllocateBuffer);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamNetworkingUtils_InitRelayNetworkAccess(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingUtilsLogic)handle.Target!;
        return logic.InitRelayNetworkAccess();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamNetworkingUtils_GetRelayNetworkStatus(IntPtr pThis, IntPtr pDetails)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingUtilsLogic)handle.Target!;
        return logic.GetRelayNetworkStatus(pDetails);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamNetworkingUtils_GetLocalPingLocation(IntPtr pThis, int result)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingUtilsLogic)handle.Target!;
        return logic.GetLocalPingLocation(result);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamNetworkingUtils_EstimatePingTimeBetweenTwoLocations(IntPtr pThis, int location1, int location2)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingUtilsLogic)handle.Target!;
        return logic.EstimatePingTimeBetweenTwoLocations(location1, location2);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamNetworkingUtils_EstimatePingTimeFromLocalHost(IntPtr pThis, int remoteLocation)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingUtilsLogic)handle.Target!;
        return logic.EstimatePingTimeFromLocalHost(remoteLocation);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamNetworkingUtils_ConvertPingLocationToString(IntPtr pThis, int location, IntPtr pszBuf, int cchBufSize)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingUtilsLogic)handle.Target!;
        return logic.ConvertPingLocationToString(location, pszBuf, cchBufSize);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamNetworkingUtils_ParsePingLocationString(IntPtr pThis, IntPtr pszString, int result)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingUtilsLogic)handle.Target!;
        return logic.ParsePingLocationString(pszString, result);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamNetworkingUtils_CheckPingDataUpToDate(IntPtr pThis, int flMaxAgeSeconds)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingUtilsLogic)handle.Target!;
        return logic.CheckPingDataUpToDate(flMaxAgeSeconds);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamNetworkingUtils_GetPingToDataCenter(IntPtr pThis, int popID, IntPtr pViaRelayPoP)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingUtilsLogic)handle.Target!;
        return logic.GetPingToDataCenter(popID, pViaRelayPoP);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamNetworkingUtils_GetDirectPingToPOP(IntPtr pThis, int popID)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingUtilsLogic)handle.Target!;
        return logic.GetDirectPingToPOP(popID);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamNetworkingUtils_GetPOPCount(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingUtilsLogic)handle.Target!;
        return logic.GetPOPCount();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamNetworkingUtils_GetPOPList(IntPtr pThis, IntPtr list, int nListSz)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingUtilsLogic)handle.Target!;
        return logic.GetPOPList(list, nListSz);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamNetworkingUtils_GetLocalTimestamp(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingUtilsLogic)handle.Target!;
        return logic.GetLocalTimestamp();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamNetworkingUtils_SetDebugOutputFunction(IntPtr pThis, int eDetailLevel, int pfnFunc)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingUtilsLogic)handle.Target!;
        return logic.SetDebugOutputFunction(eDetailLevel, pfnFunc);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamNetworkingUtils_IsFakeIPv4(IntPtr pThis, uint nIPv4)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingUtilsLogic)handle.Target!;
        return logic.IsFakeIPv4(nIPv4);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamNetworkingUtils_GetIPv4FakeIPType(IntPtr pThis, uint nIPv4)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingUtilsLogic)handle.Target!;
        return logic.GetIPv4FakeIPType(nIPv4);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamNetworkingUtils_GetRealIdentityForFakeIP(IntPtr pThis, int fakeIP, IntPtr pOutRealIdentity)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingUtilsLogic)handle.Target!;
        return logic.GetRealIdentityForFakeIP(fakeIP, pOutRealIdentity);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamNetworkingUtils_SetGlobalConfigValueInt32(IntPtr pThis, int eValue, int val)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingUtilsLogic)handle.Target!;
        return logic.SetGlobalConfigValueInt32(eValue, val);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamNetworkingUtils_SetGlobalConfigValueFloat(IntPtr pThis, int eValue, int val)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingUtilsLogic)handle.Target!;
        return logic.SetGlobalConfigValueFloat(eValue, val);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamNetworkingUtils_SetGlobalConfigValueString(IntPtr pThis, int eValue, IntPtr val)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingUtilsLogic)handle.Target!;
        return logic.SetGlobalConfigValueString(eValue, val);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamNetworkingUtils_SetGlobalConfigValuePtr(IntPtr pThis, int eValue, IntPtr val)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingUtilsLogic)handle.Target!;
        return logic.SetGlobalConfigValuePtr(eValue, val);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamNetworkingUtils_SetConnectionConfigValueInt32(IntPtr pThis, uint hConn, int eValue, int val)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingUtilsLogic)handle.Target!;
        return logic.SetConnectionConfigValueInt32(hConn, eValue, val);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamNetworkingUtils_SetConnectionConfigValueFloat(IntPtr pThis, uint hConn, int eValue, int val)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingUtilsLogic)handle.Target!;
        return logic.SetConnectionConfigValueFloat(hConn, eValue, val);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamNetworkingUtils_SetConnectionConfigValueString(IntPtr pThis, uint hConn, int eValue, IntPtr val)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingUtilsLogic)handle.Target!;
        return logic.SetConnectionConfigValueString(hConn, eValue, val);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamNetworkingUtils_SetGlobalCallback_SteamNetConnectionStatusChanged(IntPtr pThis, int fnCallback)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingUtilsLogic)handle.Target!;
        return logic.SetGlobalCallback_SteamNetConnectionStatusChanged(fnCallback);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamNetworkingUtils_SetGlobalCallback_SteamNetAuthenticationStatusChanged(IntPtr pThis, int fnCallback)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingUtilsLogic)handle.Target!;
        return logic.SetGlobalCallback_SteamNetAuthenticationStatusChanged(fnCallback);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamNetworkingUtils_SetGlobalCallback_SteamRelayNetworkStatusChanged(IntPtr pThis, int fnCallback)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingUtilsLogic)handle.Target!;
        return logic.SetGlobalCallback_SteamRelayNetworkStatusChanged(fnCallback);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamNetworkingUtils_SetGlobalCallback_FakeIPResult(IntPtr pThis, int fnCallback)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingUtilsLogic)handle.Target!;
        return logic.SetGlobalCallback_FakeIPResult(fnCallback);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamNetworkingUtils_SetGlobalCallback_MessagesSessionRequest(IntPtr pThis, int fnCallback)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingUtilsLogic)handle.Target!;
        return logic.SetGlobalCallback_MessagesSessionRequest(fnCallback);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamNetworkingUtils_SetGlobalCallback_MessagesSessionFailed(IntPtr pThis, int fnCallback)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingUtilsLogic)handle.Target!;
        return logic.SetGlobalCallback_MessagesSessionFailed(fnCallback);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamNetworkingUtils_SetConfigValue(IntPtr pThis, int eValue, int eScopeType, int scopeObj, int eDataType, IntPtr pArg)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingUtilsLogic)handle.Target!;
        return logic.SetConfigValue(eValue, eScopeType, scopeObj, eDataType, pArg);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamNetworkingUtils_SetConfigValueStruct(IntPtr pThis, int opt, int eScopeType, int scopeObj)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingUtilsLogic)handle.Target!;
        return logic.SetConfigValueStruct(opt, eScopeType, scopeObj);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamNetworkingUtils_GetConfigValue(IntPtr pThis, int eValue, int eScopeType, int scopeObj, IntPtr pOutDataType, IntPtr pResult, IntPtr cbResult)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingUtilsLogic)handle.Target!;
        return logic.GetConfigValue(eValue, eScopeType, scopeObj, pOutDataType, pResult, cbResult);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static IntPtr ISteamNetworkingUtils_GetConfigValueInfo(IntPtr pThis, int eValue, IntPtr pOutDataType, IntPtr pOutScope)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingUtilsLogic)handle.Target!;
        return logic.GetConfigValueInfo(eValue, pOutDataType, pOutScope);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamNetworkingUtils_IterateGenericEditableConfigValues(IntPtr pThis, int eCurrent, byte bEnumerateDevVars)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingUtilsLogic)handle.Target!;
        return logic.IterateGenericEditableConfigValues(eCurrent, bEnumerateDevVars);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamNetworkingUtils_SteamNetworkingIPAddr_ToString(IntPtr pThis, int addr, IntPtr buf, uint cbBuf, byte bWithPort)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingUtilsLogic)handle.Target!;
        return logic.SteamNetworkingIPAddr_ToString(addr, buf, cbBuf, bWithPort);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamNetworkingUtils_SteamNetworkingIPAddr_ParseString(IntPtr pThis, IntPtr pAddr, IntPtr pszStr)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingUtilsLogic)handle.Target!;
        return logic.SteamNetworkingIPAddr_ParseString(pAddr, pszStr);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamNetworkingUtils_SteamNetworkingIPAddr_GetFakeIPType(IntPtr pThis, int addr)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingUtilsLogic)handle.Target!;
        return logic.SteamNetworkingIPAddr_GetFakeIPType(addr);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamNetworkingUtils_SteamNetworkingIdentity_ToString(IntPtr pThis, int identity, IntPtr buf, uint cbBuf)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingUtilsLogic)handle.Target!;
        return logic.SteamNetworkingIdentity_ToString(identity, buf, cbBuf);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamNetworkingUtils_SteamNetworkingIdentity_ParseString(IntPtr pThis, IntPtr pIdentity, IntPtr pszStr)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingUtilsLogic)handle.Target!;
        return logic.SteamNetworkingIdentity_ParseString(pIdentity, pszStr);
    }
}

public unsafe class ISteamGameServerShim
{
    public static ISteamGameServerVTable VTable;
    public static IntPtr VTablePtr;

    static ISteamGameServerShim()
    {
        VTablePtr = (IntPtr)Unsafe.AsPointer(ref VTable);
        VTable.SetProduct = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, void>)&ISteamGameServer_SetProduct;
        VTable.SetGameDescription = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, void>)&ISteamGameServer_SetGameDescription;
        VTable.SetModDir = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, void>)&ISteamGameServer_SetModDir;
        VTable.SetDedicatedServer = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, byte, void>)&ISteamGameServer_SetDedicatedServer;
        VTable.LogOn = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, void>)&ISteamGameServer_LogOn;
        VTable.LogOnAnonymous = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, void>)&ISteamGameServer_LogOnAnonymous;
        VTable.LogOff = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, void>)&ISteamGameServer_LogOff;
        VTable.BLoggedOn = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, byte>)&ISteamGameServer_BLoggedOn;
        VTable.BSecure = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, byte>)&ISteamGameServer_BSecure;
        VTable.GetSteamID = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong>)&ISteamGameServer_GetSteamID;
        VTable.WasRestartRequested = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, byte>)&ISteamGameServer_WasRestartRequested;
        VTable.SetMaxPlayerCount = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, void>)&ISteamGameServer_SetMaxPlayerCount;
        VTable.SetBotPlayerCount = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, void>)&ISteamGameServer_SetBotPlayerCount;
        VTable.SetServerName = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, void>)&ISteamGameServer_SetServerName;
        VTable.SetMapName = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, void>)&ISteamGameServer_SetMapName;
        VTable.SetPasswordProtected = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, byte, void>)&ISteamGameServer_SetPasswordProtected;
        VTable.SetSpectatorPort = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, void>)&ISteamGameServer_SetSpectatorPort;
        VTable.SetSpectatorServerName = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, void>)&ISteamGameServer_SetSpectatorServerName;
        VTable.ClearAllKeyValues = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, void>)&ISteamGameServer_ClearAllKeyValues;
        VTable.SetKeyValue = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, IntPtr, void>)&ISteamGameServer_SetKeyValue;
        VTable.SetGameTags = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, void>)&ISteamGameServer_SetGameTags;
        VTable.SetGameData = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, void>)&ISteamGameServer_SetGameData;
        VTable.SetRegion = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, void>)&ISteamGameServer_SetRegion;
        VTable.SetAdvertiseServerActive = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, byte, void>)&ISteamGameServer_SetAdvertiseServerActive;
        VTable.GetAuthSessionTicket = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, int, IntPtr, IntPtr, uint>)&ISteamGameServer_GetAuthSessionTicket;
        VTable.BeginAuthSession = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, int, ulong, int>)&ISteamGameServer_BeginAuthSession;
        VTable.EndAuthSession = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, void>)&ISteamGameServer_EndAuthSession;
        VTable.CancelAuthTicket = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, void>)&ISteamGameServer_CancelAuthTicket;
        VTable.UserHasLicenseForApp = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, int, int>)&ISteamGameServer_UserHasLicenseForApp;
        VTable.RequestUserGroupStatus = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, ulong, byte>)&ISteamGameServer_RequestUserGroupStatus;
        VTable.GetGameplayStats = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, void>)&ISteamGameServer_GetGameplayStats;
        VTable.GetServerReputation = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong>)&ISteamGameServer_GetServerReputation;
        VTable.GetPublicIP = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int>)&ISteamGameServer_GetPublicIP;
        VTable.HandleIncomingPacket = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, int, uint, int, byte>)&ISteamGameServer_HandleIncomingPacket;
        VTable.GetNextOutgoingPacket = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, int, IntPtr, IntPtr, int>)&ISteamGameServer_GetNextOutgoingPacket;
        VTable.AssociateWithClan = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, ulong>)&ISteamGameServer_AssociateWithClan;
        VTable.ComputeNewPlayerCompatibility = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, ulong>)&ISteamGameServer_ComputeNewPlayerCompatibility;
        VTable.SendUserConnectAndAuthenticate_DEPRECATED = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, uint, IntPtr, uint, IntPtr, byte>)&ISteamGameServer_SendUserConnectAndAuthenticate_DEPRECATED;
        VTable.CreateUnauthenticatedUserConnection = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong>)&ISteamGameServer_CreateUnauthenticatedUserConnection;
        VTable.SendUserDisconnect_DEPRECATED = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, void>)&ISteamGameServer_SendUserDisconnect_DEPRECATED;
        VTable.BUpdateUserData = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, IntPtr, uint, byte>)&ISteamGameServer_BUpdateUserData;
    }

    public static IntPtr Create(ISteamGameServerLogic logic)
    {
        var handle = GCHandle.Alloc(logic);
        var ptr = Marshal.AllocHGlobal(IntPtr.Size * 2);
        *(IntPtr*)ptr = VTablePtr;
        *(IntPtr*)((byte*)ptr + IntPtr.Size) = GCHandle.ToIntPtr(handle);
        return ptr;
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamGameServer_SetProduct(IntPtr pThis, IntPtr pszProduct)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamGameServerLogic)handle.Target!;
        return logic.SetProduct(pszProduct);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamGameServer_SetGameDescription(IntPtr pThis, IntPtr pszGameDescription)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamGameServerLogic)handle.Target!;
        return logic.SetGameDescription(pszGameDescription);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamGameServer_SetModDir(IntPtr pThis, IntPtr pszModDir)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamGameServerLogic)handle.Target!;
        return logic.SetModDir(pszModDir);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamGameServer_SetDedicatedServer(IntPtr pThis, byte bDedicated)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamGameServerLogic)handle.Target!;
        return logic.SetDedicatedServer(bDedicated);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamGameServer_LogOn(IntPtr pThis, IntPtr pszToken)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamGameServerLogic)handle.Target!;
        return logic.LogOn(pszToken);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamGameServer_LogOnAnonymous(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamGameServerLogic)handle.Target!;
        return logic.LogOnAnonymous();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamGameServer_LogOff(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamGameServerLogic)handle.Target!;
        return logic.LogOff();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamGameServer_BLoggedOn(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamGameServerLogic)handle.Target!;
        return logic.BLoggedOn();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamGameServer_BSecure(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamGameServerLogic)handle.Target!;
        return logic.BSecure();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamGameServer_GetSteamID(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamGameServerLogic)handle.Target!;
        return logic.GetSteamID();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamGameServer_WasRestartRequested(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamGameServerLogic)handle.Target!;
        return logic.WasRestartRequested();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamGameServer_SetMaxPlayerCount(IntPtr pThis, int cPlayersMax)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamGameServerLogic)handle.Target!;
        return logic.SetMaxPlayerCount(cPlayersMax);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamGameServer_SetBotPlayerCount(IntPtr pThis, int cBotplayers)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamGameServerLogic)handle.Target!;
        return logic.SetBotPlayerCount(cBotplayers);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamGameServer_SetServerName(IntPtr pThis, IntPtr pszServerName)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamGameServerLogic)handle.Target!;
        return logic.SetServerName(pszServerName);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamGameServer_SetMapName(IntPtr pThis, IntPtr pszMapName)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamGameServerLogic)handle.Target!;
        return logic.SetMapName(pszMapName);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamGameServer_SetPasswordProtected(IntPtr pThis, byte bPasswordProtected)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamGameServerLogic)handle.Target!;
        return logic.SetPasswordProtected(bPasswordProtected);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamGameServer_SetSpectatorPort(IntPtr pThis, int unSpectatorPort)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamGameServerLogic)handle.Target!;
        return logic.SetSpectatorPort(unSpectatorPort);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamGameServer_SetSpectatorServerName(IntPtr pThis, IntPtr pszSpectatorServerName)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamGameServerLogic)handle.Target!;
        return logic.SetSpectatorServerName(pszSpectatorServerName);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamGameServer_ClearAllKeyValues(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamGameServerLogic)handle.Target!;
        return logic.ClearAllKeyValues();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamGameServer_SetKeyValue(IntPtr pThis, IntPtr pKey, IntPtr pValue)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamGameServerLogic)handle.Target!;
        return logic.SetKeyValue(pKey, pValue);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamGameServer_SetGameTags(IntPtr pThis, IntPtr pchGameTags)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamGameServerLogic)handle.Target!;
        return logic.SetGameTags(pchGameTags);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamGameServer_SetGameData(IntPtr pThis, IntPtr pchGameData)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamGameServerLogic)handle.Target!;
        return logic.SetGameData(pchGameData);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamGameServer_SetRegion(IntPtr pThis, IntPtr pszRegion)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamGameServerLogic)handle.Target!;
        return logic.SetRegion(pszRegion);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamGameServer_SetAdvertiseServerActive(IntPtr pThis, byte bActive)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamGameServerLogic)handle.Target!;
        return logic.SetAdvertiseServerActive(bActive);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static uint ISteamGameServer_GetAuthSessionTicket(IntPtr pThis, IntPtr pTicket, int cbMaxTicket, IntPtr pcbTicket, IntPtr pSnid)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamGameServerLogic)handle.Target!;
        return logic.GetAuthSessionTicket(pTicket, cbMaxTicket, pcbTicket, pSnid);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamGameServer_BeginAuthSession(IntPtr pThis, IntPtr pAuthTicket, int cbAuthTicket, ulong steamID)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamGameServerLogic)handle.Target!;
        return logic.BeginAuthSession(pAuthTicket, cbAuthTicket, steamID);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamGameServer_EndAuthSession(IntPtr pThis, ulong steamID)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamGameServerLogic)handle.Target!;
        return logic.EndAuthSession(steamID);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamGameServer_CancelAuthTicket(IntPtr pThis, uint hAuthTicket)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamGameServerLogic)handle.Target!;
        return logic.CancelAuthTicket(hAuthTicket);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamGameServer_UserHasLicenseForApp(IntPtr pThis, ulong steamID, int appID)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamGameServerLogic)handle.Target!;
        return logic.UserHasLicenseForApp(steamID, appID);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamGameServer_RequestUserGroupStatus(IntPtr pThis, ulong steamIDUser, ulong steamIDGroup)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamGameServerLogic)handle.Target!;
        return logic.RequestUserGroupStatus(steamIDUser, steamIDGroup);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamGameServer_GetGameplayStats(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamGameServerLogic)handle.Target!;
        return logic.GetGameplayStats();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamGameServer_GetServerReputation(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamGameServerLogic)handle.Target!;
        return logic.GetServerReputation();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamGameServer_GetPublicIP(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamGameServerLogic)handle.Target!;
        return logic.GetPublicIP();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamGameServer_HandleIncomingPacket(IntPtr pThis, IntPtr pData, int cbData, uint srcIP, int srcPort)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamGameServerLogic)handle.Target!;
        return logic.HandleIncomingPacket(pData, cbData, srcIP, srcPort);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamGameServer_GetNextOutgoingPacket(IntPtr pThis, IntPtr pOut, int cbMaxOut, IntPtr pNetAdr, IntPtr pPort)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamGameServerLogic)handle.Target!;
        return logic.GetNextOutgoingPacket(pOut, cbMaxOut, pNetAdr, pPort);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamGameServer_AssociateWithClan(IntPtr pThis, ulong steamIDClan)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamGameServerLogic)handle.Target!;
        return logic.AssociateWithClan(steamIDClan);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamGameServer_ComputeNewPlayerCompatibility(IntPtr pThis, ulong steamIDNewPlayer)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamGameServerLogic)handle.Target!;
        return logic.ComputeNewPlayerCompatibility(steamIDNewPlayer);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamGameServer_SendUserConnectAndAuthenticate_DEPRECATED(IntPtr pThis, uint unIPClient, IntPtr pvAuthBlob, uint cubAuthBlobSize, IntPtr pSteamIDUser)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamGameServerLogic)handle.Target!;
        return logic.SendUserConnectAndAuthenticate_DEPRECATED(unIPClient, pvAuthBlob, cubAuthBlobSize, pSteamIDUser);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamGameServer_CreateUnauthenticatedUserConnection(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamGameServerLogic)handle.Target!;
        return logic.CreateUnauthenticatedUserConnection();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamGameServer_SendUserDisconnect_DEPRECATED(IntPtr pThis, ulong steamIDUser)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamGameServerLogic)handle.Target!;
        return logic.SendUserDisconnect_DEPRECATED(steamIDUser);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamGameServer_BUpdateUserData(IntPtr pThis, ulong steamIDUser, IntPtr pchPlayerName, uint uScore)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamGameServerLogic)handle.Target!;
        return logic.BUpdateUserData(steamIDUser, pchPlayerName, uScore);
    }
}

public unsafe class ISteamGameServerStatsShim
{
    public static ISteamGameServerStatsVTable VTable;
    public static IntPtr VTablePtr;

    static ISteamGameServerStatsShim()
    {
        VTablePtr = (IntPtr)Unsafe.AsPointer(ref VTable);
        VTable.RequestUserStats = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, ulong>)&ISteamGameServerStats_RequestUserStats;
        VTable.GetUserStat = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, IntPtr, IntPtr, byte>)&ISteamGameServerStats_GetUserStat;
        VTable.GetUserStat = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, IntPtr, IntPtr, byte>)&ISteamGameServerStats_GetUserStat;
        VTable.GetUserAchievement = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, IntPtr, IntPtr, byte>)&ISteamGameServerStats_GetUserAchievement;
        VTable.SetUserStat = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, IntPtr, int, byte>)&ISteamGameServerStats_SetUserStat;
        VTable.SetUserStat = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, IntPtr, int, byte>)&ISteamGameServerStats_SetUserStat;
        VTable.UpdateUserAvgRateStat = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, IntPtr, int, int, byte>)&ISteamGameServerStats_UpdateUserAvgRateStat;
        VTable.SetUserAchievement = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, IntPtr, byte>)&ISteamGameServerStats_SetUserAchievement;
        VTable.ClearUserAchievement = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, IntPtr, byte>)&ISteamGameServerStats_ClearUserAchievement;
        VTable.StoreUserStats = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, ulong, ulong>)&ISteamGameServerStats_StoreUserStats;
    }

    public static IntPtr Create(ISteamGameServerStatsLogic logic)
    {
        var handle = GCHandle.Alloc(logic);
        var ptr = Marshal.AllocHGlobal(IntPtr.Size * 2);
        *(IntPtr*)ptr = VTablePtr;
        *(IntPtr*)((byte*)ptr + IntPtr.Size) = GCHandle.ToIntPtr(handle);
        return ptr;
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamGameServerStats_RequestUserStats(IntPtr pThis, ulong steamIDUser)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamGameServerStatsLogic)handle.Target!;
        return logic.RequestUserStats(steamIDUser);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamGameServerStats_GetUserStat(IntPtr pThis, ulong steamIDUser, IntPtr pchName, IntPtr pData)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamGameServerStatsLogic)handle.Target!;
        return logic.GetUserStat(steamIDUser, pchName, pData);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamGameServerStats_GetUserStat(IntPtr pThis, ulong steamIDUser, IntPtr pchName, IntPtr pData)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamGameServerStatsLogic)handle.Target!;
        return logic.GetUserStat(steamIDUser, pchName, pData);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamGameServerStats_GetUserAchievement(IntPtr pThis, ulong steamIDUser, IntPtr pchName, IntPtr pbAchieved)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamGameServerStatsLogic)handle.Target!;
        return logic.GetUserAchievement(steamIDUser, pchName, pbAchieved);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamGameServerStats_SetUserStat(IntPtr pThis, ulong steamIDUser, IntPtr pchName, int nData)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamGameServerStatsLogic)handle.Target!;
        return logic.SetUserStat(steamIDUser, pchName, nData);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamGameServerStats_SetUserStat(IntPtr pThis, ulong steamIDUser, IntPtr pchName, int fData)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamGameServerStatsLogic)handle.Target!;
        return logic.SetUserStat(steamIDUser, pchName, fData);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamGameServerStats_UpdateUserAvgRateStat(IntPtr pThis, ulong steamIDUser, IntPtr pchName, int flCountThisSession, int dSessionLength)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamGameServerStatsLogic)handle.Target!;
        return logic.UpdateUserAvgRateStat(steamIDUser, pchName, flCountThisSession, dSessionLength);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamGameServerStats_SetUserAchievement(IntPtr pThis, ulong steamIDUser, IntPtr pchName)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamGameServerStatsLogic)handle.Target!;
        return logic.SetUserAchievement(steamIDUser, pchName);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static byte ISteamGameServerStats_ClearUserAchievement(IntPtr pThis, ulong steamIDUser, IntPtr pchName)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamGameServerStatsLogic)handle.Target!;
        return logic.ClearUserAchievement(steamIDUser, pchName);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static ulong ISteamGameServerStats_StoreUserStats(IntPtr pThis, ulong steamIDUser)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamGameServerStatsLogic)handle.Target!;
        return logic.StoreUserStats(steamIDUser);
    }
}

public unsafe class ISteamNetworkingFakeUDPPortShim
{
    public static ISteamNetworkingFakeUDPPortVTable VTable;
    public static IntPtr VTablePtr;

    static ISteamNetworkingFakeUDPPortShim()
    {
        VTablePtr = (IntPtr)Unsafe.AsPointer(ref VTable);
        VTable.DestroyFakeUDPPort = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, void>)&ISteamNetworkingFakeUDPPort_DestroyFakeUDPPort;
        VTable.SendMessageToFakeIP = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, IntPtr, uint, int, int>)&ISteamNetworkingFakeUDPPort_SendMessageToFakeIP;
        VTable.ReceiveMessages = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, IntPtr, int, int>)&ISteamNetworkingFakeUDPPort_ReceiveMessages;
        VTable.ScheduleCleanup = (IntPtr)(delegate* unmanaged[Cdecl]<IntPtr, int, void>)&ISteamNetworkingFakeUDPPort_ScheduleCleanup;
    }

    public static IntPtr Create(ISteamNetworkingFakeUDPPortLogic logic)
    {
        var handle = GCHandle.Alloc(logic);
        var ptr = Marshal.AllocHGlobal(IntPtr.Size * 2);
        *(IntPtr*)ptr = VTablePtr;
        *(IntPtr*)((byte*)ptr + IntPtr.Size) = GCHandle.ToIntPtr(handle);
        return ptr;
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamNetworkingFakeUDPPort_DestroyFakeUDPPort(IntPtr pThis)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingFakeUDPPortLogic)handle.Target!;
        return logic.DestroyFakeUDPPort();
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamNetworkingFakeUDPPort_SendMessageToFakeIP(IntPtr pThis, int remoteAddress, IntPtr pData, uint cbData, int nSendFlags)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingFakeUDPPortLogic)handle.Target!;
        return logic.SendMessageToFakeIP(remoteAddress, pData, cbData, nSendFlags);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static int ISteamNetworkingFakeUDPPort_ReceiveMessages(IntPtr pThis, IntPtr ppOutMessages, int nMaxMessages)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingFakeUDPPortLogic)handle.Target!;
        return logic.ReceiveMessages(ppOutMessages, nMaxMessages);
    }

    [UnmanagedCallersOnly(CallConvs = [typeof(CallConvCdecl)])]
    public static void ISteamNetworkingFakeUDPPort_ScheduleCleanup(IntPtr pThis, int remoteAddress)
    {
        var handlePtr = *(IntPtr*)((byte*)pThis + IntPtr.Size);
        var handle = GCHandle.FromIntPtr(handlePtr);
        var logic = (ISteamNetworkingFakeUDPPortLogic)handle.Target!;
        return logic.ScheduleCleanup(remoteAddress);
    }
}

